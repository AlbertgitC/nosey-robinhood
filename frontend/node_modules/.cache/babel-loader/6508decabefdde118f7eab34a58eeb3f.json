{"ast":null,"code":"'use strict';\n\nvar $ = require('./$'),\n    LIBRARY = require('./$.library'),\n    global = require('./$.global'),\n    ctx = require('./$.ctx'),\n    classof = require('./$.classof'),\n    $export = require('./$.export'),\n    isObject = require('./$.is-object'),\n    anObject = require('./$.an-object'),\n    aFunction = require('./$.a-function'),\n    strictNew = require('./$.strict-new'),\n    forOf = require('./$.for-of'),\n    setProto = require('./$.set-proto').set,\n    same = require('./$.same-value'),\n    SPECIES = require('./$.wks')('species'),\n    speciesConstructor = require('./$.species-constructor'),\n    asap = require('./$.microtask'),\n    PROMISE = 'Promise',\n    process = global.process,\n    isNode = classof(process) == 'process',\n    P = global[PROMISE],\n    empty = function () {\n  /* empty */\n},\n    Wrapper;\n\nvar testResolve = function (sub) {\n  var test = new P(empty),\n      promise;\n  if (sub) test.constructor = function (exec) {\n    exec(empty, empty);\n  };\n  (promise = P.resolve(test))['catch'](empty);\n  return promise === test;\n};\n\nvar USE_NATIVE = function () {\n  var works = false;\n\n  function P2(x) {\n    var self = new P(x);\n    setProto(self, P2.prototype);\n    return self;\n  }\n\n  try {\n    works = P && P.resolve && testResolve();\n    setProto(P2, P);\n    P2.prototype = $.create(P.prototype, {\n      constructor: {\n        value: P2\n      }\n    }); // actual Firefox has broken subclass support, test that\n\n    if (!(P2.resolve(5).then(function () {}) instanceof P2)) {\n      works = false;\n    } // actual V8 bug, https://code.google.com/p/v8/issues/detail?id=4162\n\n\n    if (works && require('./$.descriptors')) {\n      var thenableThenGotten = false;\n      P.resolve($.setDesc({}, 'then', {\n        get: function () {\n          thenableThenGotten = true;\n        }\n      }));\n      works = thenableThenGotten;\n    }\n  } catch (e) {\n    works = false;\n  }\n\n  return works;\n}(); // helpers\n\n\nvar sameConstructor = function (a, b) {\n  // library wrapper special case\n  if (LIBRARY && a === P && b === Wrapper) return true;\n  return same(a, b);\n};\n\nvar getConstructor = function (C) {\n  var S = anObject(C)[SPECIES];\n  return S != undefined ? S : C;\n};\n\nvar isThenable = function (it) {\n  var then;\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\n\nvar PromiseCapability = function (C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aFunction(resolve), this.reject = aFunction(reject);\n};\n\nvar perform = function (exec) {\n  try {\n    exec();\n  } catch (e) {\n    return {\n      error: e\n    };\n  }\n};\n\nvar notify = function (record, isReject) {\n  if (record.n) return;\n  record.n = true;\n  var chain = record.c;\n  asap(function () {\n    var value = record.v,\n        ok = record.s == 1,\n        i = 0;\n\n    var run = function (reaction) {\n      var handler = ok ? reaction.ok : reaction.fail,\n          resolve = reaction.resolve,\n          reject = reaction.reject,\n          result,\n          then;\n\n      try {\n        if (handler) {\n          if (!ok) record.h = true;\n          result = handler === true ? value : handler(value);\n\n          if (result === reaction.promise) {\n            reject(TypeError('Promise-chain cycle'));\n          } else if (then = isThenable(result)) {\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch (e) {\n        reject(e);\n      }\n    };\n\n    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach\n\n\n    chain.length = 0;\n    record.n = false;\n    if (isReject) setTimeout(function () {\n      var promise = record.p,\n          handler,\n          console;\n\n      if (isUnhandled(promise)) {\n        if (isNode) {\n          process.emit('unhandledRejection', value, promise);\n        } else if (handler = global.onunhandledrejection) {\n          handler({\n            promise: promise,\n            reason: value\n          });\n        } else if ((console = global.console) && console.error) {\n          console.error('Unhandled promise rejection', value);\n        }\n      }\n\n      record.a = undefined;\n    }, 1);\n  });\n};\n\nvar isUnhandled = function (promise) {\n  var record = promise._d,\n      chain = record.a || record.c,\n      i = 0,\n      reaction;\n  if (record.h) return false;\n\n  while (chain.length > i) {\n    reaction = chain[i++];\n    if (reaction.fail || !isUnhandled(reaction.promise)) return false;\n  }\n\n  return true;\n};\n\nvar $reject = function (value) {\n  var record = this;\n  if (record.d) return;\n  record.d = true;\n  record = record.r || record; // unwrap\n\n  record.v = value;\n  record.s = 2;\n  record.a = record.c.slice();\n  notify(record, true);\n};\n\nvar $resolve = function (value) {\n  var record = this,\n      then;\n  if (record.d) return;\n  record.d = true;\n  record = record.r || record; // unwrap\n\n  try {\n    if (record.p === value) throw TypeError(\"Promise can't be resolved itself\");\n\n    if (then = isThenable(value)) {\n      asap(function () {\n        var wrapper = {\n          r: record,\n          d: false\n        }; // wrap\n\n        try {\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n        } catch (e) {\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      record.v = value;\n      record.s = 1;\n      notify(record, false);\n    }\n  } catch (e) {\n    $reject.call({\n      r: record,\n      d: false\n    }, e); // wrap\n  }\n}; // constructor polyfill\n\n\nif (!USE_NATIVE) {\n  // 25.4.3.1 Promise(executor)\n  P = function Promise(executor) {\n    aFunction(executor);\n    var record = this._d = {\n      p: strictNew(this, P, PROMISE),\n      // <- promise\n      c: [],\n      // <- awaiting reactions\n      a: undefined,\n      // <- checked in isUnhandled reactions\n      s: 0,\n      // <- state\n      d: false,\n      // <- done\n      v: undefined,\n      // <- value\n      h: false,\n      // <- handled rejection\n      n: false // <- notify\n\n    };\n\n    try {\n      executor(ctx($resolve, record, 1), ctx($reject, record, 1));\n    } catch (err) {\n      $reject.call(record, err);\n    }\n  };\n\n  require('./$.redefine-all')(P.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected) {\n      var reaction = new PromiseCapability(speciesConstructor(this, P)),\n          promise = reaction.promise,\n          record = this._d;\n      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail = typeof onRejected == 'function' && onRejected;\n      record.c.push(reaction);\n      if (record.a) record.a.push(reaction);\n      if (record.s) notify(record, false);\n      return promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function (onRejected) {\n      return this.then(undefined, onRejected);\n    }\n  });\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, {\n  Promise: P\n});\n\nrequire('./$.set-to-string-tag')(P, PROMISE);\n\nrequire('./$.set-species')(PROMISE);\n\nWrapper = require('./$.core')[PROMISE]; // statics\n\n$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r) {\n    var capability = new PromiseCapability(this),\n        $$reject = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x) {\n    // instanceof instead of internal slot check because we should fix it without replacement native Promise core\n    if (x instanceof P && sameConstructor(x.constructor, this)) return x;\n    var capability = new PromiseCapability(this),\n        $$resolve = capability.resolve;\n    $$resolve(x);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * !(USE_NATIVE && require('./$.iter-detect')(function (iter) {\n  P.all(iter)['catch'](function () {});\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable) {\n    var C = getConstructor(this),\n        capability = new PromiseCapability(C),\n        resolve = capability.resolve,\n        reject = capability.reject,\n        values = [];\n    var abrupt = perform(function () {\n      forOf(iterable, false, values.push, values);\n      var remaining = values.length,\n          results = Array(remaining);\n      if (remaining) $.each.call(values, function (promise, index) {\n        var alreadyCalled = false;\n        C.resolve(promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          results[index] = value;\n          --remaining || resolve(results);\n        }, reject);\n      });else resolve(results);\n    });\n    if (abrupt) reject(abrupt.error);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable) {\n    var C = getConstructor(this),\n        capability = new PromiseCapability(C),\n        reject = capability.reject;\n    var abrupt = perform(function () {\n      forOf(iterable, false, function (promise) {\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if (abrupt) reject(abrupt.error);\n    return capability.promise;\n  }\n});","map":null,"metadata":{},"sourceType":"script"}