{"ast":null,"code":"\"use strict\";\n\nvar MongoError = require('../error'); // Wire command operation ids\n\n\nvar OP_UPDATE = 2001;\nvar OP_INSERT = 2002;\nvar OP_DELETE = 2006;\n\nvar Insert = function (requestId, ismaster, bson, ns, documents, options) {\n  // Basic options needed to be passed in\n  if (ns == null) throw new MongoError(\"ns must be specified for query\");\n  if (!Array.isArray(documents) || documents.length == 0) throw new MongoError(\"documents array must contain at least one document to insert\"); // Validate that we are not passing 0x00 in the colletion name\n\n  if (!!~ns.indexOf(\"\\x00\")) {\n    throw new MongoError(\"namespace cannot contain a null character\");\n  } // Set internal\n\n\n  this.requestId = requestId;\n  this.bson = bson;\n  this.ns = ns;\n  this.documents = documents;\n  this.ismaster = ismaster; // Ensure empty options\n\n  options = options || {}; // Unpack options\n\n  this.serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;\n  this.ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false;\n  this.checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys : true;\n  this.continueOnError = typeof options.continueOnError == 'boolean' ? options.continueOnError : false; // Set flags\n\n  this.flags = this.continueOnError ? 1 : 0;\n}; // To Binary\n\n\nInsert.prototype.toBin = function () {\n  // Contains all the buffers to be written\n  var buffers = []; // Header buffer\n\n  var header = new Buffer(4 * 4 // Header\n  + 4 // Flags\n  + Buffer.byteLength(this.ns) + 1 // namespace\n  ); // Add header to buffers\n\n  buffers.push(header); // Total length of the message\n\n  var totalLength = header.length; // Serialize all the documents\n\n  for (var i = 0; i < this.documents.length; i++) {\n    var buffer = this.bson.serialize(this.documents[i], this.checkKeys, true, this.serializeFunctions, 0, this.ignoreUndefined); // Document is larger than maxBsonObjectSize, terminate serialization\n\n    if (buffer.length > this.ismaster.maxBsonObjectSize) {\n      throw new MongoError(\"Document exceeds maximum allowed bson size of \" + this.ismaster.maxBsonObjectSize + \" bytes\");\n    } // Add to total length of wire protocol message\n\n\n    totalLength = totalLength + buffer.length; // Add to buffer\n\n    buffers.push(buffer);\n  } // Command is larger than maxMessageSizeBytes terminate serialization\n\n\n  if (totalLength > this.ismaster.maxMessageSizeBytes) {\n    throw new MongoError(\"Command exceeds maximum message size of \" + this.ismaster.maxMessageSizeBytes + \" bytes\");\n  } // Add all the metadata\n\n\n  var index = 0; // Write header length\n\n  header[index + 3] = totalLength >> 24 & 0xff;\n  header[index + 2] = totalLength >> 16 & 0xff;\n  header[index + 1] = totalLength >> 8 & 0xff;\n  header[index] = totalLength & 0xff;\n  index = index + 4; // Write header requestId\n\n  header[index + 3] = this.requestId >> 24 & 0xff;\n  header[index + 2] = this.requestId >> 16 & 0xff;\n  header[index + 1] = this.requestId >> 8 & 0xff;\n  header[index] = this.requestId & 0xff;\n  index = index + 4; // No flags\n\n  header[index + 3] = 0 >> 24 & 0xff;\n  header[index + 2] = 0 >> 16 & 0xff;\n  header[index + 1] = 0 >> 8 & 0xff;\n  header[index] = 0 & 0xff;\n  index = index + 4; // Operation\n\n  header[index + 3] = OP_INSERT >> 24 & 0xff;\n  header[index + 2] = OP_INSERT >> 16 & 0xff;\n  header[index + 1] = OP_INSERT >> 8 & 0xff;\n  header[index] = OP_INSERT & 0xff;\n  index = index + 4; // Flags\n\n  header[index + 3] = this.flags >> 24 & 0xff;\n  header[index + 2] = this.flags >> 16 & 0xff;\n  header[index + 1] = this.flags >> 8 & 0xff;\n  header[index] = this.flags & 0xff;\n  index = index + 4; // Write collection name\n\n  index = index + header.write(this.ns, index, 'utf8') + 1;\n  header[index - 1] = 0; // Return the buffers\n\n  return buffers;\n};\n\nvar Update = function (requestId, ismaster, bson, ns, update, options) {\n  // Basic options needed to be passed in\n  if (ns == null) throw new MongoError(\"ns must be specified for query\"); // Ensure empty options\n\n  options = options || {}; // Set internal\n\n  this.requestId = requestId;\n  this.bson = bson;\n  this.ns = ns;\n  this.ismaster = ismaster; // Unpack options\n\n  this.serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;\n  this.ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false;\n  this.checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys : false; // Unpack the update document\n\n  this.upsert = typeof update[0].upsert == 'boolean' ? update[0].upsert : false;\n  this.multi = typeof update[0].multi == 'boolean' ? update[0].multi : false;\n  this.q = update[0].q;\n  this.u = update[0].u; // Create flag value\n\n  this.flags = this.upsert ? 1 : 0;\n  this.flags = this.multi ? this.flags | 2 : this.flags;\n}; // To Binary\n\n\nUpdate.prototype.toBin = function () {\n  // Contains all the buffers to be written\n  var buffers = []; // Header buffer\n\n  var header = new Buffer(4 * 4 // Header\n  + 4 // ZERO\n  + Buffer.byteLength(this.ns) + 1 // namespace\n  + 4 // Flags\n  ); // Add header to buffers\n\n  buffers.push(header); // Total length of the message\n\n  var totalLength = header.length; // Serialize the selector\n\n  var selector = this.bson.serialize(this.q, this.checkKeys, true, this.serializeFunctions, 0, this.ignoreUndefined);\n  buffers.push(selector);\n  totalLength = totalLength + selector.length; // Serialize the update\n\n  var update = this.bson.serialize(this.u, this.checkKeys, true, this.serializeFunctions, 0, this.ignoreUndefined);\n  buffers.push(update);\n  totalLength = totalLength + update.length; // Index in header buffer\n\n  var index = 0; // Write header length\n\n  header[index + 3] = totalLength >> 24 & 0xff;\n  header[index + 2] = totalLength >> 16 & 0xff;\n  header[index + 1] = totalLength >> 8 & 0xff;\n  header[index] = totalLength & 0xff;\n  index = index + 4; // Write header requestId\n\n  header[index + 3] = this.requestId >> 24 & 0xff;\n  header[index + 2] = this.requestId >> 16 & 0xff;\n  header[index + 1] = this.requestId >> 8 & 0xff;\n  header[index] = this.requestId & 0xff;\n  index = index + 4; // No flags\n\n  header[index + 3] = 0 >> 24 & 0xff;\n  header[index + 2] = 0 >> 16 & 0xff;\n  header[index + 1] = 0 >> 8 & 0xff;\n  header[index] = 0 & 0xff;\n  index = index + 4; // Operation\n\n  header[index + 3] = OP_UPDATE >> 24 & 0xff;\n  header[index + 2] = OP_UPDATE >> 16 & 0xff;\n  header[index + 1] = OP_UPDATE >> 8 & 0xff;\n  header[index] = OP_UPDATE & 0xff;\n  index = index + 4; // Write ZERO\n\n  header[index + 3] = 0 >> 24 & 0xff;\n  header[index + 2] = 0 >> 16 & 0xff;\n  header[index + 1] = 0 >> 8 & 0xff;\n  header[index] = 0 & 0xff;\n  index = index + 4; // Write collection name\n\n  index = index + header.write(this.ns, index, 'utf8') + 1;\n  header[index - 1] = 0; // Flags\n\n  header[index + 3] = this.flags >> 24 & 0xff;\n  header[index + 2] = this.flags >> 16 & 0xff;\n  header[index + 1] = this.flags >> 8 & 0xff;\n  header[index] = this.flags & 0xff;\n  index = index + 4; // Return the buffers\n\n  return buffers;\n};\n\nvar Remove = function (requestId, ismaster, bson, ns, remove, options) {\n  // Basic options needed to be passed in\n  if (ns == null) throw new MongoError(\"ns must be specified for query\"); // Ensure empty options\n\n  options = options || {}; // Set internal\n\n  this.requestId = requestId;\n  this.bson = bson;\n  this.ns = ns;\n  this.ismaster = ismaster; // Unpack options\n\n  this.serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false;\n  this.ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false;\n  this.checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys : false; // Unpack the update document\n\n  this.limit = typeof remove[0].limit == 'number' ? remove[0].limit : 1;\n  this.q = remove[0].q; // Create flag value\n\n  this.flags = this.limit == 1 ? 1 : 0;\n}; // To Binary\n\n\nRemove.prototype.toBin = function () {\n  // Contains all the buffers to be written\n  var buffers = []; // Header buffer\n\n  var header = new Buffer(4 * 4 // Header\n  + 4 // ZERO\n  + Buffer.byteLength(this.ns) + 1 // namespace\n  + 4 // Flags\n  ); // Add header to buffers\n\n  buffers.push(header); // Total length of the message\n\n  var totalLength = header.length; // Serialize the selector\n\n  var selector = this.bson.serialize(this.q, this.checkKeys, true, this.serializeFunctions, 0, this.ignoreUndefined);\n  buffers.push(selector);\n  totalLength = totalLength + selector.length; // Index in header buffer\n\n  var index = 0; // Write header length\n\n  header[index + 3] = totalLength >> 24 & 0xff;\n  header[index + 2] = totalLength >> 16 & 0xff;\n  header[index + 1] = totalLength >> 8 & 0xff;\n  header[index] = totalLength & 0xff;\n  index = index + 4; // Write header requestId\n\n  header[index + 3] = this.requestId >> 24 & 0xff;\n  header[index + 2] = this.requestId >> 16 & 0xff;\n  header[index + 1] = this.requestId >> 8 & 0xff;\n  header[index] = this.requestId & 0xff;\n  index = index + 4; // No flags\n\n  header[index + 3] = 0 >> 24 & 0xff;\n  header[index + 2] = 0 >> 16 & 0xff;\n  header[index + 1] = 0 >> 8 & 0xff;\n  header[index] = 0 & 0xff;\n  index = index + 4; // Operation\n\n  header[index + 3] = OP_DELETE >> 24 & 0xff;\n  header[index + 2] = OP_DELETE >> 16 & 0xff;\n  header[index + 1] = OP_DELETE >> 8 & 0xff;\n  header[index] = OP_DELETE & 0xff;\n  index = index + 4; // Write ZERO\n\n  header[index + 3] = 0 >> 24 & 0xff;\n  header[index + 2] = 0 >> 16 & 0xff;\n  header[index + 1] = 0 >> 8 & 0xff;\n  header[index] = 0 & 0xff;\n  index = index + 4; // Write collection name\n\n  index = index + header.write(this.ns, index, 'utf8') + 1;\n  header[index - 1] = 0; // Write ZERO\n\n  header[index + 3] = this.flags >> 24 & 0xff;\n  header[index + 2] = this.flags >> 16 & 0xff;\n  header[index + 1] = this.flags >> 8 & 0xff;\n  header[index] = this.flags & 0xff;\n  index = index + 4; // Return the buffers\n\n  return buffers;\n};\n\nmodule.exports = {\n  Insert: Insert,\n  Update: Update,\n  Remove: Remove\n};","map":null,"metadata":{},"sourceType":"script"}