{"ast":null,"code":"'use strict';\n\nvar assert = require('chai').assert;\n\nvar E = require('linq');\n\nvar SelectIterator = require('./src/iterators/select');\n\nvar MultiIterator = require('./src/iterators/multi');\n\nrequire('sugar');\n\nvar BabyParse = require('babyparse');\n\nvar extend = require('extend');\n\nvar DataFrame = require('./src/dataframe');\n\nvar Series = require('./src/series');\n\nvar E = require('linq');\n\nvar zip = require('./src/zip'); //\n// Records plugins that have been registered.\n//\n\n\nvar registeredPlugins = {};\n/**\r\n * Main namespace for Data-Forge.\r\n * \r\n * Nodejs:\r\n * \r\n * \t\tnpm install --save data-forge\r\n * \t\t\r\n * \t\tvar dataForge = require('data-forge');\r\n * \r\n * Browser:\r\n * \r\n * \t\tbower install --save data-forge\r\n * \r\n * \t\t<script language=\"javascript\" type=\"text/javascript\" src=\"bower_components/data-forge/data-forge.js\"></script>\r\n *\r\n * @namespace dataForge\r\n */\n\nvar dataForge = {\n  //\n  // Constructor for DataFrame.\n  //\n  DataFrame: DataFrame,\n  //\n  // Constructor for Series.\n  //\n  Series: Series,\n\n  /**\r\n   * Install a plugin in the dataForge namespace.\r\n   * \r\n   * @param {plugin-object} plugin - The plugin to add to data-forge.\r\n   * \r\n   * @returns {dataForge} Returns the dataForge API object so that calls to 'use' can be chained.\r\n   */\n  use: function (plugin) {\n    assert.isFunction(plugin, \"Expected 'plugin' parameter to 'use' to be a function.\");\n\n    if (registeredPlugins[plugin] === plugin) {\n      return; // Already registered.\n    }\n\n    registeredPlugins[plugin] = plugin;\n    var self = this;\n    plugin(self);\n    return self;\n  },\n\n  /**\r\n   * Deserialize a DataFrame from a JSON text string.\r\n   *\r\n   * @param {string} jsonTextString - The JSON text to deserialize.\r\n   * @param {config} [config] - Optional configuration option to pass to the DataFrame.\r\n   * \r\n   * @returns {DataFrame} Returns a dataframe that has been deserialized from the JSON data.\r\n   */\n  fromJSON: function (jsonTextString, config) {\n    assert.isString(jsonTextString, \"Expected 'jsonTextString' parameter to 'dataForge.fromJSON' to be a string containing data encoded in the JSON format.\");\n\n    if (config) {\n      assert.isObject(config, \"Expected 'config' parameter to 'dataForge.fromJSON' to be an object with configuration to pass to the DataFrame.\");\n    }\n\n    var baseConfig = {\n      values: JSON.parse(jsonTextString)\n    };\n    var dataFrameConfig = extend({}, config || {}, baseConfig);\n    return new DataFrame(dataFrameConfig);\n  },\n\n  /**\r\n   * Deserialize a DataFrame from a CSV text string.\r\n   *\r\n   * @param {string} csvTextString - The CSV text to deserialize.\r\n   * @param {config} [config] - Optional configuration option to pass to the DataFrame.\r\n   * \r\n   * @returns {DataFrame} Returns a dataframe that has been deserialized from the CSV data.\r\n   */\n  fromCSV: function (csvTextString, config) {\n    assert.isString(csvTextString, \"Expected 'csvTextString' parameter to 'dataForge.fromCSV' to be a string containing data encoded in the CSV format.\");\n\n    if (config) {\n      assert.isObject(config, \"Expected 'config' parameter to 'dataForge.fromJSON' to be an object with configuration to pass to the DataFrame.\");\n\n      if (config.columnNames) {\n        assert.isArray(config.columnNames, \"Expect 'columnNames' field of 'config' parameter to DataForge.fromCSV to be an array of strings that specify column names.\");\n        config.columnNames.forEach(function (columnName) {\n          assert.isString(columnName, \"Expect 'columnNames' field of 'config' parameter to DataForge.fromCSV to be an array of strings that specify column names.\");\n        });\n      }\n    }\n\n    var csvConfig = extend({}, config);\n    var parsed = BabyParse.parse(csvTextString, csvConfig);\n    var rows = parsed.data;\n    /* Old csv parsing.\r\n    var lines = csvTextString.split('\\n');\r\n    var rows = E\r\n    \t.from(lines) // Ignore blank lines.\r\n    \t.where(function (line) {\r\n    \t\treturn line.trim().length > 0;\r\n    \t})\r\n    \t.select(function (line) {\r\n    \t\treturn E\r\n    \t\t\t.from(line.split(','))\r\n    \t\t\t.select(function (col) {\r\n    \t\t\t\treturn col.trim();\r\n    \t\t\t})\r\n    \t\t\t.select(function (col) {\r\n    \t\t\t\tif (col.length === 0) {\r\n    \t\t\t\t\treturn undefined;\r\n    \t\t\t\t}\r\n    \t\t\t\telse {\r\n    \t\t\t\t\treturn col;\r\n    \t\t\t\t}\r\n    \t\t\t})\r\n    \t\t\t.toArray();\t\t\t\t\t\r\n    \t})\r\n    \t.toArray();\r\n    */\n\n    if (rows.length === 0) {\n      return new dataForge.DataFrame({\n        columnNames: [],\n        values: []\n      });\n    }\n\n    var columnNames;\n    rows = E.from(rows).select(function (row) {\n      return E.from(row).select(function (cell) {\n        return cell.trim(); // Trim each cell.\n      }).toArray();\n    }).toArray();\n\n    if (config && config.columnNames) {\n      columnNames = config.columnNames;\n    } else {\n      columnNames = E.from(E.from(rows).first()).select(function (columnName) {\n        return columnName.trim();\n      }).toArray();\n      rows = E.from(rows).skip(1) // Skip header.\n      .toArray();\n    }\n\n    var baseConfig = {\n      columnNames: columnNames,\n      values: rows\n    };\n    var dataFrameConfig = extend({}, config || {}, baseConfig);\n    return new dataForge.DataFrame(dataFrameConfig);\n  },\n\n  /**\r\n   * Read a file asynchronously from the file system.\r\n   * Works in Nodejs, doesn't work in the browser.\r\n   * \r\n   * @param {string} filePath - The path to the file to read.\r\n   * \r\n   * @returns {object} file - Returns an object that represents the file. Use `parseCSV` or `parseJSON` to deserialize to a DataFrame.\r\n   */\n  readFile: function (filePath) {\n    assert.isString(filePath, \"Expected 'filePath' parameter to dataForge.readFileSync to be a string that specifies the path of the file to read.\");\n    return {\n      /**\r\n       * Deserialize a CSV file to a DataFrame.\r\n       * Returns a promise that later resolves to a DataFrame.\r\n       * \r\n       * @param {object} [config] - Optional configuration file for parsing.\r\n       * \r\n       * @returns {Promise<DataFrame>} Returns a promise of a dataframe loaded from the file. \r\n       */\n      parseCSV: function (config) {\n        if (config) {\n          assert.isObject(config, \"Expected optional 'config' parameter to dataForge.readFile(...).parseCSV(...) to be an object with configuration options for CSV parsing.\");\n        }\n\n        return new Promise(function (resolve, reject) {\n          var fs = require('fs');\n\n          fs.readFile(filePath, 'utf8', function (err, csvData) {\n            if (err) {\n              reject(err);\n              return;\n            }\n\n            resolve(dataForge.fromCSV(csvData, config));\n          });\n        });\n      },\n\n      /**\r\n       * Deserialize a JSON file to a DataFrame.\r\n       * Returns a promise that later resolves to a DataFrame.\r\n       * \r\n       * @param {object} [config] - Optional configuration file for parsing.\r\n       * \r\n       * @returns {Promise<DataFrame>} Returns a promise of a dataframe loaded from the file. \r\n       */\n      parseJSON: function (config) {\n        if (config) {\n          assert.isObject(config, \"Expected optional 'config' parameter to dataForge.readFile(...).parseJSON(...) to be an object with configuration options for JSON parsing.\");\n        }\n\n        return new Promise(function (resolve, reject) {\n          var fs = require('fs');\n\n          fs.readFile(filePath, 'utf8', function (err, data) {\n            if (err) {\n              reject(err);\n              return;\n            }\n\n            resolve(dataForge.fromJSON(data, config));\n          });\n        });\n      }\n    };\n  },\n\n  /**\r\n   * Read a file synchronously from the file system.\r\n   * Works in Nodejs, doesn't work in the browser.\r\n   * \r\n   * @param {string} filePath - The path to the file to read.\r\n   * \r\n   * @returns {object} Returns an object that represents the file. Use `parseCSV` or `parseJSON` to deserialize to a DataFrame.\r\n   */\n  readFileSync: function (filePath) {\n    assert.isString(filePath, \"Expected 'filePath' parameter to dataForge.readFileSync to be a string that specifies the path of the file to read.\");\n    return {\n      /**\r\n       * Deserialize a CSV file to a DataFrame.\r\n       * \r\n       * @param {object} [config] - Optional configuration file for parsing.\r\n       * \r\n       * @returns {DataFrame} Returns a dataframe that was deserialized from the file.  \r\n       */\n      parseCSV: function (config) {\n        if (config) {\n          assert.isObject(config, \"Expected optional 'config' parameter to dataForge.readFileSync(...).parseCSV(...) to be an object with configuration options for CSV parsing.\");\n        }\n\n        var fs = require('fs');\n\n        return dataForge.fromCSV(fs.readFileSync(filePath, 'utf8'), config);\n      },\n\n      /**\r\n       * Deserialize a JSON file to a DataFrame.\r\n       * \r\n       * @param {object} [config] - Optional configuration file for parsing.\r\n       * \r\n       * @returns {DataFrame} Returns a dataframe that was deserialized from the file.  \r\n       */\n      parseJSON: function (config) {\n        if (config) {\n          assert.isObject(config, \"Expected optional 'config' parameter to dataForge.readFileSync(...).parseJSON(...) to be an object with configuration options for JSON parsing.\");\n        }\n\n        var fs = require('fs');\n\n        return dataForge.fromJSON(fs.readFileSync(filePath, 'utf8'), config);\n      }\n    };\n  },\n\n  /**\r\n   * Deserialize a DataFrame from a REST API that returns data via HTTP GET.\r\n   * Works asynchronously, returns a promise.\r\n   * \r\n   * @param {string} url - URL for a REST API that returns data.\r\n   *   \r\n   * @returns {object} Returns an object that represents the response REST API. Use `parseCSV` or `parseJSON` to deserialize to a DataFrame.\r\n   */\n  httpGet: function (url) {\n    assert.isString(url, \"Expected 'url' parameter to DataForge.httpGet to be a string that specifies the URL of the REST API from which to request data.\");\n    return {\n      /**\r\n       * Deserialize a CSV data to a DataFrame.\r\n       * \r\n       * @param {object} [config] - Optional configuration file for parsing.\r\n       * \r\n       * @returns {Promise<DataFrame>} Returns a promise of a dataframe loaded from the REST API.  \r\n       */\n      parseCSV: function (config) {\n        if (config) {\n          assert.isObject(config, \"Expected optional 'config' parameter to dataForge.httpGet(...).parseCSV(...) to be an object with configuration options for CSV parsing.\");\n        }\n\n        var requestOptions = {\n          uri: url\n        };\n\n        var request = require('request-promise');\n\n        return request.get(requestOptions).then(function (data) {\n          return dataForge.fromCSV(data, config);\n        });\n      },\n\n      /**\r\n       * Deserialize JSON data to a DataFrame.\r\n       * \r\n       * @param {object} [config] - Optional configuration file for parsing.\r\n       * \r\n       * @returns {Promise<DataFrame>} Returns a promise of a dataframe loaded from the REST API.  \r\n       */\n      parseJSON: function (config) {\n        if (config) {\n          assert.isObject(config, \"Expected optional 'config' parameter to dataForge.httpGet(...).parseJSON(...) to be an object with configuration options for JSON parsing.\");\n        }\n\n        var requestOptions = {\n          uri: url,\n          json: true\n        };\n\n        var request = require('request-promise');\n\n        return request.get(requestOptions).then(function (data) {\n          assert.isArray(data, \"Expected response from REST API to be an array!\");\n          var dataFrameOptions = extend({\n            values: data\n          }, config || {});\n          return new DataFrame(dataFrameOptions);\n        });\n      }\n    };\n  },\n\n  /**\r\n   * Request a DataFrame from a MongoDB collection.\r\n   * \r\n   * @param {string} connectionString - MongoDB connection string that specifies the database to connect to.\r\n   * @param {string} collectionName - The name of the MongoDB collection to retreive data from.\r\n   *   \r\n   * @returns {Promise<DataFrame>} Returns a promise of a dataframe loaded from the database.\r\n   */\n  fromMongoDB: function (connectionString, collectionName) {\n    assert.isString(connectionString, \"Expected 'connectionString' parameter to dataForge.fromMongoDB to be a string that specifies the database to connect to.\");\n    assert.isString(collectionName, \"Expected 'collectionName' parameter to dataForge.fromMongoDB to be a string that specifies the collection to retreive data from.\");\n\n    var mongo = require('promised-mongo');\n\n    var db = mongo(connectionString, [collectionName]);\n    return db[collectionName].find().toArray().catch(function (err) {\n      return db.close() // An error occurred, but we still need to close the database.\n      .then(function () {\n        throw err; // Rethrow after trying to close database.\n      });\n    }).then(function (data) {\n      return db.close() // Finished with the database connection.\n      .then(function () {\n        return new DataFrame(data);\n      });\n    });\n  },\n\n  /**\r\n   * Concatenate multiple dataframes into a single dataframe.\r\n   *\r\n   * @param {array} dataFrames - Array of dataframes to concatenate.\r\n   * \r\n   * @returns {DataFrame} Returns the single concatendated dataframe. \r\n   */\n  concatDataFrames: require('./src/concat-dataframes'),\n\n  /**\r\n   * Concatenate multiple series into a single series.\r\n   * \r\n   * @param {array} series - Array of series to concatenate.\r\n   *\r\n   * @returns {Series} - Returns the single concatendated series.  \r\n   */\n  concatSeries: require('./src/concat-series'),\n\n  /**\r\n   * Generate a series from a range of numbers.\r\n   *\r\n   * @param {int} start - The value of the first number in the range.\r\n   * @param {int} count - The number of sequential values in the range.\r\n   * \r\n   * @returns {Series} Returns a series with a sequence of generated values. The series contains 'count' values beginning at 'start'. \r\n   */\n  range: function (start, count) {\n    assert.isNumber(start, \"Expect 'start' parameter to range function to be a number.\");\n    assert.isNumber(count, \"Expect 'count' parameter to range function to be a number.\");\n    return new Series({\n      values: function () {\n        var i = -1;\n        return {\n          //todo: should have a range iterator.\n          moveNext: function () {\n            return ++i < count;\n          },\n          getCurrent: function () {\n            return start + i;\n          }\n        };\n      }\n    });\n  },\n\n  /**\r\n   * Generate a data-frame containing a matrix of values.\r\n   *\r\n   * @param {int} numColumns - The number of columns in the data-frame.\r\n   * @param {int} numRows - The number of rows in the data-frame.\r\n   * @param {number} start - The starting value.\r\n   * @param {number} increment - The value to increment by for each new value.\r\n   * \r\n   * @returns {DataFrame} Returns a dataframe that contains a matrix of generated values.\r\n   */\n  matrix: function (numColumns, numRows, start, increment) {\n    return new DataFrame({\n      columnNames: E.range(1, numColumns).select(function (columnNumber) {\n        return columnNumber.toString();\n      }).toArray(),\n      values: function () {\n        var rowIndex = 0;\n        var nextValue = start;\n        var curRow = undefined;\n        return {\n          moveNext: function () {\n            if (rowIndex >= numRows) {\n              return false;\n            }\n\n            curRow = E.range(0, numColumns).select(function (columnIndex) {\n              return nextValue + columnIndex * increment;\n            }).toArray();\n            nextValue += numColumns * increment;\n            ++rowIndex;\n            return true;\n          },\n          getCurrent: function () {\n            return curRow;\n          }\n        };\n      }\n    });\n  },\n\n  /**\r\n   * Zip together multiple series to create a new series.\r\n   *\r\n   * @param {array} series - Array of series to zip together.\r\n   * @param {function} selector - Selector function that produces a new series based on the input series.\r\n   * \r\n   * @returns {Series} Returns a single series that is the combination of multiple input series that have been 'zipped' together by the 'selector' function.\r\n   */\n  zipSeries: function (series, selector) {\n    return zip(series, selector, function (config) {\n      return new Series(config);\n    });\n  },\n\n  /**\r\n   * Zip together multiple data-frames to create a new data-frame.\r\n   *\r\n   * @param {array} dataFrames - Array of data-frames to zip together.\r\n   * @param {function} selector - Selector function that produces a new data-frame based on the input data-frames.\r\n   * \r\n   * @returns {DataFrame} Returns a single dataframe that is the combination of multiple input dataframes that have been 'zipped' together by the 'selector' function.\r\n   */\n  zipDataFrames: function (dataFrames, selector) {\n    return zip(dataFrames, selector, function (config) {\n      return new DataFrame(config);\n    });\n  }\n};\nmodule.exports = dataForge;","map":null,"metadata":{},"sourceType":"script"}