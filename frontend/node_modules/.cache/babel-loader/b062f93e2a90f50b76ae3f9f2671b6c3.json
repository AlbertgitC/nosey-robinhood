{"ast":null,"code":"\"use strict\";\n\nvar Logger = require('../connection/logger'),\n    f = require('util').format,\n    ObjectId = require('bson').ObjectId,\n    MongoError = require('../error');\n\nvar DISCONNECTED = 'disconnected';\nvar CONNECTING = 'connecting';\nvar CONNECTED = 'connected';\nvar DESTROYED = 'destroyed';\n/**\n * Creates a new Replicaset State object\n * @class\n * @property {object} primary Primary property\n * @property {array} secondaries List of secondaries\n * @property {array} arbiters List of arbiters\n * @return {State} A cursor instance\n */\n\nvar State = function (replSet, options) {\n  this.replSet = replSet;\n  this.options = options;\n  this.secondaries = [];\n  this.arbiters = [];\n  this.passives = [];\n  this.primary = null; // Initial state is disconnected\n\n  this.state = DISCONNECTED; // Current electionId\n\n  this.electionId = null; // Get a logger instance\n\n  this.logger = Logger('ReplSet', options); // Unpacked options\n\n  this.id = options.id;\n  this.setName = options.setName;\n  this.connectingServers = {};\n  this.secondaryOnlyConnectionAllowed = options.secondaryOnlyConnectionAllowed; // Description of the Replicaset\n\n  this.replicasetDescription = null;\n};\n/**\n * Is there a secondary connected\n * @method\n * @return {boolean}\n */\n\n\nState.prototype.resetDescription = function () {\n  this.replicasetDescription = {\n    \"topologyType\": \"Unknown\",\n    \"servers\": []\n  };\n};\n\nfunction diff(previous, current) {\n  // Difference document\n  var diff = {\n    servers: []\n  }; // Got through all the servers\n\n  for (var i = 0; i < previous.servers.length; i++) {\n    var prevServer = previous.servers[i]; // Go through all current servers\n\n    for (var j = 0; j < current.servers.length; j++) {\n      var currServer = current.servers[j]; // Matching server\n\n      if (prevServer.address === currServer.address) {\n        // We had a change in state\n        if (prevServer.type != currServer.type) {\n          diff.servers.push({\n            address: prevServer.address,\n            from: prevServer.type,\n            to: currServer.type\n          });\n        }\n      }\n    }\n  } // Return difference\n\n\n  return diff;\n}\n\nfunction emitTopologyDescriptionChanged(self) {\n  if (self.replSet.listeners('topologyDescriptionChanged').length > 0) {\n    var topology = 'Unknown';\n    var setName = self.setName;\n\n    if (self.isPrimaryConnected() && self.isSecondaryConnected()) {\n      topology = 'ReplicaSetWithPrimary';\n    } else if (!self.isPrimaryConnected() && self.isSecondaryConnected()) {\n      topology = 'ReplicaSetNoPrimary';\n    } // Generate description\n\n\n    var description = {\n      topologyType: topology,\n      setName: setName,\n      servers: []\n    }; // Add the primary to the list\n\n    if (self.isPrimaryConnected()) {\n      var desc = self.primary.getDescription();\n      desc.type = 'RSPrimary';\n      description.servers.push(desc);\n    } // Add all the secondaries\n\n\n    description.servers = description.servers.concat(self.secondaries.map(function (x) {\n      var description = x.getDescription();\n      description.type = 'RSSecondary';\n      return description;\n    })); // Add all the arbiters\n\n    description.servers = description.servers.concat(self.arbiters.map(function (x) {\n      var description = x.getDescription();\n      return description;\n    })); // Add all the passives\n\n    description.servers = description.servers.concat(self.passives.map(function (x) {\n      var description = x.getDescription();\n      description.type = 'RSSecondary';\n      return description;\n    })); // Create the result\n\n    var result = {\n      topologyId: self.id,\n      previousDescription: self.replicasetDescription,\n      newDescription: description,\n      diff: diff(self.replicasetDescription, description)\n    }; // Emit the topologyDescription change\n\n    self.replSet.emit('topologyDescriptionChanged', result); // Set the new description\n\n    self.replicasetDescription = description;\n  }\n}\n/**\n * Is there a secondary connected\n * @method\n * @return {boolean}\n */\n\n\nState.prototype.isSecondaryConnected = function () {\n  for (var i = 0; i < this.secondaries.length; i++) {\n    if (this.secondaries[i].isConnected()) return true;\n  }\n\n  return false;\n};\n/**\n * Is there a primary connection\n * @method\n * @return {boolean}\n */\n\n\nState.prototype.isPrimaryConnected = function () {\n  return this.primary != null && this.primary.isConnected();\n};\n/**\n * Is the given address the primary\n * @method\n * @param {string} address Server address\n * @return {boolean}\n */\n\n\nState.prototype.isPrimary = function (address) {\n  if (this.primary == null) return false;\n  return this.primary && this.primary.equals(address);\n};\n/**\n * Is the given address a secondary\n * @method\n * @param {string} address Server address\n * @return {boolean}\n */\n\n\nState.prototype.isSecondary = function (address) {\n  // Check if the server is a secondary at the moment\n  for (var i = 0; i < this.secondaries.length; i++) {\n    if (this.secondaries[i].equals(address)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Is the given address a secondary\n * @method\n * @param {string} address Server address\n * @return {boolean}\n */\n\n\nState.prototype.isPassive = function (address) {\n  // Check if the server is a secondary at the moment\n  for (var i = 0; i < this.passives.length; i++) {\n    if (this.passives[i].equals(address)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nState.prototype.clearConnectingServers = function () {\n  for (var name in this.connectingServers) {\n    if (typeof this.connectingServers[name].destroy == 'function') {\n      this.connectingServers[name].destroy();\n    }\n  }\n\n  this.connectingServers = {};\n};\n\nState.prototype.removeConnectingServer = function (address) {\n  if (this.connectingServers[address]) {\n    if (this.connectingServers[address].destroy) {\n      this.connectingServers[address].destroy();\n    }\n  }\n\n  delete this.connectingServers[address];\n};\n\nState.prototype.addConnectingServer = function (host, object) {\n  this.connectingServers[host] = object;\n};\n\nState.prototype.isConnectingServer = function (host) {\n  return this.connectingServers[host] != null;\n};\n\nState.prototype.connectingServersCount = function () {\n  return Object.keys(this.connectingServers).length;\n};\n/**\n * Does the replicaset contain this server\n * @method\n * @param {string} address Server address\n * @return {boolean}\n */\n\n\nState.prototype.contains = function (address) {\n  if (this.primary && this.primary.equals(address)) return true;\n\n  for (var i = 0; i < this.secondaries.length; i++) {\n    if (this.secondaries[i].equals(address)) return true;\n  }\n\n  for (var i = 0; i < this.arbiters.length; i++) {\n    if (this.arbiters[i].equals(address)) return true;\n  }\n\n  for (var i = 0; i < this.passives.length; i++) {\n    if (this.passives[i].equals(address)) return true;\n  }\n\n  return false;\n};\n/**\n * Return all the valid and non passive secondaries\n * @method\n * @return {Array[Server]}\n */\n\n\nState.prototype.getSecondaries = function () {\n  // Filter out any non connected servers\n  this.secondaries = this.secondaries.filter(function (server) {\n    return server.isConnected();\n  }); // Filter out any hidden secondaries\n\n  return this.secondaries.filter(function (server) {\n    return server.lastIsMaster().hidden ? false : true;\n  });\n};\n/**\n * Clean out all dead connections\n * @method\n */\n\n\nState.prototype.clean = function () {\n  var self = this;\n  var disconnectedServers = [];\n\n  if (this.primary != null && !this.primary.isConnected()) {\n    disconnectedServers.push(this.primary);\n    this.primary = null;\n  } // Filter out disconnected servers\n\n\n  this.secondaries = this.secondaries.filter(function (s) {\n    if (!s.isConnected()) disconnectedServers.push(s);\n    return s.isConnected();\n  }); // Filter out disconnected servers\n\n  this.arbiters = this.arbiters.filter(function (s) {\n    if (!s.isConnected()) disconnectedServers.push(s);\n    return s.isConnected();\n  }); // Filter out disconnected servers\n\n  this.passives = this.passives.filter(function (s) {\n    if (!s.isConnected()) disconnectedServers.push(s);\n    return s.isConnected();\n  });\n  return disconnectedServers;\n};\n/**\n * Unref state\n * @method\n */\n\n\nState.prototype.unref = function () {\n  if (this.primary) this.primary.unref();\n  this.secondaries.forEach(function (s) {\n    s.unref();\n  });\n  this.arbiters.forEach(function (s) {\n    s.unref();\n  });\n}; // Remove listeners\n\n\nvar events = ['timeout', 'error', 'close', 'joined', 'left', 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHearbeatFailed', 'serverClosed'];\n\nvar removeEvents = function (s) {\n  events.forEach(function (e) {\n    s.removeAllListeners(e);\n  });\n};\n/**\n * Destroy state\n * @method\n */\n\n\nState.prototype.destroy = function () {\n  this.state = DESTROYED;\n\n  if (this.primary) {\n    this.primary.destroy();\n    removeEvents(this.primary);\n  }\n\n  this.secondaries.forEach(function (s) {\n    s.destroy();\n    removeEvents(s);\n  });\n  this.arbiters.forEach(function (s) {\n    s.destroy();\n    removeEvents(s);\n  });\n};\n/**\n * Remove server from state\n * @method\n * @param {Server} Server to remove\n * @return {string} Returns type of server removed (primary|secondary)\n */\n\n\nState.prototype.remove = function (server) {\n  if (this.primary && this.primary.equals(server)) {\n    this.primary = null;\n  }\n\n  var length = this.arbiters.length; // Filter out the server from the arbiters\n\n  this.arbiters = this.arbiters.filter(function (s) {\n    return !s.equals(server);\n  });\n  if (this.arbiters.length < length) return 'arbiter';\n  var length = this.passives.length; // Filter out the server from the passives\n\n  this.passives = this.passives.filter(function (s) {\n    return !s.equals(server);\n  }); // We have removed a passive\n\n  if (this.passives.length < length) {\n    // Ensure we removed it from the list of secondaries as well if it exists\n    this.secondaries = this.secondaries.filter(function (s) {\n      return !s.equals(server);\n    });\n  } // Filter out the server from the secondaries\n\n\n  this.secondaries = this.secondaries.filter(function (s) {\n    return !s.equals(server);\n  }); // Get the isMaster\n\n  var isMaster = server.lastIsMaster(); // Return primary if the server was primary\n\n  if (isMaster.ismaster && isMaster.hosts) return 'primary';\n  if (isMaster.ismaster) return 'secondary';\n  if (isMaster.secondary) return 'secondary';\n  if (isMaster.passive) return 'passive';\n  return 'arbiter';\n};\n/**\n * Get the server by name\n * @method\n * @param {string} address Server address\n * @return {Server}\n */\n\n\nState.prototype.get = function (server) {\n  var found = false; // All servers to search\n\n  var servers = this.primary ? [this.primary] : [];\n  servers = servers.concat(this.secondaries); // Locate the server\n\n  for (var i = 0; i < servers.length; i++) {\n    if (servers[i].equals(server)) {\n      return servers[i];\n    }\n  }\n};\n/**\n * Get all the servers in the set\n * @method\n * @param {boolean} [options.includeArbiters] Include Arbiters in returned server list\n * @return {array}\n */\n\n\nState.prototype.getAll = function (options) {\n  options = options || {};\n  var servers = [];\n  if (this.primary) servers.push(this.primary);\n  servers = servers.concat(this.secondaries); // Include the arbiters\n\n  if (options.includeArbiters) {\n    servers = servers.concat(this.arbiters);\n  }\n\n  return servers;\n};\n/**\n * All raw connections\n * @method\n * @param {boolean} [options.includeArbiters] Include Arbiters in returned server list\n * @return {array}\n */\n\n\nState.prototype.getAllConnections = function (options) {\n  options = options || {};\n  var connections = [];\n  if (this.primary) connections = connections.concat(this.primary.connections());\n  this.secondaries.forEach(function (s) {\n    connections = connections.concat(s.connections());\n  }); // Include the arbiters\n\n  if (options.includeArbiters) {\n    this.arbiters.forEach(function (s) {\n      connections = connections.concat(s.connections());\n    });\n  }\n\n  return connections;\n};\n/**\n * Return JSON object\n * @method\n * @return {object}\n */\n\n\nState.prototype.toJSON = function () {\n  return {\n    primary: this.primary ? this.primary.lastIsMaster().me : null,\n    secondaries: this.secondaries.map(function (s) {\n      return s.lastIsMaster().me;\n    })\n  };\n};\n/**\n * Returns the last known ismaster document for this server\n * @method\n * @return {object}\n */\n\n\nState.prototype.lastIsMaster = function () {\n  if (this.primary) return this.primary.lastIsMaster();\n  if (this.secondaries.length > 0) return this.secondaries[0].lastIsMaster();\n  return {};\n};\n/**\n * Promote server to primary\n * @method\n * @param {Server} server Server we wish to promote\n */\n\n\nState.prototype.promotePrimary = function (server) {\n  var currentServer = this.get(server); // Server does not exist in the state, add it as new primary\n\n  if (currentServer == null) {\n    this.primary = server;\n    return;\n  } // We found a server, make it primary and remove it from the secondaries\n  // Remove the server first\n\n\n  this.remove(currentServer); // Set as primary\n\n  this.primary = currentServer;\n};\n\nvar add = function (self, list, server) {\n  // Check if the server is contained in the list\n  for (var i = 0; i < list.length; i++) {\n    if (list[i].equals(server)) return false;\n  } // Add serer to list\n\n\n  list.push(server); // Return true\n\n  return true;\n};\n/**\n * Add server to list of secondaries\n * @method\n * @param {Server} server Server we wish to add\n */\n\n\nState.prototype.addSecondary = function (server) {\n  return add(this, this.secondaries, server);\n};\n/**\n * Add server to list of arbiters\n * @method\n * @param {Server} server Server we wish to add\n */\n\n\nState.prototype.addArbiter = function (server) {\n  return add(this, this.arbiters, server);\n};\n/**\n * Add server to list of passives\n * @method\n * @param {Server} server Server we wish to add\n */\n\n\nState.prototype.addPassive = function (server) {\n  return add(this, this.passives, server);\n};\n\nvar compareObjectIds = function (id1, id2) {\n  var a = new Buffer(id1.toHexString(), 'hex');\n  var b = new Buffer(id2.toHexString(), 'hex');\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (typeof Buffer.compare === 'function') {\n    return Buffer.compare(a, b);\n  }\n\n  var x = a.length;\n  var y = b.length;\n  var len = Math.min(x, y);\n\n  for (var i = 0; i < len; i++) {\n    if (a[i] !== b[i]) {\n      break;\n    }\n  }\n\n  if (i !== len) {\n    x = a[i];\n    y = b[i];\n  }\n\n  return x < y ? -1 : y < x ? 1 : 0;\n};\n/**\n * Update the state given a specific ismaster result\n * @method\n * @param {object} ismaster IsMaster result\n * @param {Server} server IsMaster Server source\n */\n\n\nState.prototype.update = function (ismaster, server) {\n  var self = this; // Perform a cleanup before performing the update\n\n  this.clean(); // Not in a known connection valid state\n\n  if (!ismaster.ismaster && !ismaster.secondary && !ismaster.arbiterOnly || !Array.isArray(ismaster.hosts)) {\n    // Remove the state\n    var result = self.remove(server);\n\n    if (self.state == CONNECTED) {\n      if (self.logger.isInfo()) self.logger.info(f('[%s] removing %s from set', self.id, ismaster.me));\n      self.replSet.emit('left', result, server);\n    }\n\n    emitTopologyDescriptionChanged(this);\n    return false;\n  } // Set the setName if it's not set from the first server\n\n\n  if (self.setName == null && ismaster.setName) {\n    if (self.logger.isInfo()) self.logger.info(f('[%s] setting setName to %s', self.id, ismaster.setName));\n    self.setName = ismaster.setName;\n  } // Check if the replicaset name matches the provided one\n\n\n  if (ismaster.setName && self.setName != ismaster.setName) {\n    if (self.logger.isError()) self.logger.error(f('[%s] server in replset %s is not part of the specified setName %s', self.id, ismaster.setName, self.setName));\n    self.remove(server);\n    self.replSet.emit('error', new MongoError(\"provided setName for Replicaset Connection does not match setName found in server seedlist\"));\n    emitTopologyDescriptionChanged(this);\n    return false;\n  } // Log information\n\n\n  if (self.logger.isInfo()) self.logger.info(f('[%s] updating replicaset state %s', self.id, JSON.stringify(this))); // It's a master set it\n\n  if (ismaster.ismaster && self.setName == ismaster.setName && !self.isPrimary(ismaster.me)) {\n    // Check if the electionId is not null\n    if (ismaster.electionId instanceof ObjectId && self.electionId instanceof ObjectId) {\n      if (compareObjectIds(self.electionId, ismaster.electionId) == -1) {\n        self.electionId = ismaster.electionId;\n      } else if (compareObjectIds(self.electionId, ismaster.electionId) == 0) {\n        self.electionId = ismaster.electionId;\n      } else {\n        return false;\n      }\n    } // Initial electionId\n\n\n    if (ismaster.electionId instanceof ObjectId && self.electionId == null) {\n      self.electionId = ismaster.electionId;\n    } // Promote to primary\n\n\n    self.promotePrimary(server); // Log change of primary\n\n    if (self.logger.isInfo()) self.logger.info(f('[%s] promoting %s to primary', self.id, ismaster.me)); // Emit primary\n\n    self.replSet.emit('joined', 'primary', this.primary); // Emit the description change\n\n    emitTopologyDescriptionChanged(this); // We are connected\n\n    if (self.state == CONNECTING) {\n      self.state = CONNECTED;\n      self.replSet.emit('connect', self.replSet);\n    } else {\n      self.state = CONNECTED;\n      self.replSet.emit('reconnect', server);\n    }\n  } else if (!ismaster.ismaster && self.setName == ismaster.setName && ismaster.arbiterOnly) {\n    if (self.addArbiter(server)) {\n      if (self.logger.isInfo()) self.logger.info(f('[%s] promoting %s to arbiter', self.id, ismaster.me));\n      self.replSet.emit('joined', 'arbiter', server);\n      emitTopologyDescriptionChanged(this);\n      return true;\n    }\n\n    ;\n    return false;\n  } else if (!ismaster.ismaster && self.setName == ismaster.setName && ismaster.secondary && ismaster.passive) {\n    if (self.addPassive(server) && self.addSecondary(server)) {\n      if (self.logger.isInfo()) self.logger.info(f('[%s] promoting %s to passive', self.id, ismaster.me));\n      self.replSet.emit('joined', 'passive', server); // If we have secondaryOnlyConnectionAllowed and just a passive it's\n      // still a valid connection\n\n      if (self.secondaryOnlyConnectionAllowed && self.state == CONNECTING) {\n        self.state = CONNECTED;\n        self.replSet.emit('connect', self.replSet);\n      }\n\n      emitTopologyDescriptionChanged(this);\n      return true;\n    }\n\n    ;\n    return false;\n  } else if (!ismaster.ismaster && self.setName == ismaster.setName && ismaster.secondary) {\n    if (self.addSecondary(server)) {\n      if (self.logger.isInfo()) self.logger.info(f('[%s] promoting %s to secondary', self.id, ismaster.me));\n      self.replSet.emit('joined', 'secondary', server); // Is this the primary right now\n\n      if (self.primary && self.primary.name == server.name) {\n        self.primary = null;\n      }\n\n      if (self.secondaryOnlyConnectionAllowed && self.state == CONNECTING) {\n        self.state = CONNECTED;\n        self.replSet.emit('connect', self.replSet);\n      }\n\n      emitTopologyDescriptionChanged(this);\n      return true;\n    }\n\n    ;\n    return false;\n  } // Return update applied\n\n\n  return true;\n};\n\nmodule.exports = State;","map":null,"metadata":{},"sourceType":"script"}