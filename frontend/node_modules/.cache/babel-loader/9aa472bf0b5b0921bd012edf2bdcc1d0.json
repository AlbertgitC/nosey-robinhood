{"ast":null,"code":"\"use strict\";\n\nvar inherits = require('util').inherits,\n    f = require('util').format,\n    bindToCurrentDomain = require('../connection/utils').bindToCurrentDomain,\n    EventEmitter = require('events').EventEmitter,\n    Pool = require('../connection/pool'),\n    b = require('bson'),\n    crypto = require('crypto'),\n    Query = require('../connection/commands').Query,\n    MongoError = require('../error'),\n    ReadPreference = require('./read_preference'),\n    BasicCursor = require('../cursor'),\n    CommandResult = require('./command_result'),\n    getSingleProperty = require('../connection/utils').getSingleProperty,\n    getProperty = require('../connection/utils').getProperty,\n    debugOptions = require('../connection/utils').debugOptions,\n    BSON = require('bson').native().BSON,\n    PreTwoSixWireProtocolSupport = require('../wireprotocol/2_4_support'),\n    TwoSixWireProtocolSupport = require('../wireprotocol/2_6_support'),\n    ThreeTwoWireProtocolSupport = require('../wireprotocol/3_2_support'),\n    Session = require('./session'),\n    Logger = require('../connection/logger'),\n    MongoCR = require('../auth/mongocr'),\n    X509 = require('../auth/x509'),\n    Plain = require('../auth/plain'),\n    GSSAPI = require('../auth/gssapi'),\n    SSPI = require('../auth/sspi'),\n    ScramSHA1 = require('../auth/scram');\n/**\n * @fileOverview The **Server** class is a class that represents a single server topology and is\n * used to construct connections.\n *\n * @example\n * var Server = require('mongodb-core').Server\n *   , ReadPreference = require('mongodb-core').ReadPreference\n *   , assert = require('assert');\n *\n * var server = new Server({host: 'localhost', port: 27017});\n * // Wait for the connection event\n * server.on('connect', function(server) {\n *   server.destroy();\n * });\n *\n * // Start connecting\n * server.connect();\n */\n// All bson types\n\n\nvar bsonTypes = [b.Long, b.ObjectID, b.Binary, b.Code, b.DBRef, b.Symbol, b.Double, b.Timestamp, b.MaxKey, b.MinKey]; // BSON parser\n\nvar bsonInstance = null; // Server instance id\n\nvar serverId = 0; // Callbacks instance id\n\nvar callbackId = 0; // Single store for all callbacks\n\nvar Callbacks = function () {\n  // EventEmitter.call(this);\n  var self = this; // Callbacks\n\n  this.callbacks = {}; // Set the callbacks id\n\n  this.id = callbackId++; // Set the type to server\n\n  this.type = 'server';\n}; //\n// Clone the options\n\n\nvar cloneOptions = function (options) {\n  var opts = {};\n\n  for (var name in options) {\n    opts[name] = options[name];\n  }\n\n  return opts;\n}; //\n// Flush all callbacks\n\n\nCallbacks.prototype.flush = function (err) {\n  for (var id in this.callbacks) {\n    if (!isNaN(parseInt(id, 10))) {\n      var callback = this.callbacks[id];\n      delete this.callbacks[id];\n      callback(err, null);\n    }\n  }\n}; //\n// Flush all callbacks\n\n\nCallbacks.prototype.flushConnection = function (err, connection) {\n  for (var id in this.callbacks) {\n    if (!isNaN(parseInt(id, 10))) {\n      var callback = this.callbacks[id]; // Validate if the operation ran on the connection\n\n      if (callback.connection && callback.connection.id === connection.id) {\n        delete this.callbacks[id];\n        callback(err, null);\n      } else if (!callback.connection && callback.monitoring) {\n        delete this.callbacks[id];\n        callback(err, null);\n      }\n    }\n  }\n};\n\nCallbacks.prototype.callback = function (id) {\n  return this.callbacks[id];\n};\n\nCallbacks.prototype.emit = function (id, err, value) {\n  var callback = this.callbacks[id];\n  delete this.callbacks[id];\n  callback(err, value);\n};\n\nCallbacks.prototype.raw = function (id) {\n  if (this.callbacks[id] == null) return false;\n  return this.callbacks[id].raw == true ? true : false;\n};\n\nCallbacks.prototype.documentsReturnedIn = function (id) {\n  if (this.callbacks[id] == null) return false;\n  return typeof this.callbacks[id].documentsReturnedIn == 'string' ? this.callbacks[id].documentsReturnedIn : null;\n};\n\nCallbacks.prototype.unregister = function (id) {\n  delete this.callbacks[id];\n};\n\nCallbacks.prototype.register = function (id, callback) {\n  this.callbacks[id] = bindToCurrentDomain(callback);\n};\n\nvar DISCONNECTED = 'disconnected';\nvar CONNECTING = 'connecting';\nvar CONNECTED = 'connected';\nvar DESTROYED = 'destroyed'; // Supports server\n\nvar supportsServer = function (_s) {\n  return _s.ismaster && typeof _s.ismaster.minWireVersion == 'number';\n}; //\n// createWireProtocolHandler\n\n\nvar createWireProtocolHandler = function (result) {\n  // 3.2 wire protocol handler\n  if (result && result.maxWireVersion >= 4) {\n    return new ThreeTwoWireProtocolSupport(new TwoSixWireProtocolSupport());\n  } // 2.6 wire protocol handler\n\n\n  if (result && result.maxWireVersion >= 2) {\n    return new TwoSixWireProtocolSupport();\n  } // 2.4 or earlier wire protocol handler\n\n\n  return new PreTwoSixWireProtocolSupport();\n};\n\nvar errorHandler = function (self, state) {\n  return function (err, connection) {\n    if (state.state == DISCONNECTED || state.state == DESTROYED) return; // Flush the connection operations\n\n    if (self.s.callbacks) {\n      self.s.callbacks.flushConnection(new MongoError(f(\"server %s received an error %s\", self.name, JSON.stringify(err))), connection);\n    } // Emit error event\n\n\n    if (state.emitError && self.listeners('error').length > 0) {\n      self.emit('error', err, self);\n    } // No more connections left, emit a close\n\n\n    if (state.pool.getAll().length == 0) {\n      // Set disconnected state\n      state.state = DISCONNECTED; // Notify any strategies for read Preferences about closure\n\n      if (state.readPreferenceStrategies != null) notifyStrategies(self, self.s, 'error', [self]);\n      if (state.logger.isInfo()) state.logger.info(f('server %s errored out with %s', self.name, JSON.stringify(err))); // Flush out all the callbacks\n\n      if (state.callbacks) {\n        state.callbacks.flushConnection(new MongoError(f(\"server %s received an error %s\", self.name, JSON.stringify(err))), connection);\n      } // Emit error event\n\n\n      if (state.emitError && self.listeners('error').length > 0) self.emit('error', err, self); // If we specified the driver to reconnect perform it\n\n      if (state.reconnect) return setTimeout(function () {\n        reconnectServer(self, state);\n      }, state.reconnectInterval); // No reconnect destroy instance\n\n      self.destroy();\n    }\n  };\n}; //\n// reconnect error handler\n\n\nvar reconnectErrorHandler = function (self, state) {\n  return function (err, connection) {\n    if (state.state == DESTROYED) return; // Flush the connection operations\n\n    if (self.s.callbacks) {\n      self.s.callbacks.flushConnection(new MongoError(f(\"server %s received an error %s\", self.name, JSON.stringify(err))), connection);\n    } // Emit error event\n\n\n    if (state.emitError && self.listeners('error').length > 0) {\n      self.emit('error', err, self);\n    } // No reconnect enabled exit fast\n\n\n    if (!state.reconnect) {\n      // Set state to destroyed\n      state.state = DESTROYED; // Emit error event\n\n      if (self.listeners('error').length > 0) {\n        self.emit('error', err, self);\n      } // Destroy pool\n\n\n      return self.destroy();\n    } // No more connections left, emit a close\n\n\n    if (state.pool.getAll().length == 0) {\n      // No more retries\n      if (state.currentReconnectRetry == 0) {\n        // Set state to destroyed\n        state.state = DESTROYED; // Destroy pool\n\n        self.destroy();\n\n        if (state.emitError && self.listeners('error').length > 0) {\n          self.emit('error', new MongoError(f('failed to connect to %s:%s after %s retries', state.options.host, state.options.port, state.reconnectTries)), self);\n        }\n      } else {\n        // Do we have an error listener emit the error\n        if (state.emitError && self.listeners('error').length > 0) {\n          self.emit('error', new MongoError(f('failed to connect to %s:%s, %s connection attempts left ', state.options.host, state.options.port, state.currentReconnectRetry)), self);\n        } // Retry connection\n\n\n        setTimeout(function () {\n          reconnectServer(self, state);\n        }, state.reconnectInterval);\n      }\n    }\n  };\n}; //\n// Reconnect server\n\n\nvar reconnectServer = function (self, state) {\n  if (state.state == DESTROYED) return; // Flush out any left over callbacks\n\n  if (self && state && state.callbacks) {\n    state.callbacks.flush(new MongoError(f(\"server %s received a broken socket pipe error\", self.name)));\n  } // If the current reconnect retries is 0 stop attempting to reconnect\n\n\n  if (state.currentReconnectRetry == 0) {\n    return self.destroy(true, true);\n  } // Adjust the number of retries\n\n\n  state.currentReconnectRetry = state.currentReconnectRetry - 1; // Set status to connecting\n\n  state.state = CONNECTING; // If we have a pool destroy it\n\n  if (state.pool) state.pool.destroy(); // Create a new Pool\n\n  state.pool = new Pool(state.options); //\n  // Attempt to connect\n\n  state.pool.once('connect', function () {\n    // Reset retries\n    state.currentReconnectRetry = state.reconnectTries; // Remove any non used handlers\n\n    var events = ['error', 'close', 'timeout', 'parseError', 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHearbeatFailed', 'serverClosed'];\n    events.forEach(function (e) {\n      state.pool.removeAllListeners(e);\n    }); // Set connected state\n\n    state.state = CONNECTED; // Add proper handlers\n\n    state.pool.once('error', self.s.inTopology ? errorHandler(self, state) : reconnectErrorHandler(self, state));\n    state.pool.on('close', closeHandler(self, state));\n    state.pool.on('timeout', timeoutHandler(self, state));\n    state.pool.on('parseError', fatalErrorHandler(self, state)); // We need to ensure we have re-authenticated\n\n    var keys = Object.keys(state.authProviders);\n    if (keys.length == 0) return self.emit('reconnect', self); // Get all connections\n\n    var connections = state.pool.getAll(); // Authenticate with retries\n\n    var authenticate = function (retries, interval, provider, connections, self, state, callback) {\n      retries = retries - 1;\n      if (retries == 0) return callback(new Error('failed to authenticate')); // Attemp to reauthenticate\n\n      provider.reauthenticate(self, connections, function (err, r) {\n        if (!err) return callback(null, null);\n\n        if (err) {\n          if (state.logger.isError()) {\n            state.logger.error(f('[%s] failed to authenticate against server %s', state.id, self.name));\n          } // End of retries but still receiving errors\n\n\n          if (retries == 0) return callback(err);\n        }\n\n        setTimeout(function () {\n          authenticate(retries, interval, provider, connections, self, state, callback);\n        }, interval);\n      });\n    }; // Execute all providers\n\n\n    var count = keys.length; // Iterate over keys\n\n    for (var i = 0; i < keys.length; i++) {\n      authenticate(state.authenticationRetries, state.authenticationRetryIntervalMS, state.authProviders[keys[i]], connections, self, state, function (err, i) {\n        count = count - 1;\n\n        if (count == 0) {\n          if (!state.ismaster) {\n            return connectHandler(self, state)();\n          }\n\n          return self.emit('reconnect', self);\n        }\n      });\n    }\n  }); //\n  // Handle connection failure\n\n  state.pool.once('error', self.s.inTopology ? errorHandler(self, state) : reconnectErrorHandler(self, state));\n  state.pool.once('close', errorHandler(self, state));\n  state.pool.once('timeout', errorHandler(self, state));\n  state.pool.once('parseError', errorHandler(self, state)); // Connect pool\n\n  state.pool.connect();\n}; //\n// Handlers\n\n\nvar messageHandler = function (self, state) {\n  return function (response, connection) {\n    // Attempt to parse the message\n    try {\n      // Get the callback\n      var cb = state.callbacks.callback(response.responseTo); // Parse options\n\n      var parseOptions = {\n        raw: state.callbacks.raw(response.responseTo),\n        promoteLongs: cb && typeof cb.promoteLongs == 'boolean' ? cb.promoteLongs : true,\n        documentsReturnedIn: state.callbacks.documentsReturnedIn(response.responseTo)\n      }; // Parse the message\n\n      response.parse(parseOptions); // If no\n\n      if (cb && !cb.noRelease || !cb) {\n        self.s.pool.connectionAvailable(connection);\n      } // Log if debug enabled\n\n\n      if (state.logger.isDebug()) state.logger.debug(f('message [%s] received from %s', response.raw.toString('hex'), self.name)); // Execute the registered callback\n\n      state.callbacks.emit(response.responseTo, null, response);\n    } catch (err) {\n      state.callbacks.flushConnection(new MongoError(err), connection);\n      self.destroy();\n    }\n  };\n};\n\nvar fatalErrorHandler = function (self, state) {\n  return function (err, connection) {\n    if (state.state == DISCONNECTED || state.state == DESTROYED) return; // Flush the connection operations\n\n    if (self.s.callbacks) {\n      self.s.callbacks.flushConnection(new MongoError(f(\"server %s received an error %s\", self.name, JSON.stringify(err))), connection);\n    } // No more connections left, emit a close\n\n\n    if (state.pool.getAll().length == 0) {\n      // Set disconnected state\n      state.state = DISCONNECTED; // Notify any strategies for read Preferences about closure\n\n      if (state.readPreferenceStrategies != null) notifyStrategies(self, self.s, 'error', [self]);\n      if (state.logger.isInfo()) state.logger.info(f('server %s errored out with %s', self.name, JSON.stringify(err))); // Flush out all the callbacks\n\n      if (state.callbacks) {\n        state.callbacks.flushConnection(new MongoError(f(\"server %s received an error %s\", self.name, JSON.stringify(err))), connection);\n      } // Emit error event\n\n\n      if (self.listeners('error').length > 0) self.emit('error', err, self); // If we specified the driver to reconnect perform it\n\n      if (state.reconnect) return setTimeout(function () {\n        reconnectServer(self, state);\n      }, state.reconnectInterval); // No reconnect destroy instance\n\n      self.destroy();\n    }\n  };\n};\n\nvar timeoutHandler = function (self, state) {\n  return function (err, connection) {\n    if (state.state == DISCONNECTED || state.state == DESTROYED) return; // Flush the connection operations\n\n    if (self.s.callbacks) {\n      self.s.callbacks.flushConnection(new MongoError(f(\"server %s timed out\", self.name)), connection);\n    } // No more connections left, emit a close\n\n\n    if (state.pool.getAll().length == 0) {\n      // Set disconnected state\n      state.state = DISCONNECTED; // Notify any strategies for read Preferences about closure\n\n      if (state.readPreferenceStrategies != null) notifyStrategies(self, self.s, 'timeout', [self]);\n      if (state.logger.isInfo()) state.logger.info(f('server %s timed out', self.name)); // Flush out all the callbacks\n\n      if (state.callbacks) {\n        state.callbacks.flushConnection(new MongoError(f(\"server %s timed out\", self.name)), connection);\n      } // Emit error event\n\n\n      self.emit('timeout', err, self); // If we specified the driver to reconnect perform it\n\n      if (state.reconnect) return setTimeout(function () {\n        reconnectServer(self, state);\n      }, state.reconnectInterval); // No reconnect destroy instance\n\n      self.destroy();\n    }\n  };\n};\n\nvar closeHandler = function (self, state) {\n  return function (err, connection) {\n    if (state.state == DISCONNECTED || state.state == DESTROYED) return; // Flush the connection operations\n\n    if (self.s.callbacks) {\n      self.s.callbacks.flushConnection(new MongoError(f(\"server %s timed out\", self.name)), connection);\n    } // No more connections left, emit a close\n\n\n    if (state.pool.getAll().length == 0) {\n      // Set state to disconnected\n      state.state = DISCONNECTED; // Notify any strategies for read Preferences about closure\n\n      if (state.readPreferenceStrategies != null) notifyStrategies(self, self.s, 'close', [self]);\n      if (state.logger.isInfo()) state.logger.info(f('server %s closed', self.name)); // Flush out all the callbacks\n\n      if (state.callbacks) {\n        state.callbacks.flushConnection(new MongoError(f(\"server %s sockets closed\", self.name)), connection);\n      } // Emit opening server event\n\n\n      if (self.listeners('serverClosed').length > 0) self.emit('serverClosed', {\n        topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.s.id,\n        address: self.name\n      }); // Emit toplogy opening event if not in topology\n\n      if (self.listeners('topologyClosed').length > 0 && !self.s.inTopology) {\n        self.emit('topologyClosed', {\n          topologyId: self.s.id\n        });\n      } // Emit close event\n\n\n      self.emit('close', err, self); // If we specified the driver to reconnect perform it\n\n      if (state.reconnect) return setTimeout(function () {\n        reconnectServer(self, state);\n      }, state.reconnectInterval); // No reconnect destroy instance\n\n      self.destroy();\n    }\n  };\n};\n\nvar connectHandler = function (self, state) {\n  // Apply all stored authentications\n  var applyAuthentications = function (ismaster, callback) {\n    // Do not authenticate if we have an arbiter\n    if (ismaster && ismaster.arbiterOnly) return callback(null, null); // We need to ensure we have re-authenticated\n\n    var keys = Object.keys(state.authProviders);\n    if (keys.length == 0) return callback(null, null); // Get all connections\n\n    var connections = state.pool.getAll(); // Execute all providers\n\n    var count = keys.length;\n    var error = null; // Iterate over keys\n\n    for (var i = 0; i < keys.length; i++) {\n      state.authProviders[keys[i]].reauthenticate(self, connections, function (err, r) {\n        count = count - 1;\n        if (err) error = err; // We are done\n\n        if (count == 0) {\n          return callback(error, null);\n        }\n      });\n    }\n  };\n\n  return function () {\n    // Get the actual latency of the ismaster\n    var start = new Date().getTime(); // Execute an ismaster\n\n    self.command('admin.$cmd', {\n      ismaster: true\n    }, function (err, r) {\n      if (err) {\n        state.state = DISCONNECTED; // Emit opening closed event\n\n        if (self.listeners('serverClosed').length > 0) self.emit('serverClosed', {\n          topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.s.id,\n          address: self.name\n        }); // Emit toplogy opening event if not in topology\n\n        if (!self.s.inTopology) {\n          self.emit('topologyOpening', {\n            topologyId: self.s.id\n          });\n        }\n\n        return self.emit('close', err, self);\n      } // Apply authentication\n\n\n      applyAuthentications(r.result, function (err) {\n        // Initiate monitoring\n        if (state.monitoring) {\n          self.s.inquireServerStateTimeout = setTimeout(inquireServerState(self), state.haInterval);\n        } // Emit server description changed if something listening\n\n\n        emitServerDescriptionChanged(self, {\n          address: self.name,\n          arbiters: [],\n          hosts: [],\n          passives: [],\n          type: !self.s.inTopology ? 'Standalone' : getTopologyType(self)\n        }); // Emit topology description changed if something listening\n\n        emitTopologyDescriptionChanged(self, {\n          topologyType: 'Single',\n          servers: [{\n            address: self.name,\n            arbiters: [],\n            hosts: [],\n            passives: [],\n            type: 'Standalone'\n          }]\n        }); // Set the latency for this instance\n\n        state.isMasterLatencyMS = new Date().getTime() - start; // Set the current ismaster\n\n        if (!err) {\n          state.ismaster = r.result;\n        } // Emit the ismaster\n\n\n        self.emit('ismaster', r.result, self); // Determine the wire protocol handler\n\n        state.wireProtocolHandler = createWireProtocolHandler(state.ismaster); // Set the wireProtocolHandler\n\n        state.options.wireProtocolHandler = state.wireProtocolHandler; // Log the ismaster if available\n\n        if (state.logger.isInfo()) state.logger.info(f('server %s connected with ismaster [%s]', self.name, JSON.stringify(r.result))); // Validate if we it's a server we can connect to\n\n        if (!supportsServer(state) && state.wireProtocolHandler == null) {\n          state.state = DISCONNECTED;\n          return self.emit('error', new MongoError(\"non supported server version\"), self);\n        } // Set the details\n\n\n        if (state.ismaster && state.ismaster.me) {\n          state.serverDetails.name = state.ismaster.me;\n        } // No read preference strategies just emit connect\n\n\n        if (state.readPreferenceStrategies == null) {\n          state.state = CONNECTED;\n          return self.emit('connect', self);\n        } // Signal connect to all readPreferences\n\n\n        notifyStrategies(self, self.s, 'connect', [self], function (err, result) {\n          state.state = CONNECTED;\n          return self.emit('connect', self);\n        });\n      });\n    });\n  };\n};\n\nvar slaveOk = function (r) {\n  if (r) return r.slaveOk();\n  return false;\n}; //\n// Execute readPreference Strategies\n\n\nvar notifyStrategies = function (self, state, op, params, callback) {\n  if (typeof callback != 'function') {\n    // Notify query start to any read Preference strategies\n    for (var name in state.readPreferenceStrategies) {\n      if (state.readPreferenceStrategies[name][op]) {\n        var strat = state.readPreferenceStrategies[name];\n        strat[op].apply(strat, params);\n      }\n    } // Finish up\n\n\n    return;\n  } // Execute the async callbacks\n\n\n  var nPreferences = Object.keys(state.readPreferenceStrategies).length;\n  if (nPreferences == 0) return callback(null, null);\n\n  for (var name in state.readPreferenceStrategies) {\n    if (state.readPreferenceStrategies[name][op]) {\n      var strat = state.readPreferenceStrategies[name]; // Add a callback to params\n\n      var cParams = params.slice(0);\n      cParams.push(function (err, r) {\n        nPreferences = nPreferences - 1;\n\n        if (nPreferences == 0) {\n          callback(null, null);\n        }\n      }); // Execute the readPreference\n\n      strat[op].apply(strat, cParams);\n    }\n  }\n};\n\nvar debugFields = ['reconnect', 'reconnectTries', 'reconnectInterval', 'emitError', 'cursorFactory', 'host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'checkServerIdentity', 'socketTimeout', 'singleBufferSerializtion', 'ssl', 'ca', 'cert', 'key', 'rejectUnauthorized', 'promoteLongs'];\n/**\n * Creates a new Server instance\n * @class\n * @param {boolean} [options.reconnect=true] Server will attempt to reconnect on loss of connection\n * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\n * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\n * @param {boolean} [options.emitError=false] Server will emit errors events\n * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors\n * @param {string} options.host The server host\n * @param {number} options.port The server port\n * @param {number} [options.size=5] Server connection pool size\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=0] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n * @param {number} [options.monitoring=true] Enable the server state monitoring (calling ismaster at haInterval)\n * @param {number} [options.haInterval=10000] The interval of calling ismaster when monitoring is enabled.\n * @param {number} [options.monitoringSocketTimeout=30000] TCP Socket timeout setting for replicaset monitoring socket\n * @param {number} [options.authenticationRetries=10] The number of times to retry the authentication and re-authentication before giving up.\n * @param {number} [options.authenticationRetryIntervalMS=500] The interval in MS between each authentication retry.\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passphrase] SSL Certificate pass phrase\n * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @return {Server} A cursor instance\n * @fires Server#connect\n * @fires Server#close\n * @fires Server#error\n * @fires Server#timeout\n * @fires Server#parseError\n * @fires Server#reconnect\n */\n\nvar Server = function (options) {\n  var self = this; // Add event listener\n\n  EventEmitter.call(this); // BSON Parser, ensure we have a single instance\n\n  if (bsonInstance == null) {\n    bsonInstance = new BSON(bsonTypes);\n  } // Reconnect retries\n\n\n  var reconnectTries = options.reconnectTries || 30; // Keeps all the internal state of the server\n\n  this.s = {\n    // Options\n    options: options // Contains all the callbacks\n    ,\n    callbacks: new Callbacks() // Logger\n    ,\n    logger: Logger('Server', options) // Server state\n    ,\n    state: DISCONNECTED // Reconnect option\n    ,\n    reconnect: typeof options.reconnect == 'boolean' ? options.reconnect : true,\n    reconnectTries: reconnectTries,\n    reconnectInterval: options.reconnectInterval || 1000 // Authentication retries\n    ,\n    authenticationRetries: 10,\n    authenticationRetryIntervalMS: 500 // Swallow or emit errors\n    ,\n    emitError: typeof options.emitError == 'boolean' ? options.emitError : false // Current state\n    ,\n    currentReconnectRetry: reconnectTries // Contains the ismaster\n    ,\n    ismaster: null // Contains any alternate strategies for picking\n    ,\n    readPreferenceStrategies: options.readPreferenceStrategies // Auth providers\n    ,\n    authProviders: options.authProviders || {} // Server instance id\n    ,\n    id: serverId++ // Shared topology id if part of another one\n    ,\n    topologyId: options.topologyId || -1 // Grouping tag used for debugging purposes\n    ,\n    tag: options.tag // Do we have a not connected handler\n    ,\n    disconnectHandler: options.disconnectHandler // If we are monitoring this server we will create an exclusive reserved socket for that\n    ,\n    monitoring: typeof options.monitoring == 'boolean' ? options.monitoring : true // High availability monitoring interval\n    ,\n    haInterval: options.haInterval || 10000 // wireProtocolHandler methods\n    ,\n    wireProtocolHandler: options.wireProtocolHandler || new PreTwoSixWireProtocolSupport() // Factory overrides\n    ,\n    Cursor: options.cursorFactory || BasicCursor // BSON Parser, ensure we have a single instance\n    ,\n    bsonInstance: bsonInstance // Contains the inquireServerState timeout reference\n    ,\n    inquireServerStateTimeout: null // Pick the right bson parser\n    ,\n    bson: options.bson ? options.bson : bsonInstance // Internal connection pool\n    ,\n    pool: null // Is master latency\n    ,\n    isMasterLatencyMS: 0 // Is the server in a topology\n    ,\n    inTopology: typeof options.inTopology == 'boolean' ? options.inTopology : false // Server details\n    ,\n    serverDetails: {\n      host: options.host,\n      port: options.port,\n      name: options.port ? f(\"%s:%s\", options.host, options.port) : options.host\n    } // Current server description\n    ,\n    serverDescription: null // Current topology description\n    ,\n    topologyDescription: null\n  }; // Create hash method\n\n  var hash = crypto.createHash('sha1');\n  hash.update(f('%s:%s', this.host, this.port)); // Create a hash name\n\n  this.hashedName = hash.digest('hex'); // Reference state\n\n  var s = this.s; // Add bson parser to options\n\n  options.bson = s.bson; // Set error properties\n\n  getProperty(this, 'name', 'name', s.serverDetails, {});\n  getProperty(this, 'bson', 'bson', s.options, {});\n  getProperty(this, 'wireProtocolHandler', 'wireProtocolHandler', s.options, {});\n  getSingleProperty(this, 'id', s.id); // If we do not have an inherited authorization mechanism\n\n  if (!options.authProviders) {\n    this.addAuthProvider('mongocr', new MongoCR());\n    this.addAuthProvider('x509', new X509());\n    this.addAuthProvider('plain', new Plain());\n    this.addAuthProvider('gssapi', new GSSAPI());\n    this.addAuthProvider('sspi', new SSPI());\n    this.addAuthProvider('scram-sha-1', new ScramSHA1());\n  }\n};\n\ninherits(Server, EventEmitter);\n\nvar getPreviousDescription = function (self) {\n  if (!self.s.serverDescription) {\n    self.s.serverDescription = {\n      address: self.name,\n      arbiters: [],\n      hosts: [],\n      passives: [],\n      type: 'Unknown'\n    };\n  }\n\n  return self.s.serverDescription;\n};\n\nvar emitServerDescriptionChanged = function (self, description) {\n  if (self.listeners('serverDescriptionChanged').length > 0) {\n    // Emit the server description changed events\n    self.emit('serverDescriptionChanged', {\n      topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.s.id,\n      address: self.name,\n      previousDescription: getPreviousDescription(self),\n      newDescription: description\n    });\n    self.s.serverDescription = description;\n  }\n};\n\nvar getPreviousTopologyDescription = function (self) {\n  if (!self.s.topologyDescription) {\n    self.s.topologyDescription = {\n      topologyType: 'Unknown',\n      servers: [{\n        address: self.name,\n        arbiters: [],\n        hosts: [],\n        passives: [],\n        type: 'Unknown'\n      }]\n    };\n  }\n\n  return self.s.topologyDescription;\n};\n\nvar emitTopologyDescriptionChanged = function (self, description) {\n  if (self.listeners('topologyDescriptionChanged').length > 0) {\n    // Emit the server description changed events\n    self.emit('topologyDescriptionChanged', {\n      topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.s.id,\n      address: self.name,\n      previousDescription: getPreviousTopologyDescription(self),\n      newDescription: description\n    });\n    self.s.serverDescription = description;\n  }\n};\n/**\n * Emit event if it exists\n * @method\n */\n\n\nfunction emitSDAMEvent(self, event, description) {\n  if (self.listeners(event).length > 0) {\n    self.emit(event, description);\n  }\n}\n/**\n * Get the server description\n * @method\n * @return {object}\n*/\n\n\nServer.prototype.getDescription = function () {\n  var ismaster = this.s.ismaster || {};\n  var description = {\n    type: getTopologyType(this),\n    address: this.name\n  }; // Add fields if available\n\n  if (ismaster.hosts) description.hosts = ismaster.hosts;\n  if (ismaster.arbiters) description.arbiters = ismaster.arbiters;\n  if (ismaster.passives) description.passives = ismaster.passives;\n  if (ismaster.setName) description.setName = ismaster.setName;\n  return description;\n};\n/**\n * Execute a command\n * @method\n * @param {string} type Type of BSON parser to use (c++ or js)\n */\n\n\nServer.prototype.setBSONParserType = function (type) {\n  var nBSON = null;\n\n  if (type == 'c++') {\n    nBSON = require('bson').native().BSON;\n  } else if (type == 'js') {\n    nBSON = require('bson').pure().BSON;\n  } else {\n    throw new MongoError(f(\"% parser not supported\", type));\n  }\n\n  this.s.options.bson = new nBSON(bsonTypes);\n};\n/**\n * Returns the last known ismaster document for this server\n * @method\n * @return {object}\n */\n\n\nServer.prototype.lastIsMaster = function () {\n  return this.s.ismaster;\n};\n/**\n * Returns the last known ismaster response latency\n * @method\n * @return {object}\n */\n\n\nServer.prototype.isMasterLatencyMS = function () {\n  return this.s.isMasterLatencyMS;\n};\n/**\n * Initiate server connect\n * @method\n */\n\n\nServer.prototype.connect = function (_options) {\n  var self = this; // Set server specific settings\n\n  _options = _options || {}; // Set the promotion\n\n  if (typeof _options.promoteLongs == 'boolean') {\n    self.s.options.promoteLongs = _options.promoteLongs;\n  } // Destroy existing pool connections if connection called\n  // Multiple times\n\n\n  if (self.s.pool) {\n    self.s.pool.destroy();\n  } // Set the state to connection\n\n\n  self.s.state = CONNECTING; // Create a new connection pool\n\n  self.s.options.messageHandler = messageHandler(self, self.s);\n  self.s.pool = new Pool(self.s.options); // Add all the event handlers\n\n  self.s.pool.on('timeout', timeoutHandler(self, self.s));\n  self.s.pool.on('close', closeHandler(self, self.s));\n  self.s.pool.once('error', self.s.inTopology ? errorHandler(self, self.s) : reconnectErrorHandler(self, self.s));\n  self.s.pool.once('connect', connectHandler(self, self.s));\n  self.s.pool.on('parseError', fatalErrorHandler(self, self.s)); // Emit toplogy opening event if not in topology\n\n  if (!self.s.inTopology) {\n    this.emit('topologyOpening', {\n      topologyId: this.s.id\n    });\n  } // Emit opening server event\n\n\n  self.emit('serverOpening', {\n    topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.s.id,\n    address: self.name\n  }); //\n  // Handle new connections\n\n  self.s.pool.on('connection', function (connection) {\n    // No auth handler used, return the connection\n    var keys = Object.keys(self.s.authProviders);\n\n    if (keys.length == 0) {\n      return self.s.pool.connectionAvailable(connection);\n    } // Get all connections\n\n\n    var connections = [connection]; // Execute all providers\n\n    var count = keys.length; // Iterate over all auth methods\n\n    for (var i = 0; i < keys.length; i++) {\n      // reauthenticate the connection\n      self.s.authProviders[keys[i]].reauthenticate(self, connections, function (err, r) {\n        count = count - 1; // We are done, Make the connection available\n\n        if (count == 0) {\n          return self.s.pool.connectionAvailable(connection);\n        }\n      });\n    }\n  }); // Connect the pool\n\n  self.s.pool.connect();\n};\n\nvar getTopologyType = function (self, ismaster) {\n  if (!ismaster) {\n    ismaster = self.s.ismaster;\n  }\n\n  if (!ismaster) return 'Unknown';\n  if (ismaster.ismaster && !ismaster.hosts) return 'Standalone';\n  if (ismaster.ismaster && ismaster.msg == 'isdbgrid') return 'Mongos';\n  if (ismaster.ismaster) return 'RSPrimary';\n  if (ismaster.secondary) return 'RSSecondary';\n  if (ismaster.arbiterOnly) return 'RSArbiter';\n  return 'Unknown';\n};\n\nvar changedIsMaster = function (self, currentIsmaster, ismaster) {\n  var currentType = getTopologyType(self, currentIsmaster);\n  var newType = getTopologyType(self, ismaster);\n  if (newType != currentType) return true;\n  return false;\n};\n\nvar inquireServerState = function (self) {\n  return function () {\n    if (self.s.state == DESTROYED) return; // Record response time\n\n    var start = new Date().getTime(); // emitSDAMEvent\n\n    emitSDAMEvent(self, 'serverHeartbeatStarted', {\n      connectionId: self.name\n    }); // Attempt to execute ismaster command\n\n    self.command('admin.$cmd', {\n      ismaster: true\n    }, {\n      monitoring: true\n    }, function (err, r) {\n      if (!err) {\n        // Legacy event sender\n        self.emit('ismaster', r, self); // Calculate latencyMS\n\n        var latencyMS = new Date().getTime() - start; // Server heart beat event\n\n        emitSDAMEvent(self, 'serverHeartbeatSucceeded', {\n          durationMS: latencyMS,\n          reply: r.result,\n          connectionId: self.name\n        }); // Did the server change\n\n        if (changedIsMaster(self, self.s.ismaster, r.result)) {\n          // Emit server description changed if something listening\n          emitServerDescriptionChanged(self, {\n            address: self.name,\n            arbiters: [],\n            hosts: [],\n            passives: [],\n            type: !self.s.inTopology ? 'Standalone' : getTopologyType(self)\n          });\n        } // Updat ismaster view\n\n\n        self.s.ismaster = r.result; // Set server response time\n\n        self.s.isMasterLatencyMS = latencyMS;\n      } else {\n        emitSDAMEvent(self, 'serverHearbeatFailed', {\n          durationMS: latencyMS,\n          failure: err,\n          connectionId: self.name\n        });\n      } // Perform another sweep\n\n\n      self.s.inquireServerStateTimeout = setTimeout(inquireServerState(self), self.s.haInterval);\n    });\n  };\n};\n/**\n * Unref all connections belong to this server\n * @method\n */\n\n\nServer.prototype.unref = function () {\n  this.s.pool.unref();\n};\n/**\n * Destroy the server connection\n * @method\n */\n\n\nServer.prototype.destroy = function (emitClose, emitDestroy) {\n  var self = this;\n  if (self.s.logger.isDebug()) self.s.logger.debug(f('destroy called on server %s', self.name)); // If we already destroyed ignore\n\n  if (self.s.state == DESTROYED) return; // Do we have a inquireServerState running\n\n  if (this.s.inquireServerStateTimeout) {\n    clearTimeout(this.s.inquireServerStateTimeout);\n  } // Emit close\n\n\n  if (emitClose && self.listeners('close').length > 0) {\n    self.emit('close', null, self);\n  } // Emit opening server event\n\n\n  if (self.listeners('serverClosed').length > 0) self.emit('serverClosed', {\n    topologyId: self.s.topologyId != -1 ? self.s.topologyId : self.s.id,\n    address: self.name\n  }); // Emit toplogy opening event if not in topology\n\n  if (self.listeners('topologyClosed').length > 0 && !self.s.inTopology) {\n    self.emit('topologyClosed', {\n      topologyId: self.s.id\n    });\n  } // Emit destroy event\n\n\n  if (emitDestroy) self.emit('destroy', self); // Set state as destroyed\n\n  self.s.state = DESTROYED; // Close the pool\n\n  if (self.s.pool) self.s.pool.destroy(); // Flush out all the callbacks\n\n  if (self.s.callbacks) self.s.callbacks.flush(new MongoError(f(\"server %s sockets closed\", self.name)));\n};\n/**\n * Figure out if the server is connected\n * @method\n * @return {boolean}\n */\n\n\nServer.prototype.isConnected = function () {\n  var self = this;\n  if (self.s.pool) return self.s.pool.isConnected();\n  return false;\n};\n/**\n * Figure out if the server instance was destroyed by calling destroy\n * @method\n * @return {boolean}\n */\n\n\nServer.prototype.isDestroyed = function () {\n  return this.s.state == DESTROYED;\n};\n\nvar executeSingleOperation = function (self, ns, cmd, queryOptions, options, onAll, callback) {\n  // Create a query instance\n  var query = new Query(self.s.bson, ns, cmd, queryOptions); // Set slave OK\n\n  query.slaveOk = slaveOk(options.readPreference); // Notify query start to any read Preference strategies\n\n  if (self.s.readPreferenceStrategies != null) {\n    notifyStrategies(self, self.s, 'startOperation', [self, query, new Date()]);\n  } // Raw BSON response\n\n\n  var raw = typeof options.raw == 'boolean' ? options.raw : false; // Do not promote longs\n\n  var promoteLongs = typeof options.promoteLongs == 'boolean' ? options.promoteLongs : true; // Monitoring\n\n  var monitoring = typeof options.monitoring == 'boolean' ? options.monitoring : false; // Execute multiple queries\n\n  if (onAll) {\n    var connections = self.s.pool.getAll();\n    var total = connections.length; // We have an error\n\n    var error = null; // Execute on all connections\n\n    for (var i = 0; i < connections.length; i++) {\n      // Command callback\n      var commandCallback = function (_connection) {\n        return function (err, result) {\n          if (err) error = err;\n          total = total - 1; // Done\n\n          if (total == 0) {\n            // Notify end of command\n            notifyStrategies(self, self.s, 'endOperation', [self, error, result, new Date()]);\n            if (error) return callback(MongoError.create(error)); // Add the connection details\n\n            result.hashedName = _connection.hashedName; // Execute callback, catch and rethrow if needed\n\n            try {\n              callback(null, new CommandResult(options.fullResult ? result : result.documents[0], connections));\n            } catch (err) {\n              process.nextTick(function () {\n                throw err;\n              });\n            }\n          }\n        };\n      }; // Return raw BSON docs\n\n\n      if (raw) {\n        commandCallback.raw = true;\n      } // Increment the request Id\n\n\n      query.incRequestId(); // Add promote long\n\n      commandCallback.promoteLongs = promoteLongs; // Add monitoring\n\n      commandCallback.monitoring = monitoring; // Set the executed connection on the callback\n\n      commandCallback.connection = connections[i]; // Register the callback\n\n      self.s.callbacks.register(query.requestId, commandCallback(connections[i]));\n\n      try {\n        connections[i].write(query.toBin());\n      } catch (err) {\n        // Unregister the command callback\n        self.s.callbacks.unregister(query.requestId);\n        total = total - 1;\n        if (total == 0) return callback(MongoError.create(err));\n      }\n    }\n\n    return;\n  } // Command callback\n\n\n  var commandCallback = function (err, result) {\n    // Notify end of command\n    notifyStrategies(self, self.s, 'endOperation', [self, err, result, new Date()]);\n    if (err) return callback(err);\n    if (result.documents[0]['$err'] || result.documents[0]['errmsg'] || result.documents[0]['err'] || result.documents[0]['code']) return callback(MongoError.create(result.documents[0])); // Add the connection details\n\n    result.hashedName = result.connection.hashedName; // Execute callback, catch and rethrow if needed\n\n    try {\n      callback(null, new CommandResult(options.fullResult ? result : result.documents[0], result.connection));\n    } catch (err) {\n      process.nextTick(function () {\n        throw err;\n      });\n    }\n  }; // Return raw BSON docs\n\n\n  if (raw) commandCallback.raw = true; // Promote long setting\n\n  commandCallback.promoteLongs = promoteLongs; // Register the callback\n\n  self.s.callbacks.register(query.requestId, commandCallback);\n\n  try {\n    // Add monitoring\n    commandCallback.monitoring = monitoring; // Write the query out to the passed in connection or use the pool\n    // Passed in connections are used for authentication mechanisms\n\n    if (options.connection) {\n      // Add the reference to the connection to the callback so\n      // we can flush only the affected operations\n      commandCallback.connection = options.connection;\n      commandCallback.noRelease = true; // Write out the command\n\n      options.connection.write(query.toBin());\n    } else {\n      self.s.pool.write(query.toBin(), commandCallback, options);\n    }\n  } catch (err) {\n    // Un register the command Callback if we threw\n    self.s.callbacks.unregister(query.requestId); // Execute the callback\n\n    return callback(MongoError.create(err));\n  }\n};\n/**\n * Execute a command\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cmd The command hash\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {Boolean} [options.fullResult=false] Return the full envelope instead of just the result document.\n * @param {opResultCallback} callback A callback function\n */\n\n\nServer.prototype.command = function (ns, cmd, options, callback) {\n  if (typeof options == 'function') callback = options, options = {};\n  var self = this;\n  if (this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed'))); // Ensure we have no options\n\n  options = options || {}; // Do we have a read Preference it need to be of type ReadPreference\n\n  if (options.readPreference && !(options.readPreference instanceof ReadPreference)) {\n    throw new Error(\"readPreference must be an instance of ReadPreference\");\n  } // Debug log\n\n\n  if (self.s.logger.isDebug()) self.s.logger.debug(f('executing command [%s] against %s', JSON.stringify({\n    ns: ns,\n    cmd: cmd,\n    options: debugOptions(debugFields, options)\n  }), self.name)); // Topology is not connected, save the call in the provided store to be\n  // Executed at some point when the handler deems it's reconnected\n\n  if (!self.isConnected() && self.s.disconnectHandler != null) {\n    callback = bindToCurrentDomain(callback);\n    return self.s.disconnectHandler.add('command', ns, cmd, options, callback);\n  } // If we have no connection error\n\n\n  if (!self.s.pool.isConnected()) {\n    return callback(new MongoError(f(\"no connection available to server %s\", self.name)));\n  } // Execute on all connections\n\n\n  var onAll = typeof options.onAll == 'boolean' ? options.onAll : false; // Check keys\n\n  var checkKeys = typeof options.checkKeys == 'boolean' ? options.checkKeys : false; // Serialize function\n\n  var serializeFunctions = typeof options.serializeFunctions == 'boolean' ? options.serializeFunctions : false; // Ignore undefined values\n\n  var ignoreUndefined = typeof options.ignoreUndefined == 'boolean' ? options.ignoreUndefined : false; // Raw BSON response\n\n  var raw = typeof options.raw == 'boolean' ? options.raw : false; // Query options\n\n  var queryOptions = {\n    numberToSkip: 0,\n    numberToReturn: -1,\n    checkKeys: checkKeys\n  }; // Set up the serialize functions and ignore undefined\n\n  if (serializeFunctions) queryOptions.serializeFunctions = serializeFunctions;\n  if (ignoreUndefined) queryOptions.ignoreUndefined = ignoreUndefined; // Single operation execution\n\n  executeSingleOperation(self, ns, cmd, queryOptions, options, onAll, callback);\n};\n/**\n * Insert one or more documents\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of documents to insert\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {opResultCallback} callback A callback function\n */\n\n\nServer.prototype.insert = function (ns, ops, options, callback) {\n  if (typeof options == 'function') callback = options, options = {};\n  var self = this;\n  if (this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed'))); // Topology is not connected, save the call in the provided store to be\n  // Executed at some point when the handler deems it's reconnected\n\n  if (!self.isConnected() && self.s.disconnectHandler != null) {\n    callback = bindToCurrentDomain(callback);\n    return self.s.disconnectHandler.add('insert', ns, ops, options, callback);\n  } // Setup the docs as an array\n\n\n  ops = Array.isArray(ops) ? ops : [ops]; // Execute write\n\n  return self.s.wireProtocolHandler.insert(self, self.s.ismaster, ns, self.s.bson, self.s.pool, self.s.callbacks, ops, options, callback);\n};\n/**\n * Perform one or more update operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of updates\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {opResultCallback} callback A callback function\n */\n\n\nServer.prototype.update = function (ns, ops, options, callback) {\n  if (typeof options == 'function') callback = options, options = {};\n  var self = this;\n  if (this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed'))); // Topology is not connected, save the call in the provided store to be\n  // Executed at some point when the handler deems it's reconnected\n\n  if (!self.isConnected() && self.s.disconnectHandler != null) {\n    callback = bindToCurrentDomain(callback);\n    return self.s.disconnectHandler.add('update', ns, ops, options, callback);\n  } // Setup the docs as an array\n\n\n  ops = Array.isArray(ops) ? ops : [ops]; // Execute write\n\n  return self.s.wireProtocolHandler.update(self, self.s.ismaster, ns, self.s.bson, self.s.pool, self.s.callbacks, ops, options, callback);\n};\n/**\n * Perform one or more remove operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of removes\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {opResultCallback} callback A callback function\n */\n\n\nServer.prototype.remove = function (ns, ops, options, callback) {\n  if (typeof options == 'function') callback = options, options = {};\n  var self = this;\n  if (this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed'))); // Topology is not connected, save the call in the provided store to be\n  // Executed at some point when the handler deems it's reconnected\n\n  if (!self.isConnected() && self.s.disconnectHandler != null) {\n    callback = bindToCurrentDomain(callback);\n    return self.s.disconnectHandler.add('remove', ns, ops, options, callback);\n  } // Setup the docs as an array\n\n\n  ops = Array.isArray(ops) ? ops : [ops]; // Execute write\n\n  return self.s.wireProtocolHandler.remove(self, self.s.ismaster, ns, self.s.bson, self.s.pool, self.s.callbacks, ops, options, callback);\n};\n/**\n * Authenticate using a specified mechanism\n * @method\n * @param {string} mechanism The Auth mechanism we are invoking\n * @param {string} db The db we are invoking the mechanism against\n * @param {...object} param Parameters for the specific mechanism\n * @param {authResultCallback} callback A callback function\n */\n\n\nServer.prototype.auth = function (mechanism, db) {\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 2);\n  var callback = args.pop(); // If we don't have the mechanism fail\n\n  if (self.s.authProviders[mechanism] == null && mechanism != 'default') throw new MongoError(f(\"auth provider %s does not exist\", mechanism)); // If we have the default mechanism we pick mechanism based on the wire\n  // protocol max version. If it's >= 3 then scram-sha1 otherwise mongodb-cr\n\n  if (mechanism == 'default' && self.s.ismaster && self.s.ismaster.maxWireVersion >= 3) {\n    mechanism = 'scram-sha-1';\n  } else if (mechanism == 'default') {\n    mechanism = 'mongocr';\n  } // Get all available connections\n\n\n  var connections = self.s.pool.getAll(); // Authentication method that support retries\n\n  var authenticate = function (retries, interval, callback) {\n    retries = retries - 1; // Let's invoke the auth mechanism\n\n    self.s.authProviders[mechanism].auth.apply(self.s.authProviders[mechanism], [self, connections, db].concat(args.slice(0)).concat([function (err, r) {\n      // Not an error return the value\n      if (!err) return callback(err, r); // Log the error\n\n      if (self.s.logger.isError()) {\n        self.s.logger.error(f('[%s] failed to authenticate against server %s', self.s.id, self.name));\n      } // We had an error and we are out of retries return the erro\n\n\n      if (err && retries == 0) return callback(err); // Retry the authentication\n\n      setTimeout(function () {\n        authenticate(retries, interval, callback);\n      }, interval);\n    }]));\n  };\n\n  authenticate(self.s.authenticationRetries, self.s.authenticationRetryIntervalMS, function (err, r) {\n    if (err) return callback(err);\n    if (!r) return callback(new MongoError('could not authenticate'));\n    callback(null, new Session({}, self));\n  });\n}; //\n// Plugin methods\n//\n\n/**\n * Add custom read preference strategy\n * @method\n * @param {string} name Name of the read preference strategy\n * @param {object} strategy Strategy object instance\n */\n\n\nServer.prototype.addReadPreferenceStrategy = function (name, strategy) {\n  var self = this;\n  if (self.s.readPreferenceStrategies == null) self.s.readPreferenceStrategies = {};\n  self.s.readPreferenceStrategies[name] = strategy;\n};\n/**\n * Add custom authentication mechanism\n * @method\n * @param {string} name Name of the authentication mechanism\n * @param {object} provider Authentication object instance\n */\n\n\nServer.prototype.addAuthProvider = function (name, provider) {\n  var self = this;\n  self.s.authProviders[name] = provider;\n};\n/**\n * Compare two server instances\n * @method\n * @param {Server} server Server to compare equality against\n * @return {boolean}\n */\n\n\nServer.prototype.equals = function (server) {\n  if (typeof server == 'string') return server == this.name;\n\n  if (server && server.name) {\n    return server.name == this.name;\n  }\n\n  return false;\n};\n/**\n * All raw connections\n * @method\n * @return {Connection[]}\n */\n\n\nServer.prototype.connections = function () {\n  return this.s.pool.getAll();\n};\n/**\n * Get server\n * @method\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @return {Server}\n */\n\n\nServer.prototype.getServer = function (options) {\n  return this;\n};\n/**\n * Get correct server for a given connection\n * @method\n * @param {Connection} [connection] A Connection showing a current server\n * @return {Server}\n */\n\n\nServer.prototype.getServerFrom = function (connection) {\n  return this;\n};\n/**\n * Get connection\n * @method\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @return {Connection}\n */\n\n\nServer.prototype.getConnection = function (options) {\n  return this.s.pool.get();\n};\n/**\n * Get callbacks object\n * @method\n * @return {Callbacks}\n */\n\n\nServer.prototype.getCallbacks = function () {\n  return this.s.callbacks;\n};\n/**\n * Name of BSON parser currently used\n * @method\n * @return {string}\n */\n\n\nServer.prototype.parserType = function () {\n  var s = this.s;\n  if (s.options.bson.serialize.toString().indexOf('[native code]') != -1) return 'c++';\n  return 'js';\n}; // // Command\n// {\n//     find: ns\n//   , query: <object>\n//   , limit: <n>\n//   , fields: <object>\n//   , skip: <n>\n//   , hint: <string>\n//   , explain: <boolean>\n//   , snapshot: <boolean>\n//   , batchSize: <n>\n//   , returnKey: <boolean>\n//   , maxScan: <n>\n//   , min: <n>\n//   , max: <n>\n//   , showDiskLoc: <boolean>\n//   , comment: <string>\n//   , maxTimeMS: <n>\n//   , raw: <boolean>\n//   , readPreference: <ReadPreference>\n//   , tailable: <boolean>\n//   , oplogReplay: <boolean>\n//   , noCursorTimeout: <boolean>\n//   , awaitdata: <boolean>\n//   , exhaust: <boolean>\n//   , partial: <boolean>\n// }\n\n/**\n * Get a new cursor\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {{object}|{Long}} cmd Can be either a command returning a cursor or a cursorId\n * @param {object} [options.batchSize=0] Batchsize for the operation\n * @param {array} [options.documents=[]] Initial documents list for cursor\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {opResultCallback} callback A callback function\n */\n\n\nServer.prototype.cursor = function (ns, cmd, cursorOptions) {\n  var s = this.s;\n  cursorOptions = cursorOptions || {}; // Set up final cursor type\n\n  var FinalCursor = cursorOptions.cursorFactory || s.Cursor; // Return the cursor\n\n  return new FinalCursor(s.bson, ns, cmd, cursorOptions, this, s.options);\n};\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Server#connect\n * @type {Server}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Server#close\n * @type {Server}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Server#error\n * @type {Server}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Server#timeout\n * @type {Server}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Server#parseError\n * @type {Server}\n */\n\n/**\n * The server reestablished the connection\n *\n * @event Server#reconnect\n * @type {Server}\n */\n\n/**\n * This is an insert result callback\n *\n * @callback opResultCallback\n * @param {error} error An error object. Set to null if no error present\n * @param {CommandResult} command result\n */\n\n/**\n * This is an authentication result callback\n *\n * @callback authResultCallback\n * @param {error} error An error object. Set to null if no error present\n * @param {Session} an authenticated session\n */\n\n\nmodule.exports = Server;","map":null,"metadata":{},"sourceType":"script"}