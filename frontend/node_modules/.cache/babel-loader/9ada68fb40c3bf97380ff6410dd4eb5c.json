{"ast":null,"code":"\"use strict\";\n\nvar inherits = require('util').inherits,\n    f = require('util').format,\n    b = require('bson'),\n    bindToCurrentDomain = require('../connection/utils').bindToCurrentDomain,\n    EventEmitter = require('events').EventEmitter,\n    BasicCursor = require('../cursor'),\n    BSON = require('bson').native().BSON,\n    BasicCursor = require('../cursor'),\n    Server = require('./server'),\n    MongoCR = require('../auth/mongocr'),\n    X509 = require('../auth/x509'),\n    Plain = require('../auth/plain'),\n    GSSAPI = require('../auth/gssapi'),\n    SSPI = require('../auth/sspi'),\n    ScramSHA1 = require('../auth/scram'),\n    Logger = require('../connection/logger'),\n    ReadPreference = require('./read_preference'),\n    Session = require('./session'),\n    MongoError = require('../error');\n/**\n * @fileOverview The **Mongos** class is a class that represents a Mongos Proxy topology and is\n * used to construct connections.\n *\n * @example\n * var Mongos = require('mongodb-core').Mongos\n *   , ReadPreference = require('mongodb-core').ReadPreference\n *   , assert = require('assert');\n *\n * var server = new Mongos([{host: 'localhost', port: 30000}]);\n * // Wait for the connection event\n * server.on('connect', function(server) {\n *   server.destroy();\n * });\n *\n * // Start connecting\n * server.connect();\n */\n\n\nvar DISCONNECTED = 'disconnected';\nvar CONNECTING = 'connecting';\nvar CONNECTED = 'connected';\nvar DESTROYED = 'destroyed'; // All bson types\n\nvar bsonTypes = [b.Long, b.ObjectID, b.Binary, b.Code, b.DBRef, b.Symbol, b.Double, b.Timestamp, b.MaxKey, b.MinKey]; // BSON parser\n\nvar bsonInstance = null; // Instance id\n\nvar mongosId = 0; //\n// Clone the options\n\nvar cloneOptions = function (options) {\n  var opts = {};\n\n  for (var name in options) {\n    opts[name] = options[name];\n  }\n\n  return opts;\n};\n\nvar State = function (readPreferenceStrategies, localThresholdMS) {\n  // Internal state\n  this.s = {\n    connectedServers: [],\n    disconnectedServers: [],\n    readPreferenceStrategies: readPreferenceStrategies,\n    lowerBoundLatency: Number.MAX_VALUE,\n    localThresholdMS: localThresholdMS,\n    index: 0,\n    topologyDescription: null\n  };\n};\n/**\n * Emit event if it exists\n * @method\n */\n\n\nfunction emitSDAMEvent(self, event, description) {\n  if (self.listeners(event).length > 0) {\n    self.emit(event, description);\n  }\n}\n/**\n * Is there a secondary connected\n * @method\n * @return {boolean}\n */\n\n\nState.prototype.resetDescription = function () {\n  this.s.topologyDescription = {\n    \"topologyType\": \"Sharded\",\n    \"servers\": []\n  };\n};\n\nfunction emitTopologyDescriptionChanged(self, state) {\n  if (self.listeners('topologyDescriptionChanged').length > 0 && state) {\n    var state = state.s; // Generate description\n\n    var description = {\n      topologyType: 'Sharded',\n      servers: []\n    }; // Add all the secondaries\n\n    description.servers = description.servers.concat(state.connectedServers.map(function (x) {\n      var description = x.getDescription();\n      description.type = 'Mongos';\n      return description;\n    }));\n    description.servers = description.servers.concat(state.disconnectedServers.map(function (x) {\n      var description = x.getDescription();\n      description.type = 'Unknown';\n      return description;\n    })); // Create the result\n\n    var result = {\n      topologyId: self.id,\n      previousDescription: state.topologyDescription,\n      newDescription: description\n    }; // Emit the topologyDescription change\n\n    self.emit('topologyDescriptionChanged', result); // Set the new description\n\n    state.topologyDescription = description;\n  }\n} //\n// A Mongos connected\n\n\nState.prototype.connected = function (server) {\n  // Locate in disconnected servers and remove\n  this.s.disconnectedServers = this.s.disconnectedServers.filter(function (s) {\n    return !s.equals(server);\n  });\n  var found = false; // Check if the server exists\n\n  this.s.connectedServers.forEach(function (s) {\n    if (s.equals(server)) found = true;\n  }); // Add to disconnected list if it does not already exist\n\n  if (!found) this.s.connectedServers.push(server); // Adjust lower bound\n\n  if (this.s.lowerBoundLatency > server.s.isMasterLatencyMS) {\n    this.s.lowerBoundLatency = server.s.isMasterLatencyMS;\n  }\n}; //\n// A Mongos disconnected\n\n\nState.prototype.disconnected = function (server) {\n  // Locate in disconnected servers and remove\n  this.s.connectedServers = this.s.connectedServers.filter(function (s) {\n    return !s.equals(server);\n  });\n  var found = false; // Check if the server exists\n\n  this.s.disconnectedServers.forEach(function (s) {\n    if (s.equals(server)) found = true;\n  }); // Add to disconnected list if it does not already exist\n\n  if (!found) this.s.disconnectedServers.push(server);\n}; //\n// Return the list of disconnected servers\n\n\nState.prototype.disconnectedServers = function () {\n  return this.s.disconnectedServers.slice(0);\n}; //\n// Get connectedServers\n\n\nState.prototype.connectedServers = function () {\n  return this.s.connectedServers.slice(0);\n}; //\n// Get all servers\n\n\nState.prototype.getAll = function () {\n  return this.s.connectedServers.slice(0).concat(this.s.disconnectedServers);\n}; //\n// Get all connections\n\n\nState.prototype.getAllConnections = function () {\n  var connections = [];\n  this.s.connectedServers.forEach(function (e) {\n    connections = connections.concat(e.connections());\n  });\n  return connections;\n}; //\n// Unref the state\n\n\nState.prototype.unref = function () {\n  // Unref all the servers\n  for (var i = 0; i < this.s.connectedServers.length; i++) {\n    // Get each of the servers\n    var server = this.s.connectedServers[i]; // Remove any non used handlers\n\n    ['error', 'close', 'timeout', 'connect'].forEach(function (e) {\n      server.removeAllListeners(e);\n    }); // Unreference the server\n\n    server.unref();\n  }\n}; //\n// Destroy the state\n\n\nState.prototype.destroy = function () {\n  // Destroy any connected servers\n  while (this.s.connectedServers.length > 0) {\n    var server = this.s.connectedServers.shift(); // Remove any non used handlers\n\n    ['error', 'close', 'timeout', 'connect'].forEach(function (e) {\n      server.removeAllListeners(e);\n    }); // Server destroy\n\n    server.destroy(); // Add to list of disconnected servers\n\n    this.s.disconnectedServers.push(server);\n  }\n};\n\nvar pickProxies = function (self, options) {\n  options = options || {};\n  var readPreference = options.readPreference || ReadPreference.primary; // All connected servers\n\n  var servers = self.s.connectedServers.slice(0); // Do we have a custom readPreference strategy, use it\n\n  if (self.s.readPreferenceStrategies != null && self.s.readPreferenceStrategies[readPreference] != null) {\n    var server = self.s.readPreferenceStrategies[readPreference].pickServer(servers, readPreference); // Return the server if one is found\n\n    return !server ? [] : [server];\n  } // Filter out the possible servers\n\n\n  servers = self.s.connectedServers.filter(function (server) {\n    if (server.s.isMasterLatencyMS <= self.s.lowerBoundLatency + self.s.localThresholdMS && server.isConnected()) {\n      return true;\n    }\n  }); // If no servers found return the lowest latency proxy\n\n  if (servers.length == 0 && self.s.connectedServers.length > 0) {\n    servers = self.s.connectedServers.sort(function (server1, server2) {\n      return server1.s.isMasterLatencyMS - server2.s.isMasterLatencyMS;\n    }); // Return the lowest latency server if none is found\n\n    return [servers[0]];\n  } // Return all the servers found\n\n\n  return servers;\n}; //\n// Are we connected\n\n\nState.prototype.isConnected = function (options) {\n  // Get all the servers\n  var servers = pickProxies(this, options); // Return if the server is connected\n\n  return servers.length > 0 ? true : false;\n}; //\n// Pick a server\n\n\nState.prototype.pickServer = function (readPreference) {\n  // Get all the servers\n  var servers = pickProxies(this, {\n    readPreference: readPreference\n  }); // No valid connections\n\n  if (servers.length == 0) throw new MongoError(\"no mongos proxy available\"); // Update index\n\n  this.s.index = (this.s.index + 1) % servers.length; // Pick first one\n\n  return servers[this.s.index];\n};\n/**\n * Creates a new Mongos instance\n * @class\n * @param {array} seedlist A list of seeds for the replicaset\n * @param {number} [options.reconnectTries=30] Reconnect retries for HA if no servers available\n * @param {number} [options.haInterval=5000] The High availability period for replicaset inquiry\n * @param {boolean} [options.emitError=false] Server will emit errors events\n * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors\n * @param {number} [options.size=5] Server connection pool size\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled\n * @param {number} [options.localThresholdMS=15] Cutoff latency point in MS for MongoS proxy selection\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=1000] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n * @param {boolean} [options.singleBufferSerializtion=true] Serialize into single buffer, trade of peak memory for serialization speed\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passphrase] SSL Certificate pass phrase\n * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @return {Mongos} A cursor instance\n * @fires Mongos#connect\n * @fires Mongos#joined\n * @fires Mongos#left\n */\n\n\nvar Mongos = function (seedlist, options) {\n  var self = this;\n  options = options || {}; // Add event listener\n\n  EventEmitter.call(this); // Validate seedlist\n\n  if (!Array.isArray(seedlist)) throw new MongoError(\"seedlist must be an array\"); // Validate list\n\n  if (seedlist.length == 0) throw new MongoError(\"seedlist must contain at least one entry\"); // Validate entries\n\n  seedlist.forEach(function (e) {\n    if (typeof e.host != 'string' || typeof e.port != 'number') throw new MongoError(\"seedlist entry must contain a host and port\");\n  }); // BSON Parser, ensure we have a single instance\n\n  bsonInstance = bsonInstance == null ? new BSON(bsonTypes) : bsonInstance; // Pick the right bson parser\n\n  var bson = options.bson ? options.bson : bsonInstance; // Add bson parser to options\n\n  options.bson = bson; // The Mongos state\n\n  this.s = {\n    // Seed list for sharding passed in\n    seedlist: seedlist // Passed in options\n    ,\n    options: options // Logger\n    ,\n    logger: Logger('Mongos', options) // Reconnect tries\n    ,\n    reconnectTries: options.reconnectTries || 30 // Ha interval\n    ,\n    haInterval: options.haInterval || 5000 // localThresholdMS\n    ,\n    localThresholdMS: options.localThresholdMS || 15 // Have omitted fullsetup\n    ,\n    fullsetup: false // Cursor factory\n    ,\n    Cursor: options.cursorFactory || BasicCursor // Current credentials used for auth\n    ,\n    credentials: [] // BSON Parser\n    ,\n    bsonInstance: bsonInstance,\n    bson: bson // Pings\n    ,\n    pings: {} // Default state\n    ,\n    state: DISCONNECTED // Swallow or emit errors\n    ,\n    emitError: typeof options.emitError == 'boolean' ? options.emitError : false // Contains any alternate strategies for picking\n    ,\n    readPreferenceStrategies: {} // Auth providers\n    ,\n    authProviders: {} // Unique instance id\n    ,\n    id: mongosId++ // Authentication in progress\n    ,\n    authInProgress: false // Servers added while auth in progress\n    ,\n    authInProgressServers: [] // Current retries left\n    ,\n    retriesLeft: options.reconnectTries || 30 // Do we have a not connected handler\n    ,\n    disconnectHandler: options.disconnectHandler\n  }; // Set up the connection timeout for the options\n\n  options.connectionTimeout = options.connectionTimeout || 1000; // Create a new state for the mongos\n\n  this.s.mongosState = new State(this.s.readPreferenceStrategies, this.s.localThresholdMS); // Add the authentication mechanisms\n\n  this.addAuthProvider('mongocr', new MongoCR());\n  this.addAuthProvider('x509', new X509());\n  this.addAuthProvider('plain', new Plain());\n  this.addAuthProvider('gssapi', new GSSAPI());\n  this.addAuthProvider('sspi', new SSPI());\n  this.addAuthProvider('scram-sha-1', new ScramSHA1()); // BSON property (find a server and pass it along)\n\n  Object.defineProperty(this, 'bson', {\n    enumerable: true,\n    get: function () {\n      var servers = self.s.mongosState.getAll();\n      return servers.length > 0 ? servers[0].bson : null;\n    }\n  });\n  Object.defineProperty(this, 'id', {\n    enumerable: true,\n    get: function () {\n      return self.s.id;\n    }\n  });\n  Object.defineProperty(this, 'type', {\n    enumerable: true,\n    get: function () {\n      return 'mongos';\n    }\n  });\n  Object.defineProperty(this, 'haInterval', {\n    enumerable: true,\n    get: function () {\n      return self.s.haInterval;\n    }\n  });\n  Object.defineProperty(this, 'state', {\n    enumerable: true,\n    get: function () {\n      return self.s.mongosState;\n    }\n  });\n};\n\ninherits(Mongos, EventEmitter);\n/**\n * Name of BSON parser currently used\n * @method\n * @return {string}\n */\n\nMongos.prototype.parserType = function () {\n  if (this.s.bson.serialize.toString().indexOf('[native code]') != -1) return 'c++';\n  return 'js';\n};\n/**\n * Execute a command\n * @method\n * @param {string} type Type of BSON parser to use (c++ or js)\n */\n\n\nMongos.prototype.setBSONParserType = function (type) {\n  var nBSON = null;\n\n  if (type == 'c++') {\n    nBSON = require('bson').native().BSON;\n  } else if (type == 'js') {\n    nBSON = require('bson').pure().BSON;\n  } else {\n    throw new MongoError(f(\"% parser not supported\", type));\n  }\n\n  this.s.options.bson = new nBSON(bsonTypes);\n};\n/**\n * Returns the last known ismaster document for this server\n * @method\n * @return {object}\n */\n\n\nMongos.prototype.lastIsMaster = function () {\n  var connectedServers = this.s.mongosState.connectedServers();\n  if (connectedServers.length > 0) return connectedServers[0].lastIsMaster();\n  return null;\n};\n/**\n * Initiate server connect\n * @method\n */\n\n\nMongos.prototype.connect = function (_options) {\n  var self = this; // Start replicaset inquiry process\n\n  setTimeout(mongosInquirer(self, self.s), self.s.haInterval); // Additional options\n\n  if (_options) for (var name in _options) self.s.options[name] = _options[name]; // For all entries in the seedlist build a server instance\n\n  self.s.seedlist.forEach(function (e) {\n    // Clone options\n    var opts = cloneOptions(self.s.options); // Add host and port\n\n    opts.host = e.host;\n    opts.port = e.port;\n    opts.reconnect = false;\n    opts.readPreferenceStrategies = self.s.readPreferenceStrategies; // Share the auth store\n\n    opts.authProviders = self.s.authProviders; // Don't emit errors\n\n    opts.emitError = true; // Set that server is in a topology\n\n    opts.inTopology = true;\n    opts.topologyId = self.s.id;\n    opts.monitoring = true; // Create a new Server\n\n    self.s.mongosState.disconnected(new Server(opts));\n  }); // Reset the replState\n\n  this.s.mongosState.resetDescription(); // Emit the topology opening event\n\n  emitSDAMEvent(this, 'topologyOpening', {\n    topologyId: this.s.id\n  }); // Get the disconnected servers\n\n  var servers = self.s.mongosState.disconnectedServers(); // Set connecting state\n\n  this.s.state = CONNECTING; // Attempt to connect to all the servers\n\n  while (servers.length > 0) {\n    // Get the server\n    var server = servers.shift(); // Remove any non used handlers\n\n    ['error', 'close', 'timeout', 'connect', 'message', 'parseError', 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHearbeatFailed', 'serverClosed'].forEach(function (e) {\n      server.removeAllListeners(e);\n    }); // Set up the event handlers\n\n    server.once('error', errorHandlerTemp(self, self.s, server));\n    server.once('close', errorHandlerTemp(self, self.s, server));\n    server.once('timeout', errorHandlerTemp(self, self.s, server));\n    server.once('parseError', errorHandlerTemp(self, self.s, server));\n    server.once('connect', connectHandler(self, self.s, 'connect')); // SDAM Monitoring events\n\n    server.on('serverOpening', function (e) {\n      self.emit('serverOpening', e);\n    });\n    server.on('serverDescriptionChanged', function (e) {\n      self.emit('serverDescriptionChanged', e);\n    });\n    server.on('serverHeartbeatStarted', function (e) {\n      self.emit('serverHeartbeatStarted', e);\n    });\n    server.on('serverHeartbeatSucceeded', function (e) {\n      self.emit('serverHeartbeatSucceeded', e);\n    });\n    server.on('serverHearbeatFailed', function (e) {\n      self.emit('serverHearbeatFailed', e);\n    });\n    server.on('serverClosed', function (e) {\n      self.emit('serverClosed', e);\n    });\n    if (self.s.logger.isInfo()) self.s.logger.info(f('connecting to server %s', server.name)); // Execute the connect\n\n    var execute = function (_server) {\n      process.nextTick(function () {\n        _server.connect();\n      });\n    }; // Connect\n\n\n    execute(server);\n  }\n};\n/**\n * Unref all connections belong to this server\n * @method\n */\n\n\nMongos.prototype.unref = function (emitClose) {\n  if (this.s.logger.isInfo()) this.s.logger.info(f('[%s] unreferenced', this.s.id)); // Emit close\n\n  if (emitClose && this.listeners('close').length > 0) this.emit('close', this); // Unref sockets\n\n  this.s.mongosState.unref();\n};\n/**\n * Destroy the server connection\n * @method\n */\n\n\nMongos.prototype.destroy = function (emitClose) {\n  this.s.state = DESTROYED; // Emit toplogy closing event\n\n  emitSDAMEvent(this, 'topologyClosed', {\n    topologyId: this.s.id\n  }); // Emit close\n\n  if (emitClose && self.listeners('close').length > 0) self.emit('close', self); // Destroy the state\n\n  this.s.mongosState.destroy();\n};\n/**\n * Figure out if the server is connected\n * @method\n * @return {boolean}\n */\n\n\nMongos.prototype.isConnected = function (options) {\n  return this.s.mongosState.isConnected(options);\n};\n/**\n * Figure out if the server instance was destroyed by calling destroy\n * @method\n * @return {boolean}\n */\n\n\nMongos.prototype.isDestroyed = function () {\n  return this.s.state == DESTROYED;\n}; //\n// Operations\n//\n\n/**\n * Insert one or more documents\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of documents to insert\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {opResultCallback} callback A callback function\n */\n\n\nMongos.prototype.insert = function (ns, ops, options, callback) {\n  if (typeof options == 'function') callback = options, options = {};\n  if (this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed'))); // Topology is not connected, save the call in the provided store to be\n  // Executed at some point when the handler deems it's reconnected\n\n  if (!this.isConnected() && this.s.disconnectHandler != null) {\n    callback = bindToCurrentDomain(callback);\n    return this.s.disconnectHandler.add('insert', ns, ops, options, callback);\n  }\n\n  executeWriteOperation(this.s, 'insert', ns, ops, options, callback);\n};\n/**\n * Perform one or more update operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of updates\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {opResultCallback} callback A callback function\n */\n\n\nMongos.prototype.update = function (ns, ops, options, callback) {\n  if (typeof options == 'function') callback = options, options = {};\n  if (this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed'))); // Topology is not connected, save the call in the provided store to be\n  // Executed at some point when the handler deems it's reconnected\n\n  if (!this.isConnected() && this.s.disconnectHandler != null) {\n    callback = bindToCurrentDomain(callback);\n    return this.s.disconnectHandler.add('update', ns, ops, options, callback);\n  }\n\n  executeWriteOperation(this.s, 'update', ns, ops, options, callback);\n};\n/**\n * Perform one or more remove operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of removes\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {opResultCallback} callback A callback function\n */\n\n\nMongos.prototype.remove = function (ns, ops, options, callback) {\n  if (typeof options == 'function') callback = options, options = {};\n  if (this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed'))); // Topology is not connected, save the call in the provided store to be\n  // Executed at some point when the handler deems it's reconnected\n\n  if (!this.isConnected() && this.s.disconnectHandler != null) {\n    callback = bindToCurrentDomain(callback);\n    return this.s.disconnectHandler.add('remove', ns, ops, options, callback);\n  }\n\n  executeWriteOperation(this.s, 'remove', ns, ops, options, callback);\n};\n/**\n * Execute a command\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cmd The command hash\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Connection} [options.connection] Specify connection object to execute command against\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {opResultCallback} callback A callback function\n */\n\n\nMongos.prototype.command = function (ns, cmd, options, callback) {\n  if (typeof options == 'function') callback = options, options = {};\n  if (this.s.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));\n  var self = this; // Topology is not connected, save the call in the provided store to be\n  // Executed at some point when the handler deems it's reconnected\n\n  if (!self.isConnected() && self.s.disconnectHandler != null) {\n    callback = bindToCurrentDomain(callback);\n    return self.s.disconnectHandler.add('command', ns, cmd, options, callback);\n  }\n\n  var server = null; // Ensure we have no options\n\n  options = options || {}; // We need to execute the command on all servers\n\n  if (options.onAll) {\n    var servers = self.s.mongosState.getAll();\n    var count = servers.length;\n    var cmdErr = null;\n\n    for (var i = 0; i < servers.length; i++) {\n      servers[i].command(ns, cmd, options, function (err, r) {\n        count = count - 1; // Finished executing command\n\n        if (count == 0) {\n          // Was it a logout command clear any credentials\n          if (cmd.logout) clearCredentials(self.s, ns); // Return the error\n\n          callback(err, r);\n        }\n      });\n    }\n\n    return;\n  }\n\n  try {\n    // Get a primary\n    server = self.s.mongosState.pickServer(options.writeConcern ? ReadPreference.primary : options.readPreference);\n  } catch (err) {\n    return callback(err);\n  } // No server returned we had an error\n\n\n  if (server == null) return callback(new MongoError(\"no mongos found\"));\n  server.command(ns, cmd, options, function (err, r) {\n    // Was it a logout command clear any credentials\n    if (cmd.logout) clearCredentials(self.s, ns);\n    callback(err, r);\n  });\n};\n/**\n * Perform one or more remove operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {{object}|{Long}} cmd Can be either a command returning a cursor or a cursorId\n * @param {object} [options.batchSize=0] Batchsize for the operation\n * @param {array} [options.documents=[]] Initial documents list for cursor\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {opResultCallback} callback A callback function\n */\n\n\nMongos.prototype.cursor = function (ns, cmd, cursorOptions) {\n  cursorOptions = cursorOptions || {};\n  var FinalCursor = cursorOptions.cursorFactory || this.s.Cursor;\n  return new FinalCursor(this.s.bson, ns, cmd, cursorOptions, this, this.s.options);\n};\n/**\n * Authenticate using a specified mechanism\n * @method\n * @param {string} mechanism The Auth mechanism we are invoking\n * @param {string} db The db we are invoking the mechanism against\n * @param {...object} param Parameters for the specific mechanism\n * @param {authResultCallback} callback A callback function\n */\n\n\nMongos.prototype.auth = function (mechanism, db) {\n  var allArgs = Array.prototype.slice.call(arguments, 0).slice(0);\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 2);\n  var callback = args.pop(); // If we don't have the mechanism fail\n\n  if (this.s.authProviders[mechanism] == null && mechanism != 'default') throw new MongoError(f(\"auth provider %s does not exist\", mechanism)); // Authenticate against all the servers\n\n  var servers = this.s.mongosState.connectedServers().slice(0);\n  var count = servers.length; // Correct authentication\n\n  var authenticated = true;\n  var authErr = null; // Set auth in progress\n\n  this.s.authInProgress = true; // Authenticate against all servers\n\n  while (servers.length > 0) {\n    var server = servers.shift(); // Arguments without a callback\n\n    var argsWithoutCallback = [mechanism, db].concat(args.slice(0)); // Create arguments\n\n    var finalArguments = argsWithoutCallback.concat([function (err, r) {\n      count = count - 1;\n      if (err) authErr = err;\n      if (!r) authenticated = false; // We are done\n\n      if (count == 0) {\n        // We have more servers that are not authenticated, let's authenticate\n        if (self.s.authInProgressServers.length > 0) {\n          self.s.authInProgressServers = [];\n          return self.auth.apply(self, [mechanism, db].concat(args).concat([callback]));\n        } // Auth is done\n\n\n        self.s.authInProgress = false; // Add successful credentials\n\n        if (authErr == null) addCredentials(self.s, db, argsWithoutCallback); // Return the auth error\n\n        if (authErr) return callback(authErr, false); // Successfully authenticated session\n\n        callback(null, new Session({}, self));\n      }\n    }]); // Execute the auth\n\n    server.auth.apply(server, finalArguments);\n  }\n}; //\n// Plugin methods\n//\n\n/**\n * Add custom read preference strategy\n * @method\n * @param {string} name Name of the read preference strategy\n * @param {object} strategy Strategy object instance\n */\n\n\nMongos.prototype.addReadPreferenceStrategy = function (name, strategy) {\n  if (this.s.readPreferenceStrategies == null) this.s.readPreferenceStrategies = {};\n  this.s.readPreferenceStrategies[name] = strategy;\n};\n/**\n * Add custom authentication mechanism\n * @method\n * @param {string} name Name of the authentication mechanism\n * @param {object} provider Authentication object instance\n */\n\n\nMongos.prototype.addAuthProvider = function (name, provider) {\n  this.s.authProviders[name] = provider;\n};\n/**\n * Get connection\n * @method\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @return {Connection}\n */\n\n\nMongos.prototype.getConnection = function (options) {\n  // Ensure we have no options\n  options = options || {}; // Pick the right server based on readPreference\n\n  var server = this.s.mongosState.pickServer(options.readPreference);\n  if (server == null) return null; // Return connection\n\n  return server.getConnection();\n};\n/**\n * Get server\n * @method\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @return {Server}\n */\n\n\nMongos.prototype.getServer = function (options) {\n  // Ensure we have no options\n  options = options || {}; // Pick the right server based on readPreference\n\n  return this.s.mongosState.pickServer(options.readPreference);\n};\n/**\n * Get correct server for a given connection\n * @method\n * @param {Connection} [connection] A Connection showing a current server\n * @return {Server}\n */\n\n\nMongos.prototype.getServerFrom = function (connection) {\n  var servers = this.s.mongosState.getAll(); // Go through all the server\n\n  for (var i = 0; i < servers.length; i++) {\n    if (servers[i].equals(connection.name)) return servers[i];\n  }\n\n  return null;\n};\n/**\n * All raw connections\n * @method\n * @return {Connection[]}\n */\n\n\nMongos.prototype.connections = function () {\n  return this.s.mongosState.getAllConnections();\n}; //\n// Inquires about state changes\n//\n\n\nvar mongosInquirer = function (self, state) {\n  return function () {\n    if (state.state == DESTROYED) return;\n    if (state.state == CONNECTED) state.retriesLeft = state.reconnectTries; // If we have a disconnected site\n\n    if (state.state == DISCONNECTED && state.retriesLeft == 0) {\n      self.destroy();\n      return self.emit('error', new MongoError(f('failed to reconnect after %s', state.reconnectTries)));\n    } else if (state.state == DISCONNECTED) {\n      state.retriesLeft = state.retriesLeft - 1;\n    } // If we have a primary and a disconnect handler, execute\n    // buffered operations\n\n\n    if (state.mongosState.isConnected() && state.disconnectHandler) {\n      state.disconnectHandler.execute();\n    } // Log the information\n\n\n    if (state.logger.isDebug()) state.logger.debug(f('mongos ha proceess running')); // Let's query any disconnected proxies\n\n    var disconnectedServers = state.mongosState.disconnectedServers();\n    if (disconnectedServers.length == 0) return setTimeout(mongosInquirer(self, state), state.haInterval); // Count of connections waiting to be connected\n\n    var connectionCount = disconnectedServers.length;\n    if (state.logger.isDebug()) state.logger.debug(f('mongos ha proceess found %d disconnected proxies', connectionCount)); // Let's attempt to reconnect\n\n    while (disconnectedServers.length > 0) {\n      // Connect to proxy\n      var connectToProxy = function (_server) {\n        setTimeout(function () {\n          // Remove any non used handlers\n          ['error', 'close', 'timeout', 'connect', 'message', 'parseError', 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHearbeatFailed', 'serverClosed'].forEach(function (e) {\n            _server.removeAllListeners(e);\n          }); // Set up the event handlers\n\n          _server.once('error', errorHandlerTemp(self, state, server));\n\n          _server.once('close', errorHandlerTemp(self, state, server));\n\n          _server.once('timeout', errorHandlerTemp(self, state, server));\n\n          _server.once('connect', connectHandler(self, state, 'ha')); // SDAM Monitoring events\n\n\n          _server.on('serverOpening', function (e) {\n            self.emit('serverOpening', e);\n          });\n\n          _server.on('serverDescriptionChanged', function (e) {\n            self.emit('serverDescriptionChanged', e);\n          });\n\n          _server.on('serverHeartbeatStarted', function (e) {\n            self.emit('serverHeartbeatStarted', e);\n          });\n\n          _server.on('serverHeartbeatSucceeded', function (e) {\n            self.emit('serverHeartbeatSucceeded', e);\n          });\n\n          _server.on('serverHearbeatFailed', function (e) {\n            self.emit('serverHearbeatFailed', e);\n          });\n\n          _server.on('serverClosed', function (e) {\n            self.emit('serverClosed', e);\n          }); // Start connect\n\n\n          _server.connect();\n        }, 1);\n      };\n\n      var server = disconnectedServers.shift();\n      if (state.logger.isDebug()) state.logger.debug(f('attempting to connect to server %s', server.name));\n      connectToProxy(server);\n    } // Let's keep monitoring but wait for possible timeout to happen\n\n\n    return setTimeout(mongosInquirer(self, state), state.options.connectionTimeout + state.haInterval);\n  };\n}; //\n// Error handler for initial connect\n\n\nvar errorHandlerTemp = function (self, state, server) {\n  return function (err, server) {\n    // Log the information\n    if (state.logger.isInfo()) state.logger.info(f('server %s disconnected with error %s', server.name, JSON.stringify(err))); // Signal disconnect of server\n\n    state.mongosState.disconnected(server); // Remove any non used handlers\n\n    var events = ['error', 'close', 'timeout', 'connect'];\n    events.forEach(function (e) {\n      server.removeAllListeners(e);\n    });\n  };\n}; //\n// Handlers\n\n\nvar errorHandler = function (self, state) {\n  return function (err, server) {\n    if (state.logger.isInfo()) state.logger.info(f('server %s errored out with %s', server.name, JSON.stringify(err)));\n    state.mongosState.disconnected(server); // No more servers left emit close\n\n    if (state.mongosState.connectedServers().length == 0) {\n      state.state = DISCONNECTED;\n    } // Emit topology changed event\n\n\n    emitTopologyDescriptionChanged(self, state.mongosState); // Signal server left\n\n    self.emit('left', 'mongos', server);\n    if (state.emitError) self.emit('error', err, server);\n  };\n};\n\nvar timeoutHandler = function (self, state) {\n  return function (err, server) {\n    if (state.logger.isInfo()) state.logger.info(f('server %s timed out', server.name));\n    state.mongosState.disconnected(server); // No more servers emit close event if no entries left\n\n    if (state.mongosState.connectedServers().length == 0) {\n      state.state = DISCONNECTED;\n    } // Emit topology changed event\n\n\n    emitTopologyDescriptionChanged(self, state.mongosState); // Signal server left\n\n    self.emit('left', 'mongos', server);\n  };\n};\n\nvar closeHandler = function (self, state) {\n  return function (err, server) {\n    if (state.logger.isInfo()) state.logger.info(f('server %s closed', server.name));\n    state.mongosState.disconnected(server); // No more servers left emit close\n\n    if (state.mongosState.connectedServers().length == 0) {\n      state.state = DISCONNECTED;\n    } // Emit topology changed event\n\n\n    emitTopologyDescriptionChanged(self, state.mongosState); // Signal server left\n\n    self.emit('left', 'mongos', server);\n  };\n}; // Connect handler\n\n\nvar connectHandler = function (self, state, e) {\n  return function (server) {\n    if (state.logger.isInfo()) state.logger.info(f('connected to %s', server.name)); // Remove any non used handlers\n\n    ['error', 'close', 'timeout', 'connect', 'message', 'parseError'].forEach(function (e) {\n      server.removeAllListeners(e);\n    }); // finish processing the server\n\n    var processNewServer = function (_server) {\n      // Add the server handling code\n      if (_server.isConnected()) {\n        _server.once('error', errorHandler(self, state));\n\n        _server.once('close', closeHandler(self, state));\n\n        _server.once('timeout', timeoutHandler(self, state));\n\n        _server.once('parseError', timeoutHandler(self, state));\n      } // Emit joined event\n\n\n      self.emit('joined', 'mongos', _server); // Add to list connected servers\n\n      state.mongosState.connected(_server); // Do we have a reconnect event\n\n      if ('ha' == e && state.mongosState.connectedServers().length == 1) {\n        self.emit('reconnect', _server);\n      } // Full setup\n\n\n      if (state.mongosState.disconnectedServers().length == 0 && state.mongosState.connectedServers().length > 0 && !state.fullsetup) {\n        state.fullsetup = true;\n        self.emit('fullsetup', self);\n      } // all connected\n\n\n      if (state.mongosState.disconnectedServers().length == 0 && state.mongosState.connectedServers().length == state.seedlist.length && !state.all) {\n        state.all = true;\n        self.emit('all', self);\n      } // Emit topology changed event\n\n\n      emitTopologyDescriptionChanged(self, state.mongosState); // Set connected\n\n      if (state.state == DISCONNECTED) {\n        state.state = CONNECTED;\n        self.emit('reconnect', self);\n      } else if (state.state == CONNECTING) {\n        state.state = CONNECTED;\n        self.emit('connect', self);\n      }\n    }; // Is there an authentication process ongoing\n\n\n    if (state.authInProgress) {\n      state.authInProgressServers.push(server);\n    } // No credentials just process server\n\n\n    if (state.credentials.length == 0) return processNewServer(server); // Do we have credentials, let's apply them all\n\n    var count = state.credentials.length; // Apply the credentials\n\n    for (var i = 0; i < state.credentials.length; i++) {\n      server.auth.apply(server, state.credentials[i].concat([function (err, r) {\n        count = count - 1;\n\n        if (count == 0) {\n          // Did someone call destroy on the connection, close and return\n          if (self.s.state == DESTROYED) {\n            return server.destroy(false, false);\n          } // Otherwise process server\n\n\n          processNewServer(server);\n        }\n      }]));\n    }\n  };\n}; //\n// Add server to the list if it does not exist\n\n\nvar addToListIfNotExist = function (list, server) {\n  var found = false; // Remove any non used handlers\n\n  ['error', 'close', 'timeout', 'connect'].forEach(function (e) {\n    server.removeAllListeners(e);\n  }); // Check if the server already exists\n\n  for (var i = 0; i < list.length; i++) {\n    if (list[i].equals(server)) found = true;\n  }\n\n  if (!found) {\n    list.push(server);\n  }\n}; // Add the new credential for a db, removing the old\n// credential from the cache\n\n\nvar addCredentials = function (state, db, argsWithoutCallback) {\n  // Remove any credentials for the db\n  clearCredentials(state, db + \".dummy\"); // Add new credentials to list\n\n  state.credentials.push(argsWithoutCallback);\n}; // Clear out credentials for a namespace\n\n\nvar clearCredentials = function (state, ns) {\n  var db = ns.split('.')[0];\n  var filteredCredentials = []; // Filter out all credentials for the db the user is logging out off\n\n  for (var i = 0; i < state.credentials.length; i++) {\n    if (state.credentials[i][1] != db) filteredCredentials.push(state.credentials[i]);\n  } // Set new list of credentials\n\n\n  state.credentials = filteredCredentials;\n};\n\nvar processReadPreference = function (cmd, options) {\n  options = options || {}; // No read preference specified\n\n  if (options.readPreference == null) return cmd;\n}; //\n// Execute write operation\n\n\nvar executeWriteOperation = function (state, op, ns, ops, options, callback) {\n  if (typeof options == 'function') {\n    callback = options;\n    options = {};\n  }\n\n  var server = null; // Ensure we have no options\n\n  options = options || {};\n\n  try {\n    // Get a primary\n    server = state.mongosState.pickServer();\n  } catch (err) {\n    return callback(err);\n  } // No server returned we had an error\n\n\n  if (server == null) return callback(new MongoError(\"no mongos found\")); // Execute the command\n\n  server[op](ns, ops, options, callback);\n};\n/**\n * A mongos connect event, used to verify that the connection is up and running\n *\n * @event Mongos#connect\n * @type {Mongos}\n */\n\n/**\n * A server member left the mongos list\n *\n * @event Mongos#left\n * @type {Mongos}\n * @param {string} type The type of member that left (mongos)\n * @param {Server} server The server object that left\n */\n\n/**\n * A server member joined the mongos list\n *\n * @event Mongos#joined\n * @type {Mongos}\n * @param {string} type The type of member that left (mongos)\n * @param {Server} server The server object that joined\n */\n\n\nmodule.exports = Mongos;","map":null,"metadata":{},"sourceType":"script"}