{"ast":null,"code":"\"use strict\";\n\nvar inherits = require('util').inherits,\n    EventEmitter = require('events').EventEmitter,\n    net = require('net'),\n    tls = require('tls'),\n    f = require('util').format,\n    crypto = require('crypto'),\n    getSingleProperty = require('./utils').getSingleProperty,\n    debugOptions = require('./utils').debugOptions,\n    Response = require('./commands').Response,\n    MongoError = require('../error'),\n    Logger = require('./logger');\n\nvar _id = 0;\nvar debugFields = ['host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'socketTimeout', 'singleBufferSerializtion', 'ssl', 'ca', 'cert', 'rejectUnauthorized', 'promoteLongs', 'checkServerIdentity'];\n/**\n * Creates a new Connection instance\n * @class\n * @param {string} options.host The server host\n * @param {number} options.port The server port\n * @param {number} [options.size=5] Server connection pool size\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=0] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n * @param {boolean} [options.singleBufferSerializtion=true] Serialize into single buffer, trade of peak memory for serialization speed\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passphrase] SSL Certificate pass phrase\n * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @fires Connection#connect\n * @fires Connection#close\n * @fires Connection#error\n * @fires Connection#timeout\n * @fires Connection#parseError\n * @return {Connection} A cursor instance\n */\n\nvar Connection = function (options) {\n  // Add event listener\n  EventEmitter.call(this); // Set empty if no options passed\n\n  this.options = options || {}; // Identification information\n\n  this.id = _id++; // Logger instance\n\n  this.logger = Logger('Connection', options); // No bson parser passed in\n\n  if (!options.bson) throw new Error(\"must pass in valid bson parser\"); // Get bson parser\n\n  this.bson = options.bson; // Grouping tag used for debugging purposes\n\n  this.tag = options.tag; // Message handler\n\n  this.messageHandler = options.messageHandler; // Max BSON message size\n\n  this.maxBsonMessageSize = options.maxBsonMessageSize || 1024 * 1024 * 16 * 4; // Debug information\n\n  if (this.logger.isDebug()) this.logger.debug(f('creating connection %s with options [%s]', this.id, JSON.stringify(debugOptions(debugFields, options)))); // Default options\n\n  this.port = options.port || 27017;\n  this.host = options.host || 'localhost';\n  this.keepAlive = typeof options.keepAlive == 'boolean' ? options.keepAlive : true;\n  this.keepAliveInitialDelay = options.keepAliveInitialDelay || 0;\n  this.noDelay = typeof options.noDelay == 'boolean' ? options.noDelay : true;\n  this.connectionTimeout = options.connectionTimeout || 0;\n  this.socketTimeout = options.socketTimeout || 0;\n  this.initialSocketTimeout = this.socketTimeout; // If connection was destroyed\n\n  this.destroyed = false; // Check if we have a domain socket\n\n  this.domainSocket = this.host.indexOf('\\/') != -1; // Serialize commands using function\n\n  this.singleBufferSerializtion = typeof options.singleBufferSerializtion == 'boolean' ? options.singleBufferSerializtion : true;\n  this.serializationFunction = this.singleBufferSerializtion ? 'toBinUnified' : 'toBin'; // SSL options\n\n  this.ca = options.ca || null;\n  this.cert = options.cert || null;\n  this.key = options.key || null;\n  this.passphrase = options.passphrase || null;\n  this.ssl = typeof options.ssl == 'boolean' ? options.ssl : false;\n  this.rejectUnauthorized = typeof options.rejectUnauthorized == 'boolean' ? options.rejectUnauthorized : true;\n  this.checkServerIdentity = typeof options.checkServerIdentity == 'boolean' || typeof options.checkServerIdentity == 'function' ? options.checkServerIdentity : true; // If ssl not enabled\n\n  if (!this.ssl) this.rejectUnauthorized = false; // Response options\n\n  this.responseOptions = {\n    promoteLongs: typeof options.promoteLongs == 'boolean' ? options.promoteLongs : true\n  }; // State of the connection\n\n  this.state = 'DISCONNECTED'; // Flushing\n\n  this.flushing = false;\n  this.queue = []; // Internal state\n\n  this.connection = null;\n  this.writeStream = null; // Create hash method\n\n  var hash = crypto.createHash('sha1');\n  hash.update(f('%s:%s', this.host, this.port)); // Create a hash name\n\n  this.hashedName = hash.digest('hex');\n};\n\ninherits(Connection, EventEmitter);\nObject.defineProperty(Connection.prototype, 'name', {\n  enumerable: true,\n  get: function () {\n    return this.port ? f(\"%s:%s\", this.host, this.port) : this.host;\n  }\n});\nObject.defineProperty(Connection.prototype, 'socketTimeoutMS', {\n  enumerable: true,\n  set: function (value) {\n    if (typeof value != 'number') throw new Error(\"socketTimeoutMS requires a number\"); // Set the socket timeout\n\n    this.socketTimeout = value; // Set the socket timeout on the socket\n\n    this.connection.setTimeout(value);\n  },\n  get: function () {\n    return this.socketTimeout;\n  }\n}); //\n// Connection handlers\n\nvar errorHandler = function (self) {\n  return function (err) {\n    // Debug information\n    if (self.logger.isDebug()) self.logger.debug(f('connection %s for [%s:%s] errored out with [%s]', self.id, self.host, self.port, JSON.stringify(err))); // Emit the error\n\n    if (self.listeners('error').length > 0 || self.ssl && self.state == 'CONNECTING') self.emit(\"error\", MongoError.create(err), self); // Set state to closed\n\n    self.state = 'DISCONNECTED';\n  };\n};\n\nvar timeoutHandler = function (self) {\n  return function () {\n    // Set state to closed\n    self.state = 'DISCONNECTED'; // Debug information\n\n    if (self.logger.isDebug()) self.logger.debug(f('connection %s for [%s:%s] timed out', self.id, self.host, self.port)); // Emit timeout error\n\n    self.emit(\"timeout\", MongoError.create(f(\"connection %s to %s:%s timed out\", self.id, self.host, self.port)), self);\n  };\n};\n\nvar closeHandler = function (self) {\n  return function (hadError) {\n    // Set state to closed\n    self.state = 'DISCONNECTED'; // Debug information\n\n    if (self.logger.isDebug()) self.logger.debug(f('connection %s with for [%s:%s] closed', self.id, self.host, self.port)); // Emit close event\n\n    if (!hadError) {\n      self.emit(\"close\", MongoError.create(f(\"connection %s to %s:%s closed\", self.id, self.host, self.port)), self);\n    }\n  };\n};\n\nvar dataHandler = function (self) {\n  return function (data) {\n    // Parse until we are done with the data\n    while (data.length > 0) {\n      // If we still have bytes to read on the current message\n      if (self.bytesRead > 0 && self.sizeOfMessage > 0) {\n        // Calculate the amount of remaining bytes\n        var remainingBytesToRead = self.sizeOfMessage - self.bytesRead; // Check if the current chunk contains the rest of the message\n\n        if (remainingBytesToRead > data.length) {\n          // Copy the new data into the exiting buffer (should have been allocated when we know the message size)\n          data.copy(self.buffer, self.bytesRead); // Adjust the number of bytes read so it point to the correct index in the buffer\n\n          self.bytesRead = self.bytesRead + data.length; // Reset state of buffer\n\n          data = new Buffer(0);\n        } else {\n          // Copy the missing part of the data into our current buffer\n          data.copy(self.buffer, self.bytesRead, 0, remainingBytesToRead); // Slice the overflow into a new buffer that we will then re-parse\n\n          data = data.slice(remainingBytesToRead); // Emit current complete message\n\n          try {\n            var emitBuffer = self.buffer; // Reset state of buffer\n\n            self.buffer = null;\n            self.sizeOfMessage = 0;\n            self.bytesRead = 0;\n            self.stubBuffer = null; // Emit the buffer\n\n            self.messageHandler(new Response(self, self.bson, emitBuffer, self.responseOptions), self);\n          } catch (err) {\n            var errorObject = {\n              err: \"socketHandler\",\n              trace: err,\n              bin: self.buffer,\n              parseState: {\n                sizeOfMessage: self.sizeOfMessage,\n                bytesRead: self.bytesRead,\n                stubBuffer: self.stubBuffer\n              }\n            }; // We got a parse Error fire it off then keep going\n\n            self.emit(\"parseError\", errorObject, self);\n          }\n        }\n      } else {\n        // Stub buffer is kept in case we don't get enough bytes to determine the\n        // size of the message (< 4 bytes)\n        if (self.stubBuffer != null && self.stubBuffer.length > 0) {\n          // If we have enough bytes to determine the message size let's do it\n          if (self.stubBuffer.length + data.length > 4) {\n            // Prepad the data\n            var newData = new Buffer(self.stubBuffer.length + data.length);\n            self.stubBuffer.copy(newData, 0);\n            data.copy(newData, self.stubBuffer.length); // Reassign for parsing\n\n            data = newData; // Reset state of buffer\n\n            self.buffer = null;\n            self.sizeOfMessage = 0;\n            self.bytesRead = 0;\n            self.stubBuffer = null;\n          } else {\n            // Add the the bytes to the stub buffer\n            var newStubBuffer = new Buffer(self.stubBuffer.length + data.length); // Copy existing stub buffer\n\n            self.stubBuffer.copy(newStubBuffer, 0); // Copy missing part of the data\n\n            data.copy(newStubBuffer, self.stubBuffer.length); // Exit parsing loop\n\n            data = new Buffer(0);\n          }\n        } else {\n          if (data.length > 4) {\n            // Retrieve the message size\n            // var sizeOfMessage = data.readUInt32LE(0);\n            var sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24; // If we have a negative sizeOfMessage emit error and return\n\n            if (sizeOfMessage < 0 || sizeOfMessage > self.maxBsonMessageSize) {\n              var errorObject = {\n                err: \"socketHandler\",\n                trace: '',\n                bin: self.buffer,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: self.bytesRead,\n                  stubBuffer: self.stubBuffer\n                }\n              }; // We got a parse Error fire it off then keep going\n\n              self.emit(\"parseError\", errorObject, self);\n              return;\n            } // Ensure that the size of message is larger than 0 and less than the max allowed\n\n\n            if (sizeOfMessage > 4 && sizeOfMessage < self.maxBsonMessageSize && sizeOfMessage > data.length) {\n              self.buffer = new Buffer(sizeOfMessage); // Copy all the data into the buffer\n\n              data.copy(self.buffer, 0); // Update bytes read\n\n              self.bytesRead = data.length; // Update sizeOfMessage\n\n              self.sizeOfMessage = sizeOfMessage; // Ensure stub buffer is null\n\n              self.stubBuffer = null; // Exit parsing loop\n\n              data = new Buffer(0);\n            } else if (sizeOfMessage > 4 && sizeOfMessage < self.maxBsonMessageSize && sizeOfMessage == data.length) {\n              try {\n                var emitBuffer = data; // Reset state of buffer\n\n                self.buffer = null;\n                self.sizeOfMessage = 0;\n                self.bytesRead = 0;\n                self.stubBuffer = null; // Exit parsing loop\n\n                data = new Buffer(0); // Emit the message\n\n                self.messageHandler(new Response(self, self.bson, emitBuffer, self.responseOptions), self);\n              } catch (err) {\n                var errorObject = {\n                  err: \"socketHandler\",\n                  trace: err,\n                  bin: self.buffer,\n                  parseState: {\n                    sizeOfMessage: self.sizeOfMessage,\n                    bytesRead: self.bytesRead,\n                    stubBuffer: self.stubBuffer\n                  }\n                }; // We got a parse Error fire it off then keep going\n\n                self.emit(\"parseError\", errorObject, self);\n              }\n            } else if (sizeOfMessage <= 4 || sizeOfMessage > self.maxBsonMessageSize) {\n              var errorObject = {\n                err: \"socketHandler\",\n                trace: null,\n                bin: data,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: 0,\n                  buffer: null,\n                  stubBuffer: null\n                }\n              }; // We got a parse Error fire it off then keep going\n\n              self.emit(\"parseError\", errorObject, self); // Clear out the state of the parser\n\n              self.buffer = null;\n              self.sizeOfMessage = 0;\n              self.bytesRead = 0;\n              self.stubBuffer = null; // Exit parsing loop\n\n              data = new Buffer(0);\n            } else {\n              var emitBuffer = data.slice(0, sizeOfMessage); // Reset state of buffer\n\n              self.buffer = null;\n              self.sizeOfMessage = 0;\n              self.bytesRead = 0;\n              self.stubBuffer = null; // Copy rest of message\n\n              data = data.slice(sizeOfMessage); // Emit the message\n\n              self.messageHandler(new Response(self, self.bson, emitBuffer, self.responseOptions), self);\n            }\n          } else {\n            // Create a buffer that contains the space for the non-complete message\n            self.stubBuffer = new Buffer(data.length); // Copy the data to the stub buffer\n\n            data.copy(self.stubBuffer, 0); // Exit parsing loop\n\n            data = new Buffer(0);\n          }\n        }\n      }\n    }\n  };\n};\n/**\n * Connect\n * @method\n */\n\n\nConnection.prototype.connect = function (_options) {\n  var self = this;\n  _options = _options || {}; // Set connection state\n\n  this.state = 'CONNECTING'; // Check if we are overriding the promoteLongs\n\n  if (typeof _options.promoteLongs == 'boolean') {\n    self.responseOptions.promoteLongs = _options.promoteLongs;\n  } // Create new connection instance\n\n\n  self.connection = self.domainSocket ? net.createConnection(self.host) : net.createConnection(self.port, self.host); // Only change setting if a value is provided\n\n  if (self.keepAlive) {\n    self.connection.setKeepAlive(self.keepAlive, self.keepAliveInitialDelay);\n  } // Set the options for the connection\n\n\n  self.connection.setTimeout(self.connectionTimeout);\n  self.connection.setNoDelay(self.noDelay); // If we have ssl enabled\n\n  if (self.ssl) {\n    var sslOptions = {\n      socket: self.connection,\n      rejectUnauthorized: self.rejectUnauthorized\n    };\n    if (self.ca) sslOptions.ca = self.ca;\n    if (self.cert) sslOptions.cert = self.cert;\n    if (self.key) sslOptions.key = self.key;\n    if (self.passphrase) sslOptions.passphrase = self.passphrase; // Override checkServerIdentity behavior\n\n    if (self.checkServerIdentity == false) {\n      // Skip the identiy check by retuning undefined as per node documents\n      // https://nodejs.org/api/tls.html#tls_tls_connect_options_callback\n      sslOptions.checkServerIdentity = function (servername, cert) {\n        return undefined;\n      };\n    } else if (typeof self.checkServerIdentity == 'function') {\n      sslOptions.checkServerIdentity = self.checkServerIdentity;\n    }\n\n    try {\n      self.connection = tls.connect(self.port, self.host, sslOptions, function () {\n        // Error on auth or skip\n        if (self.connection.authorizationError && self.rejectUnauthorized) {\n          return self.emit(\"error\", self.connection.authorizationError, self, {\n            ssl: true\n          });\n        } // Set socket timeout instead of connection timeout\n\n\n        self.connection.setTimeout(self.socketTimeout); // Set connected state\n\n        self.state = 'CONNECTED'; // We are done emit connect\n\n        self.emit('connect', self);\n      });\n    } catch (error) {\n      // In the case of an invalid key, the Node tls module raises the error\n      // Error: error:0B080074:x509 certificate routines:X509_check_private_key\n      // but does not emit an error event like all other errors. We handle this\n      // and other potential inconsistencies here.\n      process.nextTick(function () {\n        return self.emit(\"error\", MongoError.create(error), self, {\n          ssl: true\n        });\n      });\n    }\n\n    self.connection.setTimeout(self.connectionTimeout);\n  } else {\n    self.connection.on('connect', function () {\n      // Set socket timeout instead of connection timeout\n      self.connection.setTimeout(self.socketTimeout); // Set connected state\n\n      self.state = 'CONNECTED'; // Emit connect event\n\n      self.emit('connect', self);\n    });\n  } // Add handlers for events\n\n\n  self.connection.once('error', errorHandler(self));\n  self.connection.once('timeout', timeoutHandler(self));\n  self.connection.once('close', closeHandler(self));\n  self.connection.on('data', dataHandler(self));\n};\n/**\n * Unref this connection\n * @method\n * @return {boolean}\n */\n\n\nConnection.prototype.unref = function () {\n  if (this.connection) this.connection.unref();else {\n    var self = this;\n    this.once('connect', function () {\n      self.connection.unref();\n    });\n  }\n};\n/**\n * Destroy connection\n * @method\n */\n\n\nConnection.prototype.destroy = function () {\n  if (this.connection) {\n    if (this.connection.unref) {\n      this.connection.unref();\n    }\n\n    this.connection.end();\n    this.connection.destroy();\n  }\n\n  this.destroyed = true;\n};\n/**\n * Write to connection\n * @method\n * @param {Command} command Command to write out need to implement toBin and toBinUnified\n */\n\n\nConnection.prototype.write = function (buffer) {\n  // Debug Log\n  if (this.logger.isDebug()) {\n    if (!Array.isArray(buffer)) {\n      this.logger.debug(f('writing buffer [%s] to %s:%s', buffer.toString('hex'), this.host, this.port));\n    } else {\n      for (var i = 0; i < buffer.length; i++) this.logger.debug(f('writing buffer [%s] to %s:%s', buffer[i].toString('hex'), this.host, this.port));\n    }\n  } // Write out the command\n\n\n  if (!Array.isArray(buffer)) return this.connection.write(buffer, 'binary'); // Iterate over all buffers and write them in order to the socket\n\n  for (var i = 0; i < buffer.length; i++) this.connection.write(buffer[i], 'binary');\n};\n/**\n * Return id of connection as a string\n * @method\n * @return {string}\n */\n\n\nConnection.prototype.toString = function () {\n  return \"\" + this.id;\n};\n/**\n * Return json object of connection\n * @method\n * @return {object}\n */\n\n\nConnection.prototype.toJSON = function () {\n  return {\n    id: this.id,\n    host: this.host,\n    port: this.port\n  };\n};\n/**\n * Is the connection connected\n * @method\n * @return {boolean}\n */\n\n\nConnection.prototype.isConnected = function () {\n  if (this.destroyed) return false;\n  return !this.connection.destroyed && this.connection.writable;\n};\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Connection#connect\n * @type {Connection}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Connection#close\n * @type {Connection}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Connection#error\n * @type {Connection}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Connection#timeout\n * @type {Connection}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Connection#parseError\n * @type {Connection}\n */\n\n\nmodule.exports = Connection;","map":null,"metadata":{},"sourceType":"script"}