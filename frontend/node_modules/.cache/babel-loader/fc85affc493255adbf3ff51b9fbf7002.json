{"ast":null,"code":"/* @preserve\n * The MIT License (MIT)\n * \n * Copyright (c) 2013-2015 Petka Antonov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n * \n */\n\n/**\n * bluebird build version 2.11.0\n * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, cancel, using, filter, any, each, timers\n*/\n!function (e) {\n  if (\"object\" == typeof exports && \"undefined\" != typeof module) module.exports = e();else if (\"function\" == typeof define && define.amd) define([], e);else {\n    var f;\n    \"undefined\" != typeof window ? f = window : \"undefined\" != typeof global ? f = global : \"undefined\" != typeof self && (f = self), f.Promise = e();\n  }\n}(function () {\n  var define, module, exports;\n  return function e(t, n, r) {\n    function s(o, u) {\n      if (!n[o]) {\n        if (!t[o]) {\n          var a = typeof _dereq_ == \"function\" && _dereq_;\n          if (!u && a) return a(o, !0);\n          if (i) return i(o, !0);\n          var f = new Error(\"Cannot find module '\" + o + \"'\");\n          throw f.code = \"MODULE_NOT_FOUND\", f;\n        }\n\n        var l = n[o] = {\n          exports: {}\n        };\n        t[o][0].call(l.exports, function (e) {\n          var n = t[o][1][e];\n          return s(n ? n : e);\n        }, l, l.exports, e, t, n, r);\n      }\n\n      return n[o].exports;\n    }\n\n    var i = typeof _dereq_ == \"function\" && _dereq_;\n\n    for (var o = 0; o < r.length; o++) s(r[o]);\n\n    return s;\n  }({\n    1: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise) {\n        var SomePromiseArray = Promise._SomePromiseArray;\n\n        function any(promises) {\n          var ret = new SomePromiseArray(promises);\n          var promise = ret.promise();\n          ret.setHowMany(1);\n          ret.setUnwrap();\n          ret.init();\n          return promise;\n        }\n\n        Promise.any = function (promises) {\n          return any(promises);\n        };\n\n        Promise.prototype.any = function () {\n          return any(this);\n        };\n      };\n    }, {}],\n    2: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      var firstLineError;\n\n      try {\n        throw new Error();\n      } catch (e) {\n        firstLineError = e;\n      }\n\n      var schedule = _dereq_(\"./schedule.js\");\n\n      var Queue = _dereq_(\"./queue.js\");\n\n      var util = _dereq_(\"./util.js\");\n\n      function Async() {\n        this._isTickUsed = false;\n        this._lateQueue = new Queue(16);\n        this._normalQueue = new Queue(16);\n        this._trampolineEnabled = true;\n        var self = this;\n\n        this.drainQueues = function () {\n          self._drainQueues();\n        };\n\n        this._schedule = schedule.isStatic ? schedule(this.drainQueues) : schedule;\n      }\n\n      Async.prototype.disableTrampolineIfNecessary = function () {\n        if (util.hasDevTools) {\n          this._trampolineEnabled = false;\n        }\n      };\n\n      Async.prototype.enableTrampoline = function () {\n        if (!this._trampolineEnabled) {\n          this._trampolineEnabled = true;\n\n          this._schedule = function (fn) {\n            setTimeout(fn, 0);\n          };\n        }\n      };\n\n      Async.prototype.haveItemsQueued = function () {\n        return this._normalQueue.length() > 0;\n      };\n\n      Async.prototype.throwLater = function (fn, arg) {\n        if (arguments.length === 1) {\n          arg = fn;\n\n          fn = function () {\n            throw arg;\n          };\n        }\n\n        if (typeof setTimeout !== \"undefined\") {\n          setTimeout(function () {\n            fn(arg);\n          }, 0);\n        } else try {\n          this._schedule(function () {\n            fn(arg);\n          });\n        } catch (e) {\n          throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/m3OTXk\\u000a\");\n        }\n      };\n\n      function AsyncInvokeLater(fn, receiver, arg) {\n        this._lateQueue.push(fn, receiver, arg);\n\n        this._queueTick();\n      }\n\n      function AsyncInvoke(fn, receiver, arg) {\n        this._normalQueue.push(fn, receiver, arg);\n\n        this._queueTick();\n      }\n\n      function AsyncSettlePromises(promise) {\n        this._normalQueue._pushOne(promise);\n\n        this._queueTick();\n      }\n\n      if (!util.hasDevTools) {\n        Async.prototype.invokeLater = AsyncInvokeLater;\n        Async.prototype.invoke = AsyncInvoke;\n        Async.prototype.settlePromises = AsyncSettlePromises;\n      } else {\n        if (schedule.isStatic) {\n          schedule = function (fn) {\n            setTimeout(fn, 0);\n          };\n        }\n\n        Async.prototype.invokeLater = function (fn, receiver, arg) {\n          if (this._trampolineEnabled) {\n            AsyncInvokeLater.call(this, fn, receiver, arg);\n          } else {\n            this._schedule(function () {\n              setTimeout(function () {\n                fn.call(receiver, arg);\n              }, 100);\n            });\n          }\n        };\n\n        Async.prototype.invoke = function (fn, receiver, arg) {\n          if (this._trampolineEnabled) {\n            AsyncInvoke.call(this, fn, receiver, arg);\n          } else {\n            this._schedule(function () {\n              fn.call(receiver, arg);\n            });\n          }\n        };\n\n        Async.prototype.settlePromises = function (promise) {\n          if (this._trampolineEnabled) {\n            AsyncSettlePromises.call(this, promise);\n          } else {\n            this._schedule(function () {\n              promise._settlePromises();\n            });\n          }\n        };\n      }\n\n      Async.prototype.invokeFirst = function (fn, receiver, arg) {\n        this._normalQueue.unshift(fn, receiver, arg);\n\n        this._queueTick();\n      };\n\n      Async.prototype._drainQueue = function (queue) {\n        while (queue.length() > 0) {\n          var fn = queue.shift();\n\n          if (typeof fn !== \"function\") {\n            fn._settlePromises();\n\n            continue;\n          }\n\n          var receiver = queue.shift();\n          var arg = queue.shift();\n          fn.call(receiver, arg);\n        }\n      };\n\n      Async.prototype._drainQueues = function () {\n        this._drainQueue(this._normalQueue);\n\n        this._reset();\n\n        this._drainQueue(this._lateQueue);\n      };\n\n      Async.prototype._queueTick = function () {\n        if (!this._isTickUsed) {\n          this._isTickUsed = true;\n\n          this._schedule(this.drainQueues);\n        }\n      };\n\n      Async.prototype._reset = function () {\n        this._isTickUsed = false;\n      };\n\n      module.exports = new Async();\n      module.exports.firstLineError = firstLineError;\n    }, {\n      \"./queue.js\": 28,\n      \"./schedule.js\": 31,\n      \"./util.js\": 38\n    }],\n    3: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise, INTERNAL, tryConvertToPromise) {\n        var rejectThis = function (_, e) {\n          this._reject(e);\n        };\n\n        var targetRejected = function (e, context) {\n          context.promiseRejectionQueued = true;\n\n          context.bindingPromise._then(rejectThis, rejectThis, null, this, e);\n        };\n\n        var bindingResolved = function (thisArg, context) {\n          if (this._isPending()) {\n            this._resolveCallback(context.target);\n          }\n        };\n\n        var bindingRejected = function (e, context) {\n          if (!context.promiseRejectionQueued) this._reject(e);\n        };\n\n        Promise.prototype.bind = function (thisArg) {\n          var maybePromise = tryConvertToPromise(thisArg);\n          var ret = new Promise(INTERNAL);\n\n          ret._propagateFrom(this, 1);\n\n          var target = this._target();\n\n          ret._setBoundTo(maybePromise);\n\n          if (maybePromise instanceof Promise) {\n            var context = {\n              promiseRejectionQueued: false,\n              promise: ret,\n              target: target,\n              bindingPromise: maybePromise\n            };\n\n            target._then(INTERNAL, targetRejected, ret._progress, ret, context);\n\n            maybePromise._then(bindingResolved, bindingRejected, ret._progress, ret, context);\n          } else {\n            ret._resolveCallback(target);\n          }\n\n          return ret;\n        };\n\n        Promise.prototype._setBoundTo = function (obj) {\n          if (obj !== undefined) {\n            this._bitField = this._bitField | 131072;\n            this._boundTo = obj;\n          } else {\n            this._bitField = this._bitField & ~131072;\n          }\n        };\n\n        Promise.prototype._isBound = function () {\n          return (this._bitField & 131072) === 131072;\n        };\n\n        Promise.bind = function (thisArg, value) {\n          var maybePromise = tryConvertToPromise(thisArg);\n          var ret = new Promise(INTERNAL);\n\n          ret._setBoundTo(maybePromise);\n\n          if (maybePromise instanceof Promise) {\n            maybePromise._then(function () {\n              ret._resolveCallback(value);\n            }, ret._reject, ret._progress, ret, null);\n          } else {\n            ret._resolveCallback(value);\n          }\n\n          return ret;\n        };\n      };\n    }, {}],\n    4: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      var old;\n      if (typeof Promise !== \"undefined\") old = Promise;\n\n      function noConflict() {\n        try {\n          if (Promise === bluebird) Promise = old;\n        } catch (e) {}\n\n        return bluebird;\n      }\n\n      var bluebird = _dereq_(\"./promise.js\")();\n\n      bluebird.noConflict = noConflict;\n      module.exports = bluebird;\n    }, {\n      \"./promise.js\": 23\n    }],\n    5: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      var cr = Object.create;\n\n      if (cr) {\n        var callerCache = cr(null);\n        var getterCache = cr(null);\n        callerCache[\" size\"] = getterCache[\" size\"] = 0;\n      }\n\n      module.exports = function (Promise) {\n        var util = _dereq_(\"./util.js\");\n\n        var canEvaluate = util.canEvaluate;\n        var isIdentifier = util.isIdentifier;\n        var getMethodCaller;\n        var getGetter;\n\n        if (!true) {\n          var makeMethodCaller = function (methodName) {\n            return new Function(\"ensureMethod\", \"                                    \\n\\\n        return function(obj) {                                               \\n\\\n            'use strict'                                                     \\n\\\n            var len = this.length;                                           \\n\\\n            ensureMethod(obj, 'methodName');                                 \\n\\\n            switch(len) {                                                    \\n\\\n                case 1: return obj.methodName(this[0]);                      \\n\\\n                case 2: return obj.methodName(this[0], this[1]);             \\n\\\n                case 3: return obj.methodName(this[0], this[1], this[2]);    \\n\\\n                case 0: return obj.methodName();                             \\n\\\n                default:                                                     \\n\\\n                    return obj.methodName.apply(obj, this);                  \\n\\\n            }                                                                \\n\\\n        };                                                                   \\n\\\n        \".replace(/methodName/g, methodName))(ensureMethod);\n          };\n\n          var makeGetter = function (propertyName) {\n            return new Function(\"obj\", \"                                             \\n\\\n        'use strict';                                                        \\n\\\n        return obj.propertyName;                                             \\n\\\n        \".replace(\"propertyName\", propertyName));\n          };\n\n          var getCompiled = function (name, compiler, cache) {\n            var ret = cache[name];\n\n            if (typeof ret !== \"function\") {\n              if (!isIdentifier(name)) {\n                return null;\n              }\n\n              ret = compiler(name);\n              cache[name] = ret;\n              cache[\" size\"]++;\n\n              if (cache[\" size\"] > 512) {\n                var keys = Object.keys(cache);\n\n                for (var i = 0; i < 256; ++i) delete cache[keys[i]];\n\n                cache[\" size\"] = keys.length - 256;\n              }\n            }\n\n            return ret;\n          };\n\n          getMethodCaller = function (name) {\n            return getCompiled(name, makeMethodCaller, callerCache);\n          };\n\n          getGetter = function (name) {\n            return getCompiled(name, makeGetter, getterCache);\n          };\n        }\n\n        function ensureMethod(obj, methodName) {\n          var fn;\n          if (obj != null) fn = obj[methodName];\n\n          if (typeof fn !== \"function\") {\n            var message = \"Object \" + util.classString(obj) + \" has no method '\" + util.toString(methodName) + \"'\";\n            throw new Promise.TypeError(message);\n          }\n\n          return fn;\n        }\n\n        function caller(obj) {\n          var methodName = this.pop();\n          var fn = ensureMethod(obj, methodName);\n          return fn.apply(obj, this);\n        }\n\n        Promise.prototype.call = function (methodName) {\n          var $_len = arguments.length;\n          var args = new Array($_len - 1);\n\n          for (var $_i = 1; $_i < $_len; ++$_i) {\n            args[$_i - 1] = arguments[$_i];\n          }\n\n          if (!true) {\n            if (canEvaluate) {\n              var maybeCaller = getMethodCaller(methodName);\n\n              if (maybeCaller !== null) {\n                return this._then(maybeCaller, undefined, undefined, args, undefined);\n              }\n            }\n          }\n\n          args.push(methodName);\n          return this._then(caller, undefined, undefined, args, undefined);\n        };\n\n        function namedGetter(obj) {\n          return obj[this];\n        }\n\n        function indexedGetter(obj) {\n          var index = +this;\n          if (index < 0) index = Math.max(0, index + obj.length);\n          return obj[index];\n        }\n\n        Promise.prototype.get = function (propertyName) {\n          var isIndex = typeof propertyName === \"number\";\n          var getter;\n\n          if (!isIndex) {\n            if (canEvaluate) {\n              var maybeGetter = getGetter(propertyName);\n              getter = maybeGetter !== null ? maybeGetter : namedGetter;\n            } else {\n              getter = namedGetter;\n            }\n          } else {\n            getter = indexedGetter;\n          }\n\n          return this._then(getter, undefined, undefined, propertyName, undefined);\n        };\n      };\n    }, {\n      \"./util.js\": 38\n    }],\n    6: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise) {\n        var errors = _dereq_(\"./errors.js\");\n\n        var async = _dereq_(\"./async.js\");\n\n        var CancellationError = errors.CancellationError;\n\n        Promise.prototype._cancel = function (reason) {\n          if (!this.isCancellable()) return this;\n          var parent;\n          var promiseToReject = this;\n\n          while ((parent = promiseToReject._cancellationParent) !== undefined && parent.isCancellable()) {\n            promiseToReject = parent;\n          }\n\n          this._unsetCancellable();\n\n          promiseToReject._target()._rejectCallback(reason, false, true);\n        };\n\n        Promise.prototype.cancel = function (reason) {\n          if (!this.isCancellable()) return this;\n          if (reason === undefined) reason = new CancellationError();\n          async.invokeLater(this._cancel, this, reason);\n          return this;\n        };\n\n        Promise.prototype.cancellable = function () {\n          if (this._cancellable()) return this;\n          async.enableTrampoline();\n\n          this._setCancellable();\n\n          this._cancellationParent = undefined;\n          return this;\n        };\n\n        Promise.prototype.uncancellable = function () {\n          var ret = this.then();\n\n          ret._unsetCancellable();\n\n          return ret;\n        };\n\n        Promise.prototype.fork = function (didFulfill, didReject, didProgress) {\n          var ret = this._then(didFulfill, didReject, didProgress, undefined, undefined);\n\n          ret._setCancellable();\n\n          ret._cancellationParent = undefined;\n          return ret;\n        };\n      };\n    }, {\n      \"./async.js\": 2,\n      \"./errors.js\": 13\n    }],\n    7: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function () {\n        var async = _dereq_(\"./async.js\");\n\n        var util = _dereq_(\"./util.js\");\n\n        var bluebirdFramePattern = /[\\\\\\/]bluebird[\\\\\\/]js[\\\\\\/](main|debug|zalgo|instrumented)/;\n        var stackFramePattern = null;\n        var formatStack = null;\n        var indentStackFrames = false;\n        var warn;\n\n        function CapturedTrace(parent) {\n          this._parent = parent;\n          var length = this._length = 1 + (parent === undefined ? 0 : parent._length);\n          captureStackTrace(this, CapturedTrace);\n          if (length > 32) this.uncycle();\n        }\n\n        util.inherits(CapturedTrace, Error);\n\n        CapturedTrace.prototype.uncycle = function () {\n          var length = this._length;\n          if (length < 2) return;\n          var nodes = [];\n          var stackToIndex = {};\n\n          for (var i = 0, node = this; node !== undefined; ++i) {\n            nodes.push(node);\n            node = node._parent;\n          }\n\n          length = this._length = i;\n\n          for (var i = length - 1; i >= 0; --i) {\n            var stack = nodes[i].stack;\n\n            if (stackToIndex[stack] === undefined) {\n              stackToIndex[stack] = i;\n            }\n          }\n\n          for (var i = 0; i < length; ++i) {\n            var currentStack = nodes[i].stack;\n            var index = stackToIndex[currentStack];\n\n            if (index !== undefined && index !== i) {\n              if (index > 0) {\n                nodes[index - 1]._parent = undefined;\n                nodes[index - 1]._length = 1;\n              }\n\n              nodes[i]._parent = undefined;\n              nodes[i]._length = 1;\n              var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;\n\n              if (index < length - 1) {\n                cycleEdgeNode._parent = nodes[index + 1];\n\n                cycleEdgeNode._parent.uncycle();\n\n                cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;\n              } else {\n                cycleEdgeNode._parent = undefined;\n                cycleEdgeNode._length = 1;\n              }\n\n              var currentChildLength = cycleEdgeNode._length + 1;\n\n              for (var j = i - 2; j >= 0; --j) {\n                nodes[j]._length = currentChildLength;\n                currentChildLength++;\n              }\n\n              return;\n            }\n          }\n        };\n\n        CapturedTrace.prototype.parent = function () {\n          return this._parent;\n        };\n\n        CapturedTrace.prototype.hasParent = function () {\n          return this._parent !== undefined;\n        };\n\n        CapturedTrace.prototype.attachExtraTrace = function (error) {\n          if (error.__stackCleaned__) return;\n          this.uncycle();\n          var parsed = CapturedTrace.parseStackAndMessage(error);\n          var message = parsed.message;\n          var stacks = [parsed.stack];\n          var trace = this;\n\n          while (trace !== undefined) {\n            stacks.push(cleanStack(trace.stack.split(\"\\n\")));\n            trace = trace._parent;\n          }\n\n          removeCommonRoots(stacks);\n          removeDuplicateOrEmptyJumps(stacks);\n          util.notEnumerableProp(error, \"stack\", reconstructStack(message, stacks));\n          util.notEnumerableProp(error, \"__stackCleaned__\", true);\n        };\n\n        function reconstructStack(message, stacks) {\n          for (var i = 0; i < stacks.length - 1; ++i) {\n            stacks[i].push(\"From previous event:\");\n            stacks[i] = stacks[i].join(\"\\n\");\n          }\n\n          if (i < stacks.length) {\n            stacks[i] = stacks[i].join(\"\\n\");\n          }\n\n          return message + \"\\n\" + stacks.join(\"\\n\");\n        }\n\n        function removeDuplicateOrEmptyJumps(stacks) {\n          for (var i = 0; i < stacks.length; ++i) {\n            if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {\n              stacks.splice(i, 1);\n              i--;\n            }\n          }\n        }\n\n        function removeCommonRoots(stacks) {\n          var current = stacks[0];\n\n          for (var i = 1; i < stacks.length; ++i) {\n            var prev = stacks[i];\n            var currentLastIndex = current.length - 1;\n            var currentLastLine = current[currentLastIndex];\n            var commonRootMeetPoint = -1;\n\n            for (var j = prev.length - 1; j >= 0; --j) {\n              if (prev[j] === currentLastLine) {\n                commonRootMeetPoint = j;\n                break;\n              }\n            }\n\n            for (var j = commonRootMeetPoint; j >= 0; --j) {\n              var line = prev[j];\n\n              if (current[currentLastIndex] === line) {\n                current.pop();\n                currentLastIndex--;\n              } else {\n                break;\n              }\n            }\n\n            current = prev;\n          }\n        }\n\n        function cleanStack(stack) {\n          var ret = [];\n\n          for (var i = 0; i < stack.length; ++i) {\n            var line = stack[i];\n            var isTraceLine = stackFramePattern.test(line) || \"    (No stack trace)\" === line;\n            var isInternalFrame = isTraceLine && shouldIgnore(line);\n\n            if (isTraceLine && !isInternalFrame) {\n              if (indentStackFrames && line.charAt(0) !== \" \") {\n                line = \"    \" + line;\n              }\n\n              ret.push(line);\n            }\n          }\n\n          return ret;\n        }\n\n        function stackFramesAsArray(error) {\n          var stack = error.stack.replace(/\\s+$/g, \"\").split(\"\\n\");\n\n          for (var i = 0; i < stack.length; ++i) {\n            var line = stack[i];\n\n            if (\"    (No stack trace)\" === line || stackFramePattern.test(line)) {\n              break;\n            }\n          }\n\n          if (i > 0) {\n            stack = stack.slice(i);\n          }\n\n          return stack;\n        }\n\n        CapturedTrace.parseStackAndMessage = function (error) {\n          var stack = error.stack;\n          var message = error.toString();\n          stack = typeof stack === \"string\" && stack.length > 0 ? stackFramesAsArray(error) : [\"    (No stack trace)\"];\n          return {\n            message: message,\n            stack: cleanStack(stack)\n          };\n        };\n\n        CapturedTrace.formatAndLogError = function (error, title) {\n          if (typeof console !== \"undefined\") {\n            var message;\n\n            if (typeof error === \"object\" || typeof error === \"function\") {\n              var stack = error.stack;\n              message = title + formatStack(stack, error);\n            } else {\n              message = title + String(error);\n            }\n\n            if (typeof warn === \"function\") {\n              warn(message);\n            } else if (typeof console.log === \"function\" || typeof console.log === \"object\") {\n              console.log(message);\n            }\n          }\n        };\n\n        CapturedTrace.unhandledRejection = function (reason) {\n          CapturedTrace.formatAndLogError(reason, \"^--- With additional stack trace: \");\n        };\n\n        CapturedTrace.isSupported = function () {\n          return typeof captureStackTrace === \"function\";\n        };\n\n        CapturedTrace.fireRejectionEvent = function (name, localHandler, reason, promise) {\n          var localEventFired = false;\n\n          try {\n            if (typeof localHandler === \"function\") {\n              localEventFired = true;\n\n              if (name === \"rejectionHandled\") {\n                localHandler(promise);\n              } else {\n                localHandler(reason, promise);\n              }\n            }\n          } catch (e) {\n            async.throwLater(e);\n          }\n\n          var globalEventFired = false;\n\n          try {\n            globalEventFired = fireGlobalEvent(name, reason, promise);\n          } catch (e) {\n            globalEventFired = true;\n            async.throwLater(e);\n          }\n\n          var domEventFired = false;\n\n          if (fireDomEvent) {\n            try {\n              domEventFired = fireDomEvent(name.toLowerCase(), {\n                reason: reason,\n                promise: promise\n              });\n            } catch (e) {\n              domEventFired = true;\n              async.throwLater(e);\n            }\n          }\n\n          if (!globalEventFired && !localEventFired && !domEventFired && name === \"unhandledRejection\") {\n            CapturedTrace.formatAndLogError(reason, \"Unhandled rejection \");\n          }\n        };\n\n        function formatNonError(obj) {\n          var str;\n\n          if (typeof obj === \"function\") {\n            str = \"[function \" + (obj.name || \"anonymous\") + \"]\";\n          } else {\n            str = obj.toString();\n            var ruselessToString = /\\[object [a-zA-Z0-9$_]+\\]/;\n\n            if (ruselessToString.test(str)) {\n              try {\n                var newStr = JSON.stringify(obj);\n                str = newStr;\n              } catch (e) {}\n            }\n\n            if (str.length === 0) {\n              str = \"(empty array)\";\n            }\n          }\n\n          return \"(<\" + snip(str) + \">, no stack trace)\";\n        }\n\n        function snip(str) {\n          var maxChars = 41;\n\n          if (str.length < maxChars) {\n            return str;\n          }\n\n          return str.substr(0, maxChars - 3) + \"...\";\n        }\n\n        var shouldIgnore = function () {\n          return false;\n        };\n\n        var parseLineInfoRegex = /[\\/<\\(]([^:\\/]+):(\\d+):(?:\\d+)\\)?\\s*$/;\n\n        function parseLineInfo(line) {\n          var matches = line.match(parseLineInfoRegex);\n\n          if (matches) {\n            return {\n              fileName: matches[1],\n              line: parseInt(matches[2], 10)\n            };\n          }\n        }\n\n        CapturedTrace.setBounds = function (firstLineError, lastLineError) {\n          if (!CapturedTrace.isSupported()) return;\n          var firstStackLines = firstLineError.stack.split(\"\\n\");\n          var lastStackLines = lastLineError.stack.split(\"\\n\");\n          var firstIndex = -1;\n          var lastIndex = -1;\n          var firstFileName;\n          var lastFileName;\n\n          for (var i = 0; i < firstStackLines.length; ++i) {\n            var result = parseLineInfo(firstStackLines[i]);\n\n            if (result) {\n              firstFileName = result.fileName;\n              firstIndex = result.line;\n              break;\n            }\n          }\n\n          for (var i = 0; i < lastStackLines.length; ++i) {\n            var result = parseLineInfo(lastStackLines[i]);\n\n            if (result) {\n              lastFileName = result.fileName;\n              lastIndex = result.line;\n              break;\n            }\n          }\n\n          if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {\n            return;\n          }\n\n          shouldIgnore = function (line) {\n            if (bluebirdFramePattern.test(line)) return true;\n            var info = parseLineInfo(line);\n\n            if (info) {\n              if (info.fileName === firstFileName && firstIndex <= info.line && info.line <= lastIndex) {\n                return true;\n              }\n            }\n\n            return false;\n          };\n        };\n\n        var captureStackTrace = function stackDetection() {\n          var v8stackFramePattern = /^\\s*at\\s*/;\n\n          var v8stackFormatter = function (stack, error) {\n            if (typeof stack === \"string\") return stack;\n\n            if (error.name !== undefined && error.message !== undefined) {\n              return error.toString();\n            }\n\n            return formatNonError(error);\n          };\n\n          if (typeof Error.stackTraceLimit === \"number\" && typeof Error.captureStackTrace === \"function\") {\n            Error.stackTraceLimit = Error.stackTraceLimit + 6;\n            stackFramePattern = v8stackFramePattern;\n            formatStack = v8stackFormatter;\n            var captureStackTrace = Error.captureStackTrace;\n\n            shouldIgnore = function (line) {\n              return bluebirdFramePattern.test(line);\n            };\n\n            return function (receiver, ignoreUntil) {\n              Error.stackTraceLimit = Error.stackTraceLimit + 6;\n              captureStackTrace(receiver, ignoreUntil);\n              Error.stackTraceLimit = Error.stackTraceLimit - 6;\n            };\n          }\n\n          var err = new Error();\n\n          if (typeof err.stack === \"string\" && err.stack.split(\"\\n\")[0].indexOf(\"stackDetection@\") >= 0) {\n            stackFramePattern = /@/;\n            formatStack = v8stackFormatter;\n            indentStackFrames = true;\n            return function captureStackTrace(o) {\n              o.stack = new Error().stack;\n            };\n          }\n\n          var hasStackAfterThrow;\n\n          try {\n            throw new Error();\n          } catch (e) {\n            hasStackAfterThrow = \"stack\" in e;\n          }\n\n          if (!(\"stack\" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === \"number\") {\n            stackFramePattern = v8stackFramePattern;\n            formatStack = v8stackFormatter;\n            return function captureStackTrace(o) {\n              Error.stackTraceLimit = Error.stackTraceLimit + 6;\n\n              try {\n                throw new Error();\n              } catch (e) {\n                o.stack = e.stack;\n              }\n\n              Error.stackTraceLimit = Error.stackTraceLimit - 6;\n            };\n          }\n\n          formatStack = function (stack, error) {\n            if (typeof stack === \"string\") return stack;\n\n            if ((typeof error === \"object\" || typeof error === \"function\") && error.name !== undefined && error.message !== undefined) {\n              return error.toString();\n            }\n\n            return formatNonError(error);\n          };\n\n          return null;\n        }([]);\n\n        var fireDomEvent;\n\n        var fireGlobalEvent = function () {\n          if (util.isNode) {\n            return function (name, reason, promise) {\n              if (name === \"rejectionHandled\") {\n                return process.emit(name, promise);\n              } else {\n                return process.emit(name, reason, promise);\n              }\n            };\n          } else {\n            var customEventWorks = false;\n            var anyEventWorks = true;\n\n            try {\n              var ev = new self.CustomEvent(\"test\");\n              customEventWorks = ev instanceof CustomEvent;\n            } catch (e) {}\n\n            if (!customEventWorks) {\n              try {\n                var event = document.createEvent(\"CustomEvent\");\n                event.initCustomEvent(\"testingtheevent\", false, true, {});\n                self.dispatchEvent(event);\n              } catch (e) {\n                anyEventWorks = false;\n              }\n            }\n\n            if (anyEventWorks) {\n              fireDomEvent = function (type, detail) {\n                var event;\n\n                if (customEventWorks) {\n                  event = new self.CustomEvent(type, {\n                    detail: detail,\n                    bubbles: false,\n                    cancelable: true\n                  });\n                } else if (self.dispatchEvent) {\n                  event = document.createEvent(\"CustomEvent\");\n                  event.initCustomEvent(type, false, true, detail);\n                }\n\n                return event ? !self.dispatchEvent(event) : false;\n              };\n            }\n\n            var toWindowMethodNameMap = {};\n            toWindowMethodNameMap[\"unhandledRejection\"] = (\"on\" + \"unhandledRejection\").toLowerCase();\n            toWindowMethodNameMap[\"rejectionHandled\"] = (\"on\" + \"rejectionHandled\").toLowerCase();\n            return function (name, reason, promise) {\n              var methodName = toWindowMethodNameMap[name];\n              var method = self[methodName];\n              if (!method) return false;\n\n              if (name === \"rejectionHandled\") {\n                method.call(self, promise);\n              } else {\n                method.call(self, reason, promise);\n              }\n\n              return true;\n            };\n          }\n        }();\n\n        if (typeof console !== \"undefined\" && typeof console.warn !== \"undefined\") {\n          warn = function (message) {\n            console.warn(message);\n          };\n\n          if (util.isNode && process.stderr.isTTY) {\n            warn = function (message) {\n              process.stderr.write(\"\\u001b[31m\" + message + \"\\u001b[39m\\n\");\n            };\n          } else if (!util.isNode && typeof new Error().stack === \"string\") {\n            warn = function (message) {\n              console.warn(\"%c\" + message, \"color: red\");\n            };\n          }\n        }\n\n        return CapturedTrace;\n      };\n    }, {\n      \"./async.js\": 2,\n      \"./util.js\": 38\n    }],\n    8: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (NEXT_FILTER) {\n        var util = _dereq_(\"./util.js\");\n\n        var errors = _dereq_(\"./errors.js\");\n\n        var tryCatch = util.tryCatch;\n        var errorObj = util.errorObj;\n\n        var keys = _dereq_(\"./es5.js\").keys;\n\n        var TypeError = errors.TypeError;\n\n        function CatchFilter(instances, callback, promise) {\n          this._instances = instances;\n          this._callback = callback;\n          this._promise = promise;\n        }\n\n        function safePredicate(predicate, e) {\n          var safeObject = {};\n          var retfilter = tryCatch(predicate).call(safeObject, e);\n          if (retfilter === errorObj) return retfilter;\n          var safeKeys = keys(safeObject);\n\n          if (safeKeys.length) {\n            errorObj.e = new TypeError(\"Catch filter must inherit from Error or be a simple predicate function\\u000a\\u000a    See http://goo.gl/o84o68\\u000a\");\n            return errorObj;\n          }\n\n          return retfilter;\n        }\n\n        CatchFilter.prototype.doFilter = function (e) {\n          var cb = this._callback;\n          var promise = this._promise;\n\n          var boundTo = promise._boundValue();\n\n          for (var i = 0, len = this._instances.length; i < len; ++i) {\n            var item = this._instances[i];\n            var itemIsErrorType = item === Error || item != null && item.prototype instanceof Error;\n\n            if (itemIsErrorType && e instanceof item) {\n              var ret = tryCatch(cb).call(boundTo, e);\n\n              if (ret === errorObj) {\n                NEXT_FILTER.e = ret.e;\n                return NEXT_FILTER;\n              }\n\n              return ret;\n            } else if (typeof item === \"function\" && !itemIsErrorType) {\n              var shouldHandle = safePredicate(item, e);\n\n              if (shouldHandle === errorObj) {\n                e = errorObj.e;\n                break;\n              } else if (shouldHandle) {\n                var ret = tryCatch(cb).call(boundTo, e);\n\n                if (ret === errorObj) {\n                  NEXT_FILTER.e = ret.e;\n                  return NEXT_FILTER;\n                }\n\n                return ret;\n              }\n            }\n          }\n\n          NEXT_FILTER.e = e;\n          return NEXT_FILTER;\n        };\n\n        return CatchFilter;\n      };\n    }, {\n      \"./errors.js\": 13,\n      \"./es5.js\": 14,\n      \"./util.js\": 38\n    }],\n    9: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise, CapturedTrace, isDebugging) {\n        var contextStack = [];\n\n        function Context() {\n          this._trace = new CapturedTrace(peekContext());\n        }\n\n        Context.prototype._pushContext = function () {\n          if (!isDebugging()) return;\n\n          if (this._trace !== undefined) {\n            contextStack.push(this._trace);\n          }\n        };\n\n        Context.prototype._popContext = function () {\n          if (!isDebugging()) return;\n\n          if (this._trace !== undefined) {\n            contextStack.pop();\n          }\n        };\n\n        function createContext() {\n          if (isDebugging()) return new Context();\n        }\n\n        function peekContext() {\n          var lastIndex = contextStack.length - 1;\n\n          if (lastIndex >= 0) {\n            return contextStack[lastIndex];\n          }\n\n          return undefined;\n        }\n\n        Promise.prototype._peekContext = peekContext;\n        Promise.prototype._pushContext = Context.prototype._pushContext;\n        Promise.prototype._popContext = Context.prototype._popContext;\n        return createContext;\n      };\n    }, {}],\n    10: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise, CapturedTrace) {\n        var getDomain = Promise._getDomain;\n\n        var async = _dereq_(\"./async.js\");\n\n        var Warning = _dereq_(\"./errors.js\").Warning;\n\n        var util = _dereq_(\"./util.js\");\n\n        var canAttachTrace = util.canAttachTrace;\n        var unhandledRejectionHandled;\n        var possiblyUnhandledRejection;\n        var debugging = false || util.isNode && (!!process.env[\"BLUEBIRD_DEBUG\"] || process.env[\"NODE_ENV\"] === \"development\");\n        if (util.isNode && process.env[\"BLUEBIRD_DEBUG\"] == 0) debugging = false;\n\n        if (debugging) {\n          async.disableTrampolineIfNecessary();\n        }\n\n        Promise.prototype._ignoreRejections = function () {\n          this._unsetRejectionIsUnhandled();\n\n          this._bitField = this._bitField | 16777216;\n        };\n\n        Promise.prototype._ensurePossibleRejectionHandled = function () {\n          if ((this._bitField & 16777216) !== 0) return;\n\n          this._setRejectionIsUnhandled();\n\n          async.invokeLater(this._notifyUnhandledRejection, this, undefined);\n        };\n\n        Promise.prototype._notifyUnhandledRejectionIsHandled = function () {\n          CapturedTrace.fireRejectionEvent(\"rejectionHandled\", unhandledRejectionHandled, undefined, this);\n        };\n\n        Promise.prototype._notifyUnhandledRejection = function () {\n          if (this._isRejectionUnhandled()) {\n            var reason = this._getCarriedStackTrace() || this._settledValue;\n\n            this._setUnhandledRejectionIsNotified();\n\n            CapturedTrace.fireRejectionEvent(\"unhandledRejection\", possiblyUnhandledRejection, reason, this);\n          }\n        };\n\n        Promise.prototype._setUnhandledRejectionIsNotified = function () {\n          this._bitField = this._bitField | 524288;\n        };\n\n        Promise.prototype._unsetUnhandledRejectionIsNotified = function () {\n          this._bitField = this._bitField & ~524288;\n        };\n\n        Promise.prototype._isUnhandledRejectionNotified = function () {\n          return (this._bitField & 524288) > 0;\n        };\n\n        Promise.prototype._setRejectionIsUnhandled = function () {\n          this._bitField = this._bitField | 2097152;\n        };\n\n        Promise.prototype._unsetRejectionIsUnhandled = function () {\n          this._bitField = this._bitField & ~2097152;\n\n          if (this._isUnhandledRejectionNotified()) {\n            this._unsetUnhandledRejectionIsNotified();\n\n            this._notifyUnhandledRejectionIsHandled();\n          }\n        };\n\n        Promise.prototype._isRejectionUnhandled = function () {\n          return (this._bitField & 2097152) > 0;\n        };\n\n        Promise.prototype._setCarriedStackTrace = function (capturedTrace) {\n          this._bitField = this._bitField | 1048576;\n          this._fulfillmentHandler0 = capturedTrace;\n        };\n\n        Promise.prototype._isCarryingStackTrace = function () {\n          return (this._bitField & 1048576) > 0;\n        };\n\n        Promise.prototype._getCarriedStackTrace = function () {\n          return this._isCarryingStackTrace() ? this._fulfillmentHandler0 : undefined;\n        };\n\n        Promise.prototype._captureStackTrace = function () {\n          if (debugging) {\n            this._trace = new CapturedTrace(this._peekContext());\n          }\n\n          return this;\n        };\n\n        Promise.prototype._attachExtraTrace = function (error, ignoreSelf) {\n          if (debugging && canAttachTrace(error)) {\n            var trace = this._trace;\n\n            if (trace !== undefined) {\n              if (ignoreSelf) trace = trace._parent;\n            }\n\n            if (trace !== undefined) {\n              trace.attachExtraTrace(error);\n            } else if (!error.__stackCleaned__) {\n              var parsed = CapturedTrace.parseStackAndMessage(error);\n              util.notEnumerableProp(error, \"stack\", parsed.message + \"\\n\" + parsed.stack.join(\"\\n\"));\n              util.notEnumerableProp(error, \"__stackCleaned__\", true);\n            }\n          }\n        };\n\n        Promise.prototype._warn = function (message) {\n          var warning = new Warning(message);\n\n          var ctx = this._peekContext();\n\n          if (ctx) {\n            ctx.attachExtraTrace(warning);\n          } else {\n            var parsed = CapturedTrace.parseStackAndMessage(warning);\n            warning.stack = parsed.message + \"\\n\" + parsed.stack.join(\"\\n\");\n          }\n\n          CapturedTrace.formatAndLogError(warning, \"\");\n        };\n\n        Promise.onPossiblyUnhandledRejection = function (fn) {\n          var domain = getDomain();\n          possiblyUnhandledRejection = typeof fn === \"function\" ? domain === null ? fn : domain.bind(fn) : undefined;\n        };\n\n        Promise.onUnhandledRejectionHandled = function (fn) {\n          var domain = getDomain();\n          unhandledRejectionHandled = typeof fn === \"function\" ? domain === null ? fn : domain.bind(fn) : undefined;\n        };\n\n        Promise.longStackTraces = function () {\n          if (async.haveItemsQueued() && debugging === false) {\n            throw new Error(\"cannot enable long stack traces after promises have been created\\u000a\\u000a    See http://goo.gl/DT1qyG\\u000a\");\n          }\n\n          debugging = CapturedTrace.isSupported();\n\n          if (debugging) {\n            async.disableTrampolineIfNecessary();\n          }\n        };\n\n        Promise.hasLongStackTraces = function () {\n          return debugging && CapturedTrace.isSupported();\n        };\n\n        if (!CapturedTrace.isSupported()) {\n          Promise.longStackTraces = function () {};\n\n          debugging = false;\n        }\n\n        return function () {\n          return debugging;\n        };\n      };\n    }, {\n      \"./async.js\": 2,\n      \"./errors.js\": 13,\n      \"./util.js\": 38\n    }],\n    11: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      var util = _dereq_(\"./util.js\");\n\n      var isPrimitive = util.isPrimitive;\n\n      module.exports = function (Promise) {\n        var returner = function () {\n          return this;\n        };\n\n        var thrower = function () {\n          throw this;\n        };\n\n        var returnUndefined = function () {};\n\n        var throwUndefined = function () {\n          throw undefined;\n        };\n\n        var wrapper = function (value, action) {\n          if (action === 1) {\n            return function () {\n              throw value;\n            };\n          } else if (action === 2) {\n            return function () {\n              return value;\n            };\n          }\n        };\n\n        Promise.prototype[\"return\"] = Promise.prototype.thenReturn = function (value) {\n          if (value === undefined) return this.then(returnUndefined);\n\n          if (isPrimitive(value)) {\n            return this._then(wrapper(value, 2), undefined, undefined, undefined, undefined);\n          } else if (value instanceof Promise) {\n            value._ignoreRejections();\n          }\n\n          return this._then(returner, undefined, undefined, value, undefined);\n        };\n\n        Promise.prototype[\"throw\"] = Promise.prototype.thenThrow = function (reason) {\n          if (reason === undefined) return this.then(throwUndefined);\n\n          if (isPrimitive(reason)) {\n            return this._then(wrapper(reason, 1), undefined, undefined, undefined, undefined);\n          }\n\n          return this._then(thrower, undefined, undefined, reason, undefined);\n        };\n      };\n    }, {\n      \"./util.js\": 38\n    }],\n    12: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise, INTERNAL) {\n        var PromiseReduce = Promise.reduce;\n\n        Promise.prototype.each = function (fn) {\n          return PromiseReduce(this, fn, null, INTERNAL);\n        };\n\n        Promise.each = function (promises, fn) {\n          return PromiseReduce(promises, fn, null, INTERNAL);\n        };\n      };\n    }, {}],\n    13: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      var es5 = _dereq_(\"./es5.js\");\n\n      var Objectfreeze = es5.freeze;\n\n      var util = _dereq_(\"./util.js\");\n\n      var inherits = util.inherits;\n      var notEnumerableProp = util.notEnumerableProp;\n\n      function subError(nameProperty, defaultMessage) {\n        function SubError(message) {\n          if (!(this instanceof SubError)) return new SubError(message);\n          notEnumerableProp(this, \"message\", typeof message === \"string\" ? message : defaultMessage);\n          notEnumerableProp(this, \"name\", nameProperty);\n\n          if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n          } else {\n            Error.call(this);\n          }\n        }\n\n        inherits(SubError, Error);\n        return SubError;\n      }\n\n      var _TypeError, _RangeError;\n\n      var Warning = subError(\"Warning\", \"warning\");\n      var CancellationError = subError(\"CancellationError\", \"cancellation error\");\n      var TimeoutError = subError(\"TimeoutError\", \"timeout error\");\n      var AggregateError = subError(\"AggregateError\", \"aggregate error\");\n\n      try {\n        _TypeError = TypeError;\n        _RangeError = RangeError;\n      } catch (e) {\n        _TypeError = subError(\"TypeError\", \"type error\");\n        _RangeError = subError(\"RangeError\", \"range error\");\n      }\n\n      var methods = (\"join pop push shift unshift slice filter forEach some \" + \"every map indexOf lastIndexOf reduce reduceRight sort reverse\").split(\" \");\n\n      for (var i = 0; i < methods.length; ++i) {\n        if (typeof Array.prototype[methods[i]] === \"function\") {\n          AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];\n        }\n      }\n\n      es5.defineProperty(AggregateError.prototype, \"length\", {\n        value: 0,\n        configurable: false,\n        writable: true,\n        enumerable: true\n      });\n      AggregateError.prototype[\"isOperational\"] = true;\n      var level = 0;\n\n      AggregateError.prototype.toString = function () {\n        var indent = Array(level * 4 + 1).join(\" \");\n        var ret = \"\\n\" + indent + \"AggregateError of:\" + \"\\n\";\n        level++;\n        indent = Array(level * 4 + 1).join(\" \");\n\n        for (var i = 0; i < this.length; ++i) {\n          var str = this[i] === this ? \"[Circular AggregateError]\" : this[i] + \"\";\n          var lines = str.split(\"\\n\");\n\n          for (var j = 0; j < lines.length; ++j) {\n            lines[j] = indent + lines[j];\n          }\n\n          str = lines.join(\"\\n\");\n          ret += str + \"\\n\";\n        }\n\n        level--;\n        return ret;\n      };\n\n      function OperationalError(message) {\n        if (!(this instanceof OperationalError)) return new OperationalError(message);\n        notEnumerableProp(this, \"name\", \"OperationalError\");\n        notEnumerableProp(this, \"message\", message);\n        this.cause = message;\n        this[\"isOperational\"] = true;\n\n        if (message instanceof Error) {\n          notEnumerableProp(this, \"message\", message.message);\n          notEnumerableProp(this, \"stack\", message.stack);\n        } else if (Error.captureStackTrace) {\n          Error.captureStackTrace(this, this.constructor);\n        }\n      }\n\n      inherits(OperationalError, Error);\n      var errorTypes = Error[\"__BluebirdErrorTypes__\"];\n\n      if (!errorTypes) {\n        errorTypes = Objectfreeze({\n          CancellationError: CancellationError,\n          TimeoutError: TimeoutError,\n          OperationalError: OperationalError,\n          RejectionError: OperationalError,\n          AggregateError: AggregateError\n        });\n        notEnumerableProp(Error, \"__BluebirdErrorTypes__\", errorTypes);\n      }\n\n      module.exports = {\n        Error: Error,\n        TypeError: _TypeError,\n        RangeError: _RangeError,\n        CancellationError: errorTypes.CancellationError,\n        OperationalError: errorTypes.OperationalError,\n        TimeoutError: errorTypes.TimeoutError,\n        AggregateError: errorTypes.AggregateError,\n        Warning: Warning\n      };\n    }, {\n      \"./es5.js\": 14,\n      \"./util.js\": 38\n    }],\n    14: [function (_dereq_, module, exports) {\n      var isES5 = function () {\n        \"use strict\";\n\n        return this === undefined;\n      }();\n\n      if (isES5) {\n        module.exports = {\n          freeze: Object.freeze,\n          defineProperty: Object.defineProperty,\n          getDescriptor: Object.getOwnPropertyDescriptor,\n          keys: Object.keys,\n          names: Object.getOwnPropertyNames,\n          getPrototypeOf: Object.getPrototypeOf,\n          isArray: Array.isArray,\n          isES5: isES5,\n          propertyIsWritable: function (obj, prop) {\n            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);\n            return !!(!descriptor || descriptor.writable || descriptor.set);\n          }\n        };\n      } else {\n        var has = {}.hasOwnProperty;\n        var str = {}.toString;\n        var proto = {}.constructor.prototype;\n\n        var ObjectKeys = function (o) {\n          var ret = [];\n\n          for (var key in o) {\n            if (has.call(o, key)) {\n              ret.push(key);\n            }\n          }\n\n          return ret;\n        };\n\n        var ObjectGetDescriptor = function (o, key) {\n          return {\n            value: o[key]\n          };\n        };\n\n        var ObjectDefineProperty = function (o, key, desc) {\n          o[key] = desc.value;\n          return o;\n        };\n\n        var ObjectFreeze = function (obj) {\n          return obj;\n        };\n\n        var ObjectGetPrototypeOf = function (obj) {\n          try {\n            return Object(obj).constructor.prototype;\n          } catch (e) {\n            return proto;\n          }\n        };\n\n        var ArrayIsArray = function (obj) {\n          try {\n            return str.call(obj) === \"[object Array]\";\n          } catch (e) {\n            return false;\n          }\n        };\n\n        module.exports = {\n          isArray: ArrayIsArray,\n          keys: ObjectKeys,\n          names: ObjectKeys,\n          defineProperty: ObjectDefineProperty,\n          getDescriptor: ObjectGetDescriptor,\n          freeze: ObjectFreeze,\n          getPrototypeOf: ObjectGetPrototypeOf,\n          isES5: isES5,\n          propertyIsWritable: function () {\n            return true;\n          }\n        };\n      }\n    }, {}],\n    15: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise, INTERNAL) {\n        var PromiseMap = Promise.map;\n\n        Promise.prototype.filter = function (fn, options) {\n          return PromiseMap(this, fn, options, INTERNAL);\n        };\n\n        Promise.filter = function (promises, fn, options) {\n          return PromiseMap(promises, fn, options, INTERNAL);\n        };\n      };\n    }, {}],\n    16: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise, NEXT_FILTER, tryConvertToPromise) {\n        var util = _dereq_(\"./util.js\");\n\n        var isPrimitive = util.isPrimitive;\n        var thrower = util.thrower;\n\n        function returnThis() {\n          return this;\n        }\n\n        function throwThis() {\n          throw this;\n        }\n\n        function return$(r) {\n          return function () {\n            return r;\n          };\n        }\n\n        function throw$(r) {\n          return function () {\n            throw r;\n          };\n        }\n\n        function promisedFinally(ret, reasonOrValue, isFulfilled) {\n          var then;\n\n          if (isPrimitive(reasonOrValue)) {\n            then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);\n          } else {\n            then = isFulfilled ? returnThis : throwThis;\n          }\n\n          return ret._then(then, thrower, undefined, reasonOrValue, undefined);\n        }\n\n        function finallyHandler(reasonOrValue) {\n          var promise = this.promise;\n          var handler = this.handler;\n          var ret = promise._isBound() ? handler.call(promise._boundValue()) : handler();\n\n          if (ret !== undefined) {\n            var maybePromise = tryConvertToPromise(ret, promise);\n\n            if (maybePromise instanceof Promise) {\n              maybePromise = maybePromise._target();\n              return promisedFinally(maybePromise, reasonOrValue, promise.isFulfilled());\n            }\n          }\n\n          if (promise.isRejected()) {\n            NEXT_FILTER.e = reasonOrValue;\n            return NEXT_FILTER;\n          } else {\n            return reasonOrValue;\n          }\n        }\n\n        function tapHandler(value) {\n          var promise = this.promise;\n          var handler = this.handler;\n          var ret = promise._isBound() ? handler.call(promise._boundValue(), value) : handler(value);\n\n          if (ret !== undefined) {\n            var maybePromise = tryConvertToPromise(ret, promise);\n\n            if (maybePromise instanceof Promise) {\n              maybePromise = maybePromise._target();\n              return promisedFinally(maybePromise, value, true);\n            }\n          }\n\n          return value;\n        }\n\n        Promise.prototype._passThroughHandler = function (handler, isFinally) {\n          if (typeof handler !== \"function\") return this.then();\n          var promiseAndHandler = {\n            promise: this,\n            handler: handler\n          };\n          return this._then(isFinally ? finallyHandler : tapHandler, isFinally ? finallyHandler : undefined, undefined, promiseAndHandler, undefined);\n        };\n\n        Promise.prototype.lastly = Promise.prototype[\"finally\"] = function (handler) {\n          return this._passThroughHandler(handler, true);\n        };\n\n        Promise.prototype.tap = function (handler) {\n          return this._passThroughHandler(handler, false);\n        };\n      };\n    }, {\n      \"./util.js\": 38\n    }],\n    17: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise, apiRejection, INTERNAL, tryConvertToPromise) {\n        var errors = _dereq_(\"./errors.js\");\n\n        var TypeError = errors.TypeError;\n\n        var util = _dereq_(\"./util.js\");\n\n        var errorObj = util.errorObj;\n        var tryCatch = util.tryCatch;\n        var yieldHandlers = [];\n\n        function promiseFromYieldHandler(value, yieldHandlers, traceParent) {\n          for (var i = 0; i < yieldHandlers.length; ++i) {\n            traceParent._pushContext();\n\n            var result = tryCatch(yieldHandlers[i])(value);\n\n            traceParent._popContext();\n\n            if (result === errorObj) {\n              traceParent._pushContext();\n\n              var ret = Promise.reject(errorObj.e);\n\n              traceParent._popContext();\n\n              return ret;\n            }\n\n            var maybePromise = tryConvertToPromise(result, traceParent);\n            if (maybePromise instanceof Promise) return maybePromise;\n          }\n\n          return null;\n        }\n\n        function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {\n          var promise = this._promise = new Promise(INTERNAL);\n\n          promise._captureStackTrace();\n\n          this._stack = stack;\n          this._generatorFunction = generatorFunction;\n          this._receiver = receiver;\n          this._generator = undefined;\n          this._yieldHandlers = typeof yieldHandler === \"function\" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;\n        }\n\n        PromiseSpawn.prototype.promise = function () {\n          return this._promise;\n        };\n\n        PromiseSpawn.prototype._run = function () {\n          this._generator = this._generatorFunction.call(this._receiver);\n          this._receiver = this._generatorFunction = undefined;\n\n          this._next(undefined);\n        };\n\n        PromiseSpawn.prototype._continue = function (result) {\n          if (result === errorObj) {\n            return this._promise._rejectCallback(result.e, false, true);\n          }\n\n          var value = result.value;\n\n          if (result.done === true) {\n            this._promise._resolveCallback(value);\n          } else {\n            var maybePromise = tryConvertToPromise(value, this._promise);\n\n            if (!(maybePromise instanceof Promise)) {\n              maybePromise = promiseFromYieldHandler(maybePromise, this._yieldHandlers, this._promise);\n\n              if (maybePromise === null) {\n                this._throw(new TypeError(\"A value %s was yielded that could not be treated as a promise\\u000a\\u000a    See http://goo.gl/4Y4pDk\\u000a\\u000a\".replace(\"%s\", value) + \"From coroutine:\\u000a\" + this._stack.split(\"\\n\").slice(1, -7).join(\"\\n\")));\n\n                return;\n              }\n            }\n\n            maybePromise._then(this._next, this._throw, undefined, this, null);\n          }\n        };\n\n        PromiseSpawn.prototype._throw = function (reason) {\n          this._promise._attachExtraTrace(reason);\n\n          this._promise._pushContext();\n\n          var result = tryCatch(this._generator[\"throw\"]).call(this._generator, reason);\n\n          this._promise._popContext();\n\n          this._continue(result);\n        };\n\n        PromiseSpawn.prototype._next = function (value) {\n          this._promise._pushContext();\n\n          var result = tryCatch(this._generator.next).call(this._generator, value);\n\n          this._promise._popContext();\n\n          this._continue(result);\n        };\n\n        Promise.coroutine = function (generatorFunction, options) {\n          if (typeof generatorFunction !== \"function\") {\n            throw new TypeError(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/6Vqhm0\\u000a\");\n          }\n\n          var yieldHandler = Object(options).yieldHandler;\n          var PromiseSpawn$ = PromiseSpawn;\n          var stack = new Error().stack;\n          return function () {\n            var generator = generatorFunction.apply(this, arguments);\n            var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler, stack);\n            spawn._generator = generator;\n\n            spawn._next(undefined);\n\n            return spawn.promise();\n          };\n        };\n\n        Promise.coroutine.addYieldHandler = function (fn) {\n          if (typeof fn !== \"function\") throw new TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n          yieldHandlers.push(fn);\n        };\n\n        Promise.spawn = function (generatorFunction) {\n          if (typeof generatorFunction !== \"function\") {\n            return apiRejection(\"generatorFunction must be a function\\u000a\\u000a    See http://goo.gl/6Vqhm0\\u000a\");\n          }\n\n          var spawn = new PromiseSpawn(generatorFunction, this);\n          var ret = spawn.promise();\n\n          spawn._run(Promise.spawn);\n\n          return ret;\n        };\n      };\n    }, {\n      \"./errors.js\": 13,\n      \"./util.js\": 38\n    }],\n    18: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise, PromiseArray, tryConvertToPromise, INTERNAL) {\n        var util = _dereq_(\"./util.js\");\n\n        var canEvaluate = util.canEvaluate;\n        var tryCatch = util.tryCatch;\n        var errorObj = util.errorObj;\n        var reject;\n\n        if (!true) {\n          if (canEvaluate) {\n            var thenCallback = function (i) {\n              return new Function(\"value\", \"holder\", \"                             \\n\\\n            'use strict';                                                    \\n\\\n            holder.pIndex = value;                                           \\n\\\n            holder.checkFulfillment(this);                                   \\n\\\n            \".replace(/Index/g, i));\n            };\n\n            var caller = function (count) {\n              var values = [];\n\n              for (var i = 1; i <= count; ++i) values.push(\"holder.p\" + i);\n\n              return new Function(\"holder\", \"                                      \\n\\\n            'use strict';                                                    \\n\\\n            var callback = holder.fn;                                        \\n\\\n            return callback(values);                                         \\n\\\n            \".replace(/values/g, values.join(\", \")));\n            };\n\n            var thenCallbacks = [];\n            var callers = [undefined];\n\n            for (var i = 1; i <= 5; ++i) {\n              thenCallbacks.push(thenCallback(i));\n              callers.push(caller(i));\n            }\n\n            var Holder = function (total, fn) {\n              this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;\n              this.fn = fn;\n              this.total = total;\n              this.now = 0;\n            };\n\n            Holder.prototype.callers = callers;\n\n            Holder.prototype.checkFulfillment = function (promise) {\n              var now = this.now;\n              now++;\n              var total = this.total;\n\n              if (now >= total) {\n                var handler = this.callers[total];\n\n                promise._pushContext();\n\n                var ret = tryCatch(handler)(this);\n\n                promise._popContext();\n\n                if (ret === errorObj) {\n                  promise._rejectCallback(ret.e, false, true);\n                } else {\n                  promise._resolveCallback(ret);\n                }\n              } else {\n                this.now = now;\n              }\n            };\n\n            var reject = function (reason) {\n              this._reject(reason);\n            };\n          }\n        }\n\n        Promise.join = function () {\n          var last = arguments.length - 1;\n          var fn;\n\n          if (last > 0 && typeof arguments[last] === \"function\") {\n            fn = arguments[last];\n\n            if (!true) {\n              if (last < 6 && canEvaluate) {\n                var ret = new Promise(INTERNAL);\n\n                ret._captureStackTrace();\n\n                var holder = new Holder(last, fn);\n                var callbacks = thenCallbacks;\n\n                for (var i = 0; i < last; ++i) {\n                  var maybePromise = tryConvertToPromise(arguments[i], ret);\n\n                  if (maybePromise instanceof Promise) {\n                    maybePromise = maybePromise._target();\n\n                    if (maybePromise._isPending()) {\n                      maybePromise._then(callbacks[i], reject, undefined, ret, holder);\n                    } else if (maybePromise._isFulfilled()) {\n                      callbacks[i].call(ret, maybePromise._value(), holder);\n                    } else {\n                      ret._reject(maybePromise._reason());\n                    }\n                  } else {\n                    callbacks[i].call(ret, maybePromise, holder);\n                  }\n                }\n\n                return ret;\n              }\n            }\n          }\n\n          var $_len = arguments.length;\n          var args = new Array($_len);\n\n          for (var $_i = 0; $_i < $_len; ++$_i) {\n            args[$_i] = arguments[$_i];\n          }\n\n          if (fn) args.pop();\n          var ret = new PromiseArray(args).promise();\n          return fn !== undefined ? ret.spread(fn) : ret;\n        };\n      };\n    }, {\n      \"./util.js\": 38\n    }],\n    19: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL) {\n        var getDomain = Promise._getDomain;\n\n        var async = _dereq_(\"./async.js\");\n\n        var util = _dereq_(\"./util.js\");\n\n        var tryCatch = util.tryCatch;\n        var errorObj = util.errorObj;\n        var PENDING = {};\n        var EMPTY_ARRAY = [];\n\n        function MappingPromiseArray(promises, fn, limit, _filter) {\n          this.constructor$(promises);\n\n          this._promise._captureStackTrace();\n\n          var domain = getDomain();\n          this._callback = domain === null ? fn : domain.bind(fn);\n          this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;\n          this._limit = limit;\n          this._inFlight = 0;\n          this._queue = limit >= 1 ? [] : EMPTY_ARRAY;\n          async.invoke(init, this, undefined);\n        }\n\n        util.inherits(MappingPromiseArray, PromiseArray);\n\n        function init() {\n          this._init$(undefined, -2);\n        }\n\n        MappingPromiseArray.prototype._init = function () {};\n\n        MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {\n          var values = this._values;\n          var length = this.length();\n          var preservedValues = this._preservedValues;\n          var limit = this._limit;\n\n          if (values[index] === PENDING) {\n            values[index] = value;\n\n            if (limit >= 1) {\n              this._inFlight--;\n\n              this._drainQueue();\n\n              if (this._isResolved()) return;\n            }\n          } else {\n            if (limit >= 1 && this._inFlight >= limit) {\n              values[index] = value;\n\n              this._queue.push(index);\n\n              return;\n            }\n\n            if (preservedValues !== null) preservedValues[index] = value;\n            var callback = this._callback;\n\n            var receiver = this._promise._boundValue();\n\n            this._promise._pushContext();\n\n            var ret = tryCatch(callback).call(receiver, value, index, length);\n\n            this._promise._popContext();\n\n            if (ret === errorObj) return this._reject(ret.e);\n            var maybePromise = tryConvertToPromise(ret, this._promise);\n\n            if (maybePromise instanceof Promise) {\n              maybePromise = maybePromise._target();\n\n              if (maybePromise._isPending()) {\n                if (limit >= 1) this._inFlight++;\n                values[index] = PENDING;\n                return maybePromise._proxyPromiseArray(this, index);\n              } else if (maybePromise._isFulfilled()) {\n                ret = maybePromise._value();\n              } else {\n                return this._reject(maybePromise._reason());\n              }\n            }\n\n            values[index] = ret;\n          }\n\n          var totalResolved = ++this._totalResolved;\n\n          if (totalResolved >= length) {\n            if (preservedValues !== null) {\n              this._filter(values, preservedValues);\n            } else {\n              this._resolve(values);\n            }\n          }\n        };\n\n        MappingPromiseArray.prototype._drainQueue = function () {\n          var queue = this._queue;\n          var limit = this._limit;\n          var values = this._values;\n\n          while (queue.length > 0 && this._inFlight < limit) {\n            if (this._isResolved()) return;\n            var index = queue.pop();\n\n            this._promiseFulfilled(values[index], index);\n          }\n        };\n\n        MappingPromiseArray.prototype._filter = function (booleans, values) {\n          var len = values.length;\n          var ret = new Array(len);\n          var j = 0;\n\n          for (var i = 0; i < len; ++i) {\n            if (booleans[i]) ret[j++] = values[i];\n          }\n\n          ret.length = j;\n\n          this._resolve(ret);\n        };\n\n        MappingPromiseArray.prototype.preservedValues = function () {\n          return this._preservedValues;\n        };\n\n        function map(promises, fn, options, _filter) {\n          var limit = typeof options === \"object\" && options !== null ? options.concurrency : 0;\n          limit = typeof limit === \"number\" && isFinite(limit) && limit >= 1 ? limit : 0;\n          return new MappingPromiseArray(promises, fn, limit, _filter);\n        }\n\n        Promise.prototype.map = function (fn, options) {\n          if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n          return map(this, fn, options, null).promise();\n        };\n\n        Promise.map = function (promises, fn, options, _filter) {\n          if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n          return map(promises, fn, options, _filter).promise();\n        };\n      };\n    }, {\n      \"./async.js\": 2,\n      \"./util.js\": 38\n    }],\n    20: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection) {\n        var util = _dereq_(\"./util.js\");\n\n        var tryCatch = util.tryCatch;\n\n        Promise.method = function (fn) {\n          if (typeof fn !== \"function\") {\n            throw new Promise.TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n          }\n\n          return function () {\n            var ret = new Promise(INTERNAL);\n\n            ret._captureStackTrace();\n\n            ret._pushContext();\n\n            var value = tryCatch(fn).apply(this, arguments);\n\n            ret._popContext();\n\n            ret._resolveFromSyncValue(value);\n\n            return ret;\n          };\n        };\n\n        Promise.attempt = Promise[\"try\"] = function (fn, args, ctx) {\n          if (typeof fn !== \"function\") {\n            return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n          }\n\n          var ret = new Promise(INTERNAL);\n\n          ret._captureStackTrace();\n\n          ret._pushContext();\n\n          var value = util.isArray(args) ? tryCatch(fn).apply(ctx, args) : tryCatch(fn).call(ctx, args);\n\n          ret._popContext();\n\n          ret._resolveFromSyncValue(value);\n\n          return ret;\n        };\n\n        Promise.prototype._resolveFromSyncValue = function (value) {\n          if (value === util.errorObj) {\n            this._rejectCallback(value.e, false, true);\n          } else {\n            this._resolveCallback(value, true);\n          }\n        };\n      };\n    }, {\n      \"./util.js\": 38\n    }],\n    21: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise) {\n        var util = _dereq_(\"./util.js\");\n\n        var async = _dereq_(\"./async.js\");\n\n        var tryCatch = util.tryCatch;\n        var errorObj = util.errorObj;\n\n        function spreadAdapter(val, nodeback) {\n          var promise = this;\n          if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);\n          var ret = tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));\n\n          if (ret === errorObj) {\n            async.throwLater(ret.e);\n          }\n        }\n\n        function successAdapter(val, nodeback) {\n          var promise = this;\n\n          var receiver = promise._boundValue();\n\n          var ret = val === undefined ? tryCatch(nodeback).call(receiver, null) : tryCatch(nodeback).call(receiver, null, val);\n\n          if (ret === errorObj) {\n            async.throwLater(ret.e);\n          }\n        }\n\n        function errorAdapter(reason, nodeback) {\n          var promise = this;\n\n          if (!reason) {\n            var target = promise._target();\n\n            var newReason = target._getCarriedStackTrace();\n\n            newReason.cause = reason;\n            reason = newReason;\n          }\n\n          var ret = tryCatch(nodeback).call(promise._boundValue(), reason);\n\n          if (ret === errorObj) {\n            async.throwLater(ret.e);\n          }\n        }\n\n        Promise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback, options) {\n          if (typeof nodeback == \"function\") {\n            var adapter = successAdapter;\n\n            if (options !== undefined && Object(options).spread) {\n              adapter = spreadAdapter;\n            }\n\n            this._then(adapter, errorAdapter, undefined, this, nodeback);\n          }\n\n          return this;\n        };\n      };\n    }, {\n      \"./async.js\": 2,\n      \"./util.js\": 38\n    }],\n    22: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise, PromiseArray) {\n        var util = _dereq_(\"./util.js\");\n\n        var async = _dereq_(\"./async.js\");\n\n        var tryCatch = util.tryCatch;\n        var errorObj = util.errorObj;\n\n        Promise.prototype.progressed = function (handler) {\n          return this._then(undefined, undefined, handler, undefined, undefined);\n        };\n\n        Promise.prototype._progress = function (progressValue) {\n          if (this._isFollowingOrFulfilledOrRejected()) return;\n\n          this._target()._progressUnchecked(progressValue);\n        };\n\n        Promise.prototype._progressHandlerAt = function (index) {\n          return index === 0 ? this._progressHandler0 : this[(index << 2) + index - 5 + 2];\n        };\n\n        Promise.prototype._doProgressWith = function (progression) {\n          var progressValue = progression.value;\n          var handler = progression.handler;\n          var promise = progression.promise;\n          var receiver = progression.receiver;\n          var ret = tryCatch(handler).call(receiver, progressValue);\n\n          if (ret === errorObj) {\n            if (ret.e != null && ret.e.name !== \"StopProgressPropagation\") {\n              var trace = util.canAttachTrace(ret.e) ? ret.e : new Error(util.toString(ret.e));\n\n              promise._attachExtraTrace(trace);\n\n              promise._progress(ret.e);\n            }\n          } else if (ret instanceof Promise) {\n            ret._then(promise._progress, null, null, promise, undefined);\n          } else {\n            promise._progress(ret);\n          }\n        };\n\n        Promise.prototype._progressUnchecked = function (progressValue) {\n          var len = this._length();\n\n          var progress = this._progress;\n\n          for (var i = 0; i < len; i++) {\n            var handler = this._progressHandlerAt(i);\n\n            var promise = this._promiseAt(i);\n\n            if (!(promise instanceof Promise)) {\n              var receiver = this._receiverAt(i);\n\n              if (typeof handler === \"function\") {\n                handler.call(receiver, progressValue, promise);\n              } else if (receiver instanceof PromiseArray && !receiver._isResolved()) {\n                receiver._promiseProgressed(progressValue, promise);\n              }\n\n              continue;\n            }\n\n            if (typeof handler === \"function\") {\n              async.invoke(this._doProgressWith, this, {\n                handler: handler,\n                promise: promise,\n                receiver: this._receiverAt(i),\n                value: progressValue\n              });\n            } else {\n              async.invoke(progress, promise, progressValue);\n            }\n          }\n        };\n      };\n    }, {\n      \"./async.js\": 2,\n      \"./util.js\": 38\n    }],\n    23: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function () {\n        var makeSelfResolutionError = function () {\n          return new TypeError(\"circular promise resolution chain\\u000a\\u000a    See http://goo.gl/LhFpo0\\u000a\");\n        };\n\n        var reflect = function () {\n          return new Promise.PromiseInspection(this._target());\n        };\n\n        var apiRejection = function (msg) {\n          return Promise.reject(new TypeError(msg));\n        };\n\n        var util = _dereq_(\"./util.js\");\n\n        var getDomain;\n\n        if (util.isNode) {\n          getDomain = function () {\n            var ret = process.domain;\n            if (ret === undefined) ret = null;\n            return ret;\n          };\n        } else {\n          getDomain = function () {\n            return null;\n          };\n        }\n\n        util.notEnumerableProp(Promise, \"_getDomain\", getDomain);\n        var UNDEFINED_BINDING = {};\n\n        var async = _dereq_(\"./async.js\");\n\n        var errors = _dereq_(\"./errors.js\");\n\n        var TypeError = Promise.TypeError = errors.TypeError;\n        Promise.RangeError = errors.RangeError;\n        Promise.CancellationError = errors.CancellationError;\n        Promise.TimeoutError = errors.TimeoutError;\n        Promise.OperationalError = errors.OperationalError;\n        Promise.RejectionError = errors.OperationalError;\n        Promise.AggregateError = errors.AggregateError;\n\n        var INTERNAL = function () {};\n\n        var APPLY = {};\n        var NEXT_FILTER = {\n          e: null\n        };\n\n        var tryConvertToPromise = _dereq_(\"./thenables.js\")(Promise, INTERNAL);\n\n        var PromiseArray = _dereq_(\"./promise_array.js\")(Promise, INTERNAL, tryConvertToPromise, apiRejection);\n\n        var CapturedTrace = _dereq_(\"./captured_trace.js\")();\n\n        var isDebugging = _dereq_(\"./debuggability.js\")(Promise, CapturedTrace);\n        /*jshint unused:false*/\n\n\n        var createContext = _dereq_(\"./context.js\")(Promise, CapturedTrace, isDebugging);\n\n        var CatchFilter = _dereq_(\"./catch_filter.js\")(NEXT_FILTER);\n\n        var PromiseResolver = _dereq_(\"./promise_resolver.js\");\n\n        var nodebackForPromise = PromiseResolver._nodebackForPromise;\n        var errorObj = util.errorObj;\n        var tryCatch = util.tryCatch;\n\n        function Promise(resolver) {\n          if (typeof resolver !== \"function\") {\n            throw new TypeError(\"the promise constructor requires a resolver function\\u000a\\u000a    See http://goo.gl/EC22Yn\\u000a\");\n          }\n\n          if (this.constructor !== Promise) {\n            throw new TypeError(\"the promise constructor cannot be invoked directly\\u000a\\u000a    See http://goo.gl/KsIlge\\u000a\");\n          }\n\n          this._bitField = 0;\n          this._fulfillmentHandler0 = undefined;\n          this._rejectionHandler0 = undefined;\n          this._progressHandler0 = undefined;\n          this._promise0 = undefined;\n          this._receiver0 = undefined;\n          this._settledValue = undefined;\n          if (resolver !== INTERNAL) this._resolveFromResolver(resolver);\n        }\n\n        Promise.prototype.toString = function () {\n          return \"[object Promise]\";\n        };\n\n        Promise.prototype.caught = Promise.prototype[\"catch\"] = function (fn) {\n          var len = arguments.length;\n\n          if (len > 1) {\n            var catchInstances = new Array(len - 1),\n                j = 0,\n                i;\n\n            for (i = 0; i < len - 1; ++i) {\n              var item = arguments[i];\n\n              if (typeof item === \"function\") {\n                catchInstances[j++] = item;\n              } else {\n                return Promise.reject(new TypeError(\"Catch filter must inherit from Error or be a simple predicate function\\u000a\\u000a    See http://goo.gl/o84o68\\u000a\"));\n              }\n            }\n\n            catchInstances.length = j;\n            fn = arguments[i];\n            var catchFilter = new CatchFilter(catchInstances, fn, this);\n            return this._then(undefined, catchFilter.doFilter, undefined, catchFilter, undefined);\n          }\n\n          return this._then(undefined, fn, undefined, undefined, undefined);\n        };\n\n        Promise.prototype.reflect = function () {\n          return this._then(reflect, reflect, undefined, this, undefined);\n        };\n\n        Promise.prototype.then = function (didFulfill, didReject, didProgress) {\n          if (isDebugging() && arguments.length > 0 && typeof didFulfill !== \"function\" && typeof didReject !== \"function\") {\n            var msg = \".then() only accepts functions but was passed: \" + util.classString(didFulfill);\n\n            if (arguments.length > 1) {\n              msg += \", \" + util.classString(didReject);\n            }\n\n            this._warn(msg);\n          }\n\n          return this._then(didFulfill, didReject, didProgress, undefined, undefined);\n        };\n\n        Promise.prototype.done = function (didFulfill, didReject, didProgress) {\n          var promise = this._then(didFulfill, didReject, didProgress, undefined, undefined);\n\n          promise._setIsFinal();\n        };\n\n        Promise.prototype.spread = function (didFulfill, didReject) {\n          return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);\n        };\n\n        Promise.prototype.isCancellable = function () {\n          return !this.isResolved() && this._cancellable();\n        };\n\n        Promise.prototype.toJSON = function () {\n          var ret = {\n            isFulfilled: false,\n            isRejected: false,\n            fulfillmentValue: undefined,\n            rejectionReason: undefined\n          };\n\n          if (this.isFulfilled()) {\n            ret.fulfillmentValue = this.value();\n            ret.isFulfilled = true;\n          } else if (this.isRejected()) {\n            ret.rejectionReason = this.reason();\n            ret.isRejected = true;\n          }\n\n          return ret;\n        };\n\n        Promise.prototype.all = function () {\n          return new PromiseArray(this).promise();\n        };\n\n        Promise.prototype.error = function (fn) {\n          return this.caught(util.originatesFromRejection, fn);\n        };\n\n        Promise.getNewLibraryCopy = module.exports;\n\n        Promise.is = function (val) {\n          return val instanceof Promise;\n        };\n\n        Promise.fromNode = function (fn) {\n          var ret = new Promise(INTERNAL);\n          var result = tryCatch(fn)(nodebackForPromise(ret));\n\n          if (result === errorObj) {\n            ret._rejectCallback(result.e, true, true);\n          }\n\n          return ret;\n        };\n\n        Promise.all = function (promises) {\n          return new PromiseArray(promises).promise();\n        };\n\n        Promise.defer = Promise.pending = function () {\n          var promise = new Promise(INTERNAL);\n          return new PromiseResolver(promise);\n        };\n\n        Promise.cast = function (obj) {\n          var ret = tryConvertToPromise(obj);\n\n          if (!(ret instanceof Promise)) {\n            var val = ret;\n            ret = new Promise(INTERNAL);\n\n            ret._fulfillUnchecked(val);\n          }\n\n          return ret;\n        };\n\n        Promise.resolve = Promise.fulfilled = Promise.cast;\n\n        Promise.reject = Promise.rejected = function (reason) {\n          var ret = new Promise(INTERNAL);\n\n          ret._captureStackTrace();\n\n          ret._rejectCallback(reason, true);\n\n          return ret;\n        };\n\n        Promise.setScheduler = function (fn) {\n          if (typeof fn !== \"function\") throw new TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n          var prev = async._schedule;\n          async._schedule = fn;\n          return prev;\n        };\n\n        Promise.prototype._then = function (didFulfill, didReject, didProgress, receiver, internalData) {\n          var haveInternalData = internalData !== undefined;\n          var ret = haveInternalData ? internalData : new Promise(INTERNAL);\n\n          if (!haveInternalData) {\n            ret._propagateFrom(this, 4 | 1);\n\n            ret._captureStackTrace();\n          }\n\n          var target = this._target();\n\n          if (target !== this) {\n            if (receiver === undefined) receiver = this._boundTo;\n            if (!haveInternalData) ret._setIsMigrated();\n          }\n\n          var callbackIndex = target._addCallbacks(didFulfill, didReject, didProgress, ret, receiver, getDomain());\n\n          if (target._isResolved() && !target._isSettlePromisesQueued()) {\n            async.invoke(target._settlePromiseAtPostResolution, target, callbackIndex);\n          }\n\n          return ret;\n        };\n\n        Promise.prototype._settlePromiseAtPostResolution = function (index) {\n          if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();\n\n          this._settlePromiseAt(index);\n        };\n\n        Promise.prototype._length = function () {\n          return this._bitField & 131071;\n        };\n\n        Promise.prototype._isFollowingOrFulfilledOrRejected = function () {\n          return (this._bitField & 939524096) > 0;\n        };\n\n        Promise.prototype._isFollowing = function () {\n          return (this._bitField & 536870912) === 536870912;\n        };\n\n        Promise.prototype._setLength = function (len) {\n          this._bitField = this._bitField & -131072 | len & 131071;\n        };\n\n        Promise.prototype._setFulfilled = function () {\n          this._bitField = this._bitField | 268435456;\n        };\n\n        Promise.prototype._setRejected = function () {\n          this._bitField = this._bitField | 134217728;\n        };\n\n        Promise.prototype._setFollowing = function () {\n          this._bitField = this._bitField | 536870912;\n        };\n\n        Promise.prototype._setIsFinal = function () {\n          this._bitField = this._bitField | 33554432;\n        };\n\n        Promise.prototype._isFinal = function () {\n          return (this._bitField & 33554432) > 0;\n        };\n\n        Promise.prototype._cancellable = function () {\n          return (this._bitField & 67108864) > 0;\n        };\n\n        Promise.prototype._setCancellable = function () {\n          this._bitField = this._bitField | 67108864;\n        };\n\n        Promise.prototype._unsetCancellable = function () {\n          this._bitField = this._bitField & ~67108864;\n        };\n\n        Promise.prototype._setIsMigrated = function () {\n          this._bitField = this._bitField | 4194304;\n        };\n\n        Promise.prototype._unsetIsMigrated = function () {\n          this._bitField = this._bitField & ~4194304;\n        };\n\n        Promise.prototype._isMigrated = function () {\n          return (this._bitField & 4194304) > 0;\n        };\n\n        Promise.prototype._receiverAt = function (index) {\n          var ret = index === 0 ? this._receiver0 : this[index * 5 - 5 + 4];\n\n          if (ret === UNDEFINED_BINDING) {\n            return undefined;\n          } else if (ret === undefined && this._isBound()) {\n            return this._boundValue();\n          }\n\n          return ret;\n        };\n\n        Promise.prototype._promiseAt = function (index) {\n          return index === 0 ? this._promise0 : this[index * 5 - 5 + 3];\n        };\n\n        Promise.prototype._fulfillmentHandlerAt = function (index) {\n          return index === 0 ? this._fulfillmentHandler0 : this[index * 5 - 5 + 0];\n        };\n\n        Promise.prototype._rejectionHandlerAt = function (index) {\n          return index === 0 ? this._rejectionHandler0 : this[index * 5 - 5 + 1];\n        };\n\n        Promise.prototype._boundValue = function () {\n          var ret = this._boundTo;\n\n          if (ret !== undefined) {\n            if (ret instanceof Promise) {\n              if (ret.isFulfilled()) {\n                return ret.value();\n              } else {\n                return undefined;\n              }\n            }\n          }\n\n          return ret;\n        };\n\n        Promise.prototype._migrateCallbacks = function (follower, index) {\n          var fulfill = follower._fulfillmentHandlerAt(index);\n\n          var reject = follower._rejectionHandlerAt(index);\n\n          var progress = follower._progressHandlerAt(index);\n\n          var promise = follower._promiseAt(index);\n\n          var receiver = follower._receiverAt(index);\n\n          if (promise instanceof Promise) promise._setIsMigrated();\n          if (receiver === undefined) receiver = UNDEFINED_BINDING;\n\n          this._addCallbacks(fulfill, reject, progress, promise, receiver, null);\n        };\n\n        Promise.prototype._addCallbacks = function (fulfill, reject, progress, promise, receiver, domain) {\n          var index = this._length();\n\n          if (index >= 131071 - 5) {\n            index = 0;\n\n            this._setLength(0);\n          }\n\n          if (index === 0) {\n            this._promise0 = promise;\n            if (receiver !== undefined) this._receiver0 = receiver;\n\n            if (typeof fulfill === \"function\" && !this._isCarryingStackTrace()) {\n              this._fulfillmentHandler0 = domain === null ? fulfill : domain.bind(fulfill);\n            }\n\n            if (typeof reject === \"function\") {\n              this._rejectionHandler0 = domain === null ? reject : domain.bind(reject);\n            }\n\n            if (typeof progress === \"function\") {\n              this._progressHandler0 = domain === null ? progress : domain.bind(progress);\n            }\n          } else {\n            var base = index * 5 - 5;\n            this[base + 3] = promise;\n            this[base + 4] = receiver;\n\n            if (typeof fulfill === \"function\") {\n              this[base + 0] = domain === null ? fulfill : domain.bind(fulfill);\n            }\n\n            if (typeof reject === \"function\") {\n              this[base + 1] = domain === null ? reject : domain.bind(reject);\n            }\n\n            if (typeof progress === \"function\") {\n              this[base + 2] = domain === null ? progress : domain.bind(progress);\n            }\n          }\n\n          this._setLength(index + 1);\n\n          return index;\n        };\n\n        Promise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {\n          var index = this._length();\n\n          if (index >= 131071 - 5) {\n            index = 0;\n\n            this._setLength(0);\n          }\n\n          if (index === 0) {\n            this._promise0 = promiseSlotValue;\n            this._receiver0 = receiver;\n          } else {\n            var base = index * 5 - 5;\n            this[base + 3] = promiseSlotValue;\n            this[base + 4] = receiver;\n          }\n\n          this._setLength(index + 1);\n        };\n\n        Promise.prototype._proxyPromiseArray = function (promiseArray, index) {\n          this._setProxyHandlers(promiseArray, index);\n        };\n\n        Promise.prototype._resolveCallback = function (value, shouldBind) {\n          if (this._isFollowingOrFulfilledOrRejected()) return;\n          if (value === this) return this._rejectCallback(makeSelfResolutionError(), false, true);\n          var maybePromise = tryConvertToPromise(value, this);\n          if (!(maybePromise instanceof Promise)) return this._fulfill(value);\n          var propagationFlags = 1 | (shouldBind ? 4 : 0);\n\n          this._propagateFrom(maybePromise, propagationFlags);\n\n          var promise = maybePromise._target();\n\n          if (promise._isPending()) {\n            var len = this._length();\n\n            for (var i = 0; i < len; ++i) {\n              promise._migrateCallbacks(this, i);\n            }\n\n            this._setFollowing();\n\n            this._setLength(0);\n\n            this._setFollowee(promise);\n          } else if (promise._isFulfilled()) {\n            this._fulfillUnchecked(promise._value());\n          } else {\n            this._rejectUnchecked(promise._reason(), promise._getCarriedStackTrace());\n          }\n        };\n\n        Promise.prototype._rejectCallback = function (reason, synchronous, shouldNotMarkOriginatingFromRejection) {\n          if (!shouldNotMarkOriginatingFromRejection) {\n            util.markAsOriginatingFromRejection(reason);\n          }\n\n          var trace = util.ensureErrorObject(reason);\n          var hasStack = trace === reason;\n\n          this._attachExtraTrace(trace, synchronous ? hasStack : false);\n\n          this._reject(reason, hasStack ? undefined : trace);\n        };\n\n        Promise.prototype._resolveFromResolver = function (resolver) {\n          var promise = this;\n\n          this._captureStackTrace();\n\n          this._pushContext();\n\n          var synchronous = true;\n          var r = tryCatch(resolver)(function (value) {\n            if (promise === null) return;\n\n            promise._resolveCallback(value);\n\n            promise = null;\n          }, function (reason) {\n            if (promise === null) return;\n\n            promise._rejectCallback(reason, synchronous);\n\n            promise = null;\n          });\n          synchronous = false;\n\n          this._popContext();\n\n          if (r !== undefined && r === errorObj && promise !== null) {\n            promise._rejectCallback(r.e, true, true);\n\n            promise = null;\n          }\n        };\n\n        Promise.prototype._settlePromiseFromHandler = function (handler, receiver, value, promise) {\n          if (promise._isRejected()) return;\n\n          promise._pushContext();\n\n          var x;\n\n          if (receiver === APPLY && !this._isRejected()) {\n            x = tryCatch(handler).apply(this._boundValue(), value);\n          } else {\n            x = tryCatch(handler).call(receiver, value);\n          }\n\n          promise._popContext();\n\n          if (x === errorObj || x === promise || x === NEXT_FILTER) {\n            var err = x === promise ? makeSelfResolutionError() : x.e;\n\n            promise._rejectCallback(err, false, true);\n          } else {\n            promise._resolveCallback(x);\n          }\n        };\n\n        Promise.prototype._target = function () {\n          var ret = this;\n\n          while (ret._isFollowing()) ret = ret._followee();\n\n          return ret;\n        };\n\n        Promise.prototype._followee = function () {\n          return this._rejectionHandler0;\n        };\n\n        Promise.prototype._setFollowee = function (promise) {\n          this._rejectionHandler0 = promise;\n        };\n\n        Promise.prototype._cleanValues = function () {\n          if (this._cancellable()) {\n            this._cancellationParent = undefined;\n          }\n        };\n\n        Promise.prototype._propagateFrom = function (parent, flags) {\n          if ((flags & 1) > 0 && parent._cancellable()) {\n            this._setCancellable();\n\n            this._cancellationParent = parent;\n          }\n\n          if ((flags & 4) > 0 && parent._isBound()) {\n            this._setBoundTo(parent._boundTo);\n          }\n        };\n\n        Promise.prototype._fulfill = function (value) {\n          if (this._isFollowingOrFulfilledOrRejected()) return;\n\n          this._fulfillUnchecked(value);\n        };\n\n        Promise.prototype._reject = function (reason, carriedStackTrace) {\n          if (this._isFollowingOrFulfilledOrRejected()) return;\n\n          this._rejectUnchecked(reason, carriedStackTrace);\n        };\n\n        Promise.prototype._settlePromiseAt = function (index) {\n          var promise = this._promiseAt(index);\n\n          var isPromise = promise instanceof Promise;\n\n          if (isPromise && promise._isMigrated()) {\n            promise._unsetIsMigrated();\n\n            return async.invoke(this._settlePromiseAt, this, index);\n          }\n\n          var handler = this._isFulfilled() ? this._fulfillmentHandlerAt(index) : this._rejectionHandlerAt(index);\n          var carriedStackTrace = this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;\n          var value = this._settledValue;\n\n          var receiver = this._receiverAt(index);\n\n          this._clearCallbackDataAtIndex(index);\n\n          if (typeof handler === \"function\") {\n            if (!isPromise) {\n              handler.call(receiver, value, promise);\n            } else {\n              this._settlePromiseFromHandler(handler, receiver, value, promise);\n            }\n          } else if (receiver instanceof PromiseArray) {\n            if (!receiver._isResolved()) {\n              if (this._isFulfilled()) {\n                receiver._promiseFulfilled(value, promise);\n              } else {\n                receiver._promiseRejected(value, promise);\n              }\n            }\n          } else if (isPromise) {\n            if (this._isFulfilled()) {\n              promise._fulfill(value);\n            } else {\n              promise._reject(value, carriedStackTrace);\n            }\n          }\n\n          if (index >= 4 && (index & 31) === 4) async.invokeLater(this._setLength, this, 0);\n        };\n\n        Promise.prototype._clearCallbackDataAtIndex = function (index) {\n          if (index === 0) {\n            if (!this._isCarryingStackTrace()) {\n              this._fulfillmentHandler0 = undefined;\n            }\n\n            this._rejectionHandler0 = this._progressHandler0 = this._receiver0 = this._promise0 = undefined;\n          } else {\n            var base = index * 5 - 5;\n            this[base + 3] = this[base + 4] = this[base + 0] = this[base + 1] = this[base + 2] = undefined;\n          }\n        };\n\n        Promise.prototype._isSettlePromisesQueued = function () {\n          return (this._bitField & -1073741824) === -1073741824;\n        };\n\n        Promise.prototype._setSettlePromisesQueued = function () {\n          this._bitField = this._bitField | -1073741824;\n        };\n\n        Promise.prototype._unsetSettlePromisesQueued = function () {\n          this._bitField = this._bitField & ~-1073741824;\n        };\n\n        Promise.prototype._queueSettlePromises = function () {\n          async.settlePromises(this);\n\n          this._setSettlePromisesQueued();\n        };\n\n        Promise.prototype._fulfillUnchecked = function (value) {\n          if (value === this) {\n            var err = makeSelfResolutionError();\n\n            this._attachExtraTrace(err);\n\n            return this._rejectUnchecked(err, undefined);\n          }\n\n          this._setFulfilled();\n\n          this._settledValue = value;\n\n          this._cleanValues();\n\n          if (this._length() > 0) {\n            this._queueSettlePromises();\n          }\n        };\n\n        Promise.prototype._rejectUncheckedCheckError = function (reason) {\n          var trace = util.ensureErrorObject(reason);\n\n          this._rejectUnchecked(reason, trace === reason ? undefined : trace);\n        };\n\n        Promise.prototype._rejectUnchecked = function (reason, trace) {\n          if (reason === this) {\n            var err = makeSelfResolutionError();\n\n            this._attachExtraTrace(err);\n\n            return this._rejectUnchecked(err);\n          }\n\n          this._setRejected();\n\n          this._settledValue = reason;\n\n          this._cleanValues();\n\n          if (this._isFinal()) {\n            async.throwLater(function (e) {\n              if (\"stack\" in e) {\n                async.invokeFirst(CapturedTrace.unhandledRejection, undefined, e);\n              }\n\n              throw e;\n            }, trace === undefined ? reason : trace);\n            return;\n          }\n\n          if (trace !== undefined && trace !== reason) {\n            this._setCarriedStackTrace(trace);\n          }\n\n          if (this._length() > 0) {\n            this._queueSettlePromises();\n          } else {\n            this._ensurePossibleRejectionHandled();\n          }\n        };\n\n        Promise.prototype._settlePromises = function () {\n          this._unsetSettlePromisesQueued();\n\n          var len = this._length();\n\n          for (var i = 0; i < len; i++) {\n            this._settlePromiseAt(i);\n          }\n        };\n\n        util.notEnumerableProp(Promise, \"_makeSelfResolutionError\", makeSelfResolutionError);\n\n        _dereq_(\"./progress.js\")(Promise, PromiseArray);\n\n        _dereq_(\"./method.js\")(Promise, INTERNAL, tryConvertToPromise, apiRejection);\n\n        _dereq_(\"./bind.js\")(Promise, INTERNAL, tryConvertToPromise);\n\n        _dereq_(\"./finally.js\")(Promise, NEXT_FILTER, tryConvertToPromise);\n\n        _dereq_(\"./direct_resolve.js\")(Promise);\n\n        _dereq_(\"./synchronous_inspection.js\")(Promise);\n\n        _dereq_(\"./join.js\")(Promise, PromiseArray, tryConvertToPromise, INTERNAL);\n\n        Promise.version = \"2.11.0\";\n        Promise.Promise = Promise;\n\n        _dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);\n\n        _dereq_('./cancel.js')(Promise);\n\n        _dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext);\n\n        _dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise);\n\n        _dereq_('./nodeify.js')(Promise);\n\n        _dereq_('./call_get.js')(Promise);\n\n        _dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);\n\n        _dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);\n\n        _dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);\n\n        _dereq_('./settle.js')(Promise, PromiseArray);\n\n        _dereq_('./some.js')(Promise, PromiseArray, apiRejection);\n\n        _dereq_('./promisify.js')(Promise, INTERNAL);\n\n        _dereq_('./any.js')(Promise);\n\n        _dereq_('./each.js')(Promise, INTERNAL);\n\n        _dereq_('./timers.js')(Promise, INTERNAL);\n\n        _dereq_('./filter.js')(Promise, INTERNAL);\n\n        util.toFastProperties(Promise);\n        util.toFastProperties(Promise.prototype);\n\n        function fillTypes(value) {\n          var p = new Promise(INTERNAL);\n          p._fulfillmentHandler0 = value;\n          p._rejectionHandler0 = value;\n          p._progressHandler0 = value;\n          p._promise0 = value;\n          p._receiver0 = value;\n          p._settledValue = value;\n        } // Complete slack tracking, opt out of field-type tracking and           \n        // stabilize map                                                         \n\n\n        fillTypes({\n          a: 1\n        });\n        fillTypes({\n          b: 2\n        });\n        fillTypes({\n          c: 3\n        });\n        fillTypes(1);\n        fillTypes(function () {});\n        fillTypes(undefined);\n        fillTypes(false);\n        fillTypes(new Promise(INTERNAL));\n        CapturedTrace.setBounds(async.firstLineError, util.lastLineError);\n        return Promise;\n      };\n    }, {\n      \"./any.js\": 1,\n      \"./async.js\": 2,\n      \"./bind.js\": 3,\n      \"./call_get.js\": 5,\n      \"./cancel.js\": 6,\n      \"./captured_trace.js\": 7,\n      \"./catch_filter.js\": 8,\n      \"./context.js\": 9,\n      \"./debuggability.js\": 10,\n      \"./direct_resolve.js\": 11,\n      \"./each.js\": 12,\n      \"./errors.js\": 13,\n      \"./filter.js\": 15,\n      \"./finally.js\": 16,\n      \"./generators.js\": 17,\n      \"./join.js\": 18,\n      \"./map.js\": 19,\n      \"./method.js\": 20,\n      \"./nodeify.js\": 21,\n      \"./progress.js\": 22,\n      \"./promise_array.js\": 24,\n      \"./promise_resolver.js\": 25,\n      \"./promisify.js\": 26,\n      \"./props.js\": 27,\n      \"./race.js\": 29,\n      \"./reduce.js\": 30,\n      \"./settle.js\": 32,\n      \"./some.js\": 33,\n      \"./synchronous_inspection.js\": 34,\n      \"./thenables.js\": 35,\n      \"./timers.js\": 36,\n      \"./using.js\": 37,\n      \"./util.js\": 38\n    }],\n    24: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection) {\n        var util = _dereq_(\"./util.js\");\n\n        var isArray = util.isArray;\n\n        function toResolutionValue(val) {\n          switch (val) {\n            case -2:\n              return [];\n\n            case -3:\n              return {};\n          }\n        }\n\n        function PromiseArray(values) {\n          var promise = this._promise = new Promise(INTERNAL);\n          var parent;\n\n          if (values instanceof Promise) {\n            parent = values;\n\n            promise._propagateFrom(parent, 1 | 4);\n          }\n\n          this._values = values;\n          this._length = 0;\n          this._totalResolved = 0;\n\n          this._init(undefined, -2);\n        }\n\n        PromiseArray.prototype.length = function () {\n          return this._length;\n        };\n\n        PromiseArray.prototype.promise = function () {\n          return this._promise;\n        };\n\n        PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {\n          var values = tryConvertToPromise(this._values, this._promise);\n\n          if (values instanceof Promise) {\n            values = values._target();\n            this._values = values;\n\n            if (values._isFulfilled()) {\n              values = values._value();\n\n              if (!isArray(values)) {\n                var err = new Promise.TypeError(\"expecting an array, a promise or a thenable\\u000a\\u000a    See http://goo.gl/s8MMhc\\u000a\");\n\n                this.__hardReject__(err);\n\n                return;\n              }\n            } else if (values._isPending()) {\n              values._then(init, this._reject, undefined, this, resolveValueIfEmpty);\n\n              return;\n            } else {\n              this._reject(values._reason());\n\n              return;\n            }\n          } else if (!isArray(values)) {\n            this._promise._reject(apiRejection(\"expecting an array, a promise or a thenable\\u000a\\u000a    See http://goo.gl/s8MMhc\\u000a\")._reason());\n\n            return;\n          }\n\n          if (values.length === 0) {\n            if (resolveValueIfEmpty === -5) {\n              this._resolveEmptyArray();\n            } else {\n              this._resolve(toResolutionValue(resolveValueIfEmpty));\n            }\n\n            return;\n          }\n\n          var len = this.getActualLength(values.length);\n          this._length = len;\n          this._values = this.shouldCopyValues() ? new Array(len) : this._values;\n          var promise = this._promise;\n\n          for (var i = 0; i < len; ++i) {\n            var isResolved = this._isResolved();\n\n            var maybePromise = tryConvertToPromise(values[i], promise);\n\n            if (maybePromise instanceof Promise) {\n              maybePromise = maybePromise._target();\n\n              if (isResolved) {\n                maybePromise._ignoreRejections();\n              } else if (maybePromise._isPending()) {\n                maybePromise._proxyPromiseArray(this, i);\n              } else if (maybePromise._isFulfilled()) {\n                this._promiseFulfilled(maybePromise._value(), i);\n              } else {\n                this._promiseRejected(maybePromise._reason(), i);\n              }\n            } else if (!isResolved) {\n              this._promiseFulfilled(maybePromise, i);\n            }\n          }\n        };\n\n        PromiseArray.prototype._isResolved = function () {\n          return this._values === null;\n        };\n\n        PromiseArray.prototype._resolve = function (value) {\n          this._values = null;\n\n          this._promise._fulfill(value);\n        };\n\n        PromiseArray.prototype.__hardReject__ = PromiseArray.prototype._reject = function (reason) {\n          this._values = null;\n\n          this._promise._rejectCallback(reason, false, true);\n        };\n\n        PromiseArray.prototype._promiseProgressed = function (progressValue, index) {\n          this._promise._progress({\n            index: index,\n            value: progressValue\n          });\n        };\n\n        PromiseArray.prototype._promiseFulfilled = function (value, index) {\n          this._values[index] = value;\n          var totalResolved = ++this._totalResolved;\n\n          if (totalResolved >= this._length) {\n            this._resolve(this._values);\n          }\n        };\n\n        PromiseArray.prototype._promiseRejected = function (reason, index) {\n          this._totalResolved++;\n\n          this._reject(reason);\n        };\n\n        PromiseArray.prototype.shouldCopyValues = function () {\n          return true;\n        };\n\n        PromiseArray.prototype.getActualLength = function (len) {\n          return len;\n        };\n\n        return PromiseArray;\n      };\n    }, {\n      \"./util.js\": 38\n    }],\n    25: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      var util = _dereq_(\"./util.js\");\n\n      var maybeWrapAsError = util.maybeWrapAsError;\n\n      var errors = _dereq_(\"./errors.js\");\n\n      var TimeoutError = errors.TimeoutError;\n      var OperationalError = errors.OperationalError;\n      var haveGetters = util.haveGetters;\n\n      var es5 = _dereq_(\"./es5.js\");\n\n      function isUntypedError(obj) {\n        return obj instanceof Error && es5.getPrototypeOf(obj) === Error.prototype;\n      }\n\n      var rErrorKey = /^(?:name|message|stack|cause)$/;\n\n      function wrapAsOperationalError(obj) {\n        var ret;\n\n        if (isUntypedError(obj)) {\n          ret = new OperationalError(obj);\n          ret.name = obj.name;\n          ret.message = obj.message;\n          ret.stack = obj.stack;\n          var keys = es5.keys(obj);\n\n          for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n\n            if (!rErrorKey.test(key)) {\n              ret[key] = obj[key];\n            }\n          }\n\n          return ret;\n        }\n\n        util.markAsOriginatingFromRejection(obj);\n        return obj;\n      }\n\n      function nodebackForPromise(promise) {\n        return function (err, value) {\n          if (promise === null) return;\n\n          if (err) {\n            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));\n\n            promise._attachExtraTrace(wrapped);\n\n            promise._reject(wrapped);\n          } else if (arguments.length > 2) {\n            var $_len = arguments.length;\n            var args = new Array($_len - 1);\n\n            for (var $_i = 1; $_i < $_len; ++$_i) {\n              args[$_i - 1] = arguments[$_i];\n            }\n\n            promise._fulfill(args);\n          } else {\n            promise._fulfill(value);\n          }\n\n          promise = null;\n        };\n      }\n\n      var PromiseResolver;\n\n      if (!haveGetters) {\n        PromiseResolver = function (promise) {\n          this.promise = promise;\n          this.asCallback = nodebackForPromise(promise);\n          this.callback = this.asCallback;\n        };\n      } else {\n        PromiseResolver = function (promise) {\n          this.promise = promise;\n        };\n      }\n\n      if (haveGetters) {\n        var prop = {\n          get: function () {\n            return nodebackForPromise(this.promise);\n          }\n        };\n        es5.defineProperty(PromiseResolver.prototype, \"asCallback\", prop);\n        es5.defineProperty(PromiseResolver.prototype, \"callback\", prop);\n      }\n\n      PromiseResolver._nodebackForPromise = nodebackForPromise;\n\n      PromiseResolver.prototype.toString = function () {\n        return \"[object PromiseResolver]\";\n      };\n\n      PromiseResolver.prototype.resolve = PromiseResolver.prototype.fulfill = function (value) {\n        if (!(this instanceof PromiseResolver)) {\n          throw new TypeError(\"Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\\u000a\\u000a    See http://goo.gl/sdkXL9\\u000a\");\n        }\n\n        this.promise._resolveCallback(value);\n      };\n\n      PromiseResolver.prototype.reject = function (reason) {\n        if (!(this instanceof PromiseResolver)) {\n          throw new TypeError(\"Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\\u000a\\u000a    See http://goo.gl/sdkXL9\\u000a\");\n        }\n\n        this.promise._rejectCallback(reason);\n      };\n\n      PromiseResolver.prototype.progress = function (value) {\n        if (!(this instanceof PromiseResolver)) {\n          throw new TypeError(\"Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\\u000a\\u000a    See http://goo.gl/sdkXL9\\u000a\");\n        }\n\n        this.promise._progress(value);\n      };\n\n      PromiseResolver.prototype.cancel = function (err) {\n        this.promise.cancel(err);\n      };\n\n      PromiseResolver.prototype.timeout = function () {\n        this.reject(new TimeoutError(\"timeout\"));\n      };\n\n      PromiseResolver.prototype.isResolved = function () {\n        return this.promise.isResolved();\n      };\n\n      PromiseResolver.prototype.toJSON = function () {\n        return this.promise.toJSON();\n      };\n\n      module.exports = PromiseResolver;\n    }, {\n      \"./errors.js\": 13,\n      \"./es5.js\": 14,\n      \"./util.js\": 38\n    }],\n    26: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise, INTERNAL) {\n        var THIS = {};\n\n        var util = _dereq_(\"./util.js\");\n\n        var nodebackForPromise = _dereq_(\"./promise_resolver.js\")._nodebackForPromise;\n\n        var withAppended = util.withAppended;\n        var maybeWrapAsError = util.maybeWrapAsError;\n        var canEvaluate = util.canEvaluate;\n\n        var TypeError = _dereq_(\"./errors\").TypeError;\n\n        var defaultSuffix = \"Async\";\n        var defaultPromisified = {\n          __isPromisified__: true\n        };\n        var noCopyProps = [\"arity\", \"length\", \"name\", \"arguments\", \"caller\", \"callee\", \"prototype\", \"__isPromisified__\"];\n        var noCopyPropsPattern = new RegExp(\"^(?:\" + noCopyProps.join(\"|\") + \")$\");\n\n        var defaultFilter = function (name) {\n          return util.isIdentifier(name) && name.charAt(0) !== \"_\" && name !== \"constructor\";\n        };\n\n        function propsFilter(key) {\n          return !noCopyPropsPattern.test(key);\n        }\n\n        function isPromisified(fn) {\n          try {\n            return fn.__isPromisified__ === true;\n          } catch (e) {\n            return false;\n          }\n        }\n\n        function hasPromisified(obj, key, suffix) {\n          var val = util.getDataPropertyOrDefault(obj, key + suffix, defaultPromisified);\n          return val ? isPromisified(val) : false;\n        }\n\n        function checkValid(ret, suffix, suffixRegexp) {\n          for (var i = 0; i < ret.length; i += 2) {\n            var key = ret[i];\n\n            if (suffixRegexp.test(key)) {\n              var keyWithoutAsyncSuffix = key.replace(suffixRegexp, \"\");\n\n              for (var j = 0; j < ret.length; j += 2) {\n                if (ret[j] === keyWithoutAsyncSuffix) {\n                  throw new TypeError(\"Cannot promisify an API that has normal methods with '%s'-suffix\\u000a\\u000a    See http://goo.gl/iWrZbw\\u000a\".replace(\"%s\", suffix));\n                }\n              }\n            }\n          }\n        }\n\n        function promisifiableMethods(obj, suffix, suffixRegexp, filter) {\n          var keys = util.inheritedDataKeys(obj);\n          var ret = [];\n\n          for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            var value = obj[key];\n            var passesDefaultFilter = filter === defaultFilter ? true : defaultFilter(key, value, obj);\n\n            if (typeof value === \"function\" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter(key, value, obj, passesDefaultFilter)) {\n              ret.push(key, value);\n            }\n          }\n\n          checkValid(ret, suffix, suffixRegexp);\n          return ret;\n        }\n\n        var escapeIdentRegex = function (str) {\n          return str.replace(/([$])/, \"\\\\$\");\n        };\n\n        var makeNodePromisifiedEval;\n\n        if (!true) {\n          var switchCaseArgumentOrder = function (likelyArgumentCount) {\n            var ret = [likelyArgumentCount];\n            var min = Math.max(0, likelyArgumentCount - 1 - 3);\n\n            for (var i = likelyArgumentCount - 1; i >= min; --i) {\n              ret.push(i);\n            }\n\n            for (var i = likelyArgumentCount + 1; i <= 3; ++i) {\n              ret.push(i);\n            }\n\n            return ret;\n          };\n\n          var argumentSequence = function (argumentCount) {\n            return util.filledRange(argumentCount, \"_arg\", \"\");\n          };\n\n          var parameterDeclaration = function (parameterCount) {\n            return util.filledRange(Math.max(parameterCount, 3), \"_arg\", \"\");\n          };\n\n          var parameterCount = function (fn) {\n            if (typeof fn.length === \"number\") {\n              return Math.max(Math.min(fn.length, 1023 + 1), 0);\n            }\n\n            return 0;\n          };\n\n          makeNodePromisifiedEval = function (callback, receiver, originalName, fn) {\n            var newParameterCount = Math.max(0, parameterCount(fn) - 1);\n            var argumentOrder = switchCaseArgumentOrder(newParameterCount);\n            var shouldProxyThis = typeof callback === \"string\" || receiver === THIS;\n\n            function generateCallForArgumentCount(count) {\n              var args = argumentSequence(count).join(\", \");\n              var comma = count > 0 ? \", \" : \"\";\n              var ret;\n\n              if (shouldProxyThis) {\n                ret = \"ret = callback.call(this, {{args}}, nodeback); break;\\n\";\n              } else {\n                ret = receiver === undefined ? \"ret = callback({{args}}, nodeback); break;\\n\" : \"ret = callback.call(receiver, {{args}}, nodeback); break;\\n\";\n              }\n\n              return ret.replace(\"{{args}}\", args).replace(\", \", comma);\n            }\n\n            function generateArgumentSwitchCase() {\n              var ret = \"\";\n\n              for (var i = 0; i < argumentOrder.length; ++i) {\n                ret += \"case \" + argumentOrder[i] + \":\" + generateCallForArgumentCount(argumentOrder[i]);\n              }\n\n              ret += \"                                                             \\n\\\n        default:                                                             \\n\\\n            var args = new Array(len + 1);                                   \\n\\\n            var i = 0;                                                       \\n\\\n            for (var i = 0; i < len; ++i) {                                  \\n\\\n               args[i] = arguments[i];                                       \\n\\\n            }                                                                \\n\\\n            args[i] = nodeback;                                              \\n\\\n            [CodeForCall]                                                    \\n\\\n            break;                                                           \\n\\\n        \".replace(\"[CodeForCall]\", shouldProxyThis ? \"ret = callback.apply(this, args);\\n\" : \"ret = callback.apply(receiver, args);\\n\");\n              return ret;\n            }\n\n            var getFunctionCode = typeof callback === \"string\" ? \"this != null ? this['\" + callback + \"'] : fn\" : \"fn\";\n            return new Function(\"Promise\", \"fn\", \"receiver\", \"withAppended\", \"maybeWrapAsError\", \"nodebackForPromise\", \"tryCatch\", \"errorObj\", \"notEnumerableProp\", \"INTERNAL\", \"'use strict';                            \\n\\\n        var ret = function (Parameters) {                                    \\n\\\n            'use strict';                                                    \\n\\\n            var len = arguments.length;                                      \\n\\\n            var promise = new Promise(INTERNAL);                             \\n\\\n            promise._captureStackTrace();                                    \\n\\\n            var nodeback = nodebackForPromise(promise);                      \\n\\\n            var ret;                                                         \\n\\\n            var callback = tryCatch([GetFunctionCode]);                      \\n\\\n            switch(len) {                                                    \\n\\\n                [CodeForSwitchCase]                                          \\n\\\n            }                                                                \\n\\\n            if (ret === errorObj) {                                          \\n\\\n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\\n\\\n            }                                                                \\n\\\n            return promise;                                                  \\n\\\n        };                                                                   \\n\\\n        notEnumerableProp(ret, '__isPromisified__', true);                   \\n\\\n        return ret;                                                          \\n\\\n        \".replace(\"Parameters\", parameterDeclaration(newParameterCount)).replace(\"[CodeForSwitchCase]\", generateArgumentSwitchCase()).replace(\"[GetFunctionCode]\", getFunctionCode))(Promise, fn, receiver, withAppended, maybeWrapAsError, nodebackForPromise, util.tryCatch, util.errorObj, util.notEnumerableProp, INTERNAL);\n          };\n        }\n\n        function makeNodePromisifiedClosure(callback, receiver, _, fn) {\n          var defaultThis = function () {\n            return this;\n          }();\n\n          var method = callback;\n\n          if (typeof method === \"string\") {\n            callback = fn;\n          }\n\n          function promisified() {\n            var _receiver = receiver;\n            if (receiver === THIS) _receiver = this;\n            var promise = new Promise(INTERNAL);\n\n            promise._captureStackTrace();\n\n            var cb = typeof method === \"string\" && this !== defaultThis ? this[method] : callback;\n            var fn = nodebackForPromise(promise);\n\n            try {\n              cb.apply(_receiver, withAppended(arguments, fn));\n            } catch (e) {\n              promise._rejectCallback(maybeWrapAsError(e), true, true);\n            }\n\n            return promise;\n          }\n\n          util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n          return promisified;\n        }\n\n        var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;\n\n        function promisifyAll(obj, suffix, filter, promisifier) {\n          var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + \"$\");\n          var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter);\n\n          for (var i = 0, len = methods.length; i < len; i += 2) {\n            var key = methods[i];\n            var fn = methods[i + 1];\n            var promisifiedKey = key + suffix;\n\n            if (promisifier === makeNodePromisified) {\n              obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix);\n            } else {\n              var promisified = promisifier(fn, function () {\n                return makeNodePromisified(key, THIS, key, fn, suffix);\n              });\n              util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n              obj[promisifiedKey] = promisified;\n            }\n          }\n\n          util.toFastProperties(obj);\n          return obj;\n        }\n\n        function promisify(callback, receiver) {\n          return makeNodePromisified(callback, receiver, undefined, callback);\n        }\n\n        Promise.promisify = function (fn, receiver) {\n          if (typeof fn !== \"function\") {\n            throw new TypeError(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n          }\n\n          if (isPromisified(fn)) {\n            return fn;\n          }\n\n          var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);\n          util.copyDescriptors(fn, ret, propsFilter);\n          return ret;\n        };\n\n        Promise.promisifyAll = function (target, options) {\n          if (typeof target !== \"function\" && typeof target !== \"object\") {\n            throw new TypeError(\"the target of promisifyAll must be an object or a function\\u000a\\u000a    See http://goo.gl/9ITlV0\\u000a\");\n          }\n\n          options = Object(options);\n          var suffix = options.suffix;\n          if (typeof suffix !== \"string\") suffix = defaultSuffix;\n          var filter = options.filter;\n          if (typeof filter !== \"function\") filter = defaultFilter;\n          var promisifier = options.promisifier;\n          if (typeof promisifier !== \"function\") promisifier = makeNodePromisified;\n\n          if (!util.isIdentifier(suffix)) {\n            throw new RangeError(\"suffix must be a valid identifier\\u000a\\u000a    See http://goo.gl/8FZo5V\\u000a\");\n          }\n\n          var keys = util.inheritedDataKeys(target);\n\n          for (var i = 0; i < keys.length; ++i) {\n            var value = target[keys[i]];\n\n            if (keys[i] !== \"constructor\" && util.isClass(value)) {\n              promisifyAll(value.prototype, suffix, filter, promisifier);\n              promisifyAll(value, suffix, filter, promisifier);\n            }\n          }\n\n          return promisifyAll(target, suffix, filter, promisifier);\n        };\n      };\n    }, {\n      \"./errors\": 13,\n      \"./promise_resolver.js\": 25,\n      \"./util.js\": 38\n    }],\n    27: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise, PromiseArray, tryConvertToPromise, apiRejection) {\n        var util = _dereq_(\"./util.js\");\n\n        var isObject = util.isObject;\n\n        var es5 = _dereq_(\"./es5.js\");\n\n        function PropertiesPromiseArray(obj) {\n          var keys = es5.keys(obj);\n          var len = keys.length;\n          var values = new Array(len * 2);\n\n          for (var i = 0; i < len; ++i) {\n            var key = keys[i];\n            values[i] = obj[key];\n            values[i + len] = key;\n          }\n\n          this.constructor$(values);\n        }\n\n        util.inherits(PropertiesPromiseArray, PromiseArray);\n\n        PropertiesPromiseArray.prototype._init = function () {\n          this._init$(undefined, -3);\n        };\n\n        PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {\n          this._values[index] = value;\n          var totalResolved = ++this._totalResolved;\n\n          if (totalResolved >= this._length) {\n            var val = {};\n            var keyOffset = this.length();\n\n            for (var i = 0, len = this.length(); i < len; ++i) {\n              val[this._values[i + keyOffset]] = this._values[i];\n            }\n\n            this._resolve(val);\n          }\n        };\n\n        PropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {\n          this._promise._progress({\n            key: this._values[index + this.length()],\n            value: value\n          });\n        };\n\n        PropertiesPromiseArray.prototype.shouldCopyValues = function () {\n          return false;\n        };\n\n        PropertiesPromiseArray.prototype.getActualLength = function (len) {\n          return len >> 1;\n        };\n\n        function props(promises) {\n          var ret;\n          var castValue = tryConvertToPromise(promises);\n\n          if (!isObject(castValue)) {\n            return apiRejection(\"cannot await properties of a non-object\\u000a\\u000a    See http://goo.gl/OsFKC8\\u000a\");\n          } else if (castValue instanceof Promise) {\n            ret = castValue._then(Promise.props, undefined, undefined, undefined, undefined);\n          } else {\n            ret = new PropertiesPromiseArray(castValue).promise();\n          }\n\n          if (castValue instanceof Promise) {\n            ret._propagateFrom(castValue, 4);\n          }\n\n          return ret;\n        }\n\n        Promise.prototype.props = function () {\n          return props(this);\n        };\n\n        Promise.props = function (promises) {\n          return props(promises);\n        };\n      };\n    }, {\n      \"./es5.js\": 14,\n      \"./util.js\": 38\n    }],\n    28: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      function arrayMove(src, srcIndex, dst, dstIndex, len) {\n        for (var j = 0; j < len; ++j) {\n          dst[j + dstIndex] = src[j + srcIndex];\n          src[j + srcIndex] = void 0;\n        }\n      }\n\n      function Queue(capacity) {\n        this._capacity = capacity;\n        this._length = 0;\n        this._front = 0;\n      }\n\n      Queue.prototype._willBeOverCapacity = function (size) {\n        return this._capacity < size;\n      };\n\n      Queue.prototype._pushOne = function (arg) {\n        var length = this.length();\n\n        this._checkCapacity(length + 1);\n\n        var i = this._front + length & this._capacity - 1;\n        this[i] = arg;\n        this._length = length + 1;\n      };\n\n      Queue.prototype._unshiftOne = function (value) {\n        var capacity = this._capacity;\n\n        this._checkCapacity(this.length() + 1);\n\n        var front = this._front;\n        var i = (front - 1 & capacity - 1 ^ capacity) - capacity;\n        this[i] = value;\n        this._front = i;\n        this._length = this.length() + 1;\n      };\n\n      Queue.prototype.unshift = function (fn, receiver, arg) {\n        this._unshiftOne(arg);\n\n        this._unshiftOne(receiver);\n\n        this._unshiftOne(fn);\n      };\n\n      Queue.prototype.push = function (fn, receiver, arg) {\n        var length = this.length() + 3;\n\n        if (this._willBeOverCapacity(length)) {\n          this._pushOne(fn);\n\n          this._pushOne(receiver);\n\n          this._pushOne(arg);\n\n          return;\n        }\n\n        var j = this._front + length - 3;\n\n        this._checkCapacity(length);\n\n        var wrapMask = this._capacity - 1;\n        this[j + 0 & wrapMask] = fn;\n        this[j + 1 & wrapMask] = receiver;\n        this[j + 2 & wrapMask] = arg;\n        this._length = length;\n      };\n\n      Queue.prototype.shift = function () {\n        var front = this._front,\n            ret = this[front];\n        this[front] = undefined;\n        this._front = front + 1 & this._capacity - 1;\n        this._length--;\n        return ret;\n      };\n\n      Queue.prototype.length = function () {\n        return this._length;\n      };\n\n      Queue.prototype._checkCapacity = function (size) {\n        if (this._capacity < size) {\n          this._resizeTo(this._capacity << 1);\n        }\n      };\n\n      Queue.prototype._resizeTo = function (capacity) {\n        var oldCapacity = this._capacity;\n        this._capacity = capacity;\n        var front = this._front;\n        var length = this._length;\n        var moveItemsCount = front + length & oldCapacity - 1;\n        arrayMove(this, 0, this, oldCapacity, moveItemsCount);\n      };\n\n      module.exports = Queue;\n    }, {}],\n    29: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise, INTERNAL, tryConvertToPromise, apiRejection) {\n        var isArray = _dereq_(\"./util.js\").isArray;\n\n        var raceLater = function (promise) {\n          return promise.then(function (array) {\n            return race(array, promise);\n          });\n        };\n\n        function race(promises, parent) {\n          var maybePromise = tryConvertToPromise(promises);\n\n          if (maybePromise instanceof Promise) {\n            return raceLater(maybePromise);\n          } else if (!isArray(promises)) {\n            return apiRejection(\"expecting an array, a promise or a thenable\\u000a\\u000a    See http://goo.gl/s8MMhc\\u000a\");\n          }\n\n          var ret = new Promise(INTERNAL);\n\n          if (parent !== undefined) {\n            ret._propagateFrom(parent, 4 | 1);\n          }\n\n          var fulfill = ret._fulfill;\n          var reject = ret._reject;\n\n          for (var i = 0, len = promises.length; i < len; ++i) {\n            var val = promises[i];\n\n            if (val === undefined && !(i in promises)) {\n              continue;\n            }\n\n            Promise.cast(val)._then(fulfill, reject, undefined, ret, null);\n          }\n\n          return ret;\n        }\n\n        Promise.race = function (promises) {\n          return race(promises, undefined);\n        };\n\n        Promise.prototype.race = function () {\n          return race(this, undefined);\n        };\n      };\n    }, {\n      \"./util.js\": 38\n    }],\n    30: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL) {\n        var getDomain = Promise._getDomain;\n\n        var async = _dereq_(\"./async.js\");\n\n        var util = _dereq_(\"./util.js\");\n\n        var tryCatch = util.tryCatch;\n        var errorObj = util.errorObj;\n\n        function ReductionPromiseArray(promises, fn, accum, _each) {\n          this.constructor$(promises);\n\n          this._promise._captureStackTrace();\n\n          this._preservedValues = _each === INTERNAL ? [] : null;\n          this._zerothIsAccum = accum === undefined;\n          this._gotAccum = false;\n          this._reducingIndex = this._zerothIsAccum ? 1 : 0;\n          this._valuesPhase = undefined;\n          var maybePromise = tryConvertToPromise(accum, this._promise);\n          var rejected = false;\n          var isPromise = maybePromise instanceof Promise;\n\n          if (isPromise) {\n            maybePromise = maybePromise._target();\n\n            if (maybePromise._isPending()) {\n              maybePromise._proxyPromiseArray(this, -1);\n            } else if (maybePromise._isFulfilled()) {\n              accum = maybePromise._value();\n              this._gotAccum = true;\n            } else {\n              this._reject(maybePromise._reason());\n\n              rejected = true;\n            }\n          }\n\n          if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;\n          var domain = getDomain();\n          this._callback = domain === null ? fn : domain.bind(fn);\n          this._accum = accum;\n          if (!rejected) async.invoke(init, this, undefined);\n        }\n\n        function init() {\n          this._init$(undefined, -5);\n        }\n\n        util.inherits(ReductionPromiseArray, PromiseArray);\n\n        ReductionPromiseArray.prototype._init = function () {};\n\n        ReductionPromiseArray.prototype._resolveEmptyArray = function () {\n          if (this._gotAccum || this._zerothIsAccum) {\n            this._resolve(this._preservedValues !== null ? [] : this._accum);\n          }\n        };\n\n        ReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {\n          var values = this._values;\n          values[index] = value;\n          var length = this.length();\n          var preservedValues = this._preservedValues;\n          var isEach = preservedValues !== null;\n          var gotAccum = this._gotAccum;\n          var valuesPhase = this._valuesPhase;\n          var valuesPhaseIndex;\n\n          if (!valuesPhase) {\n            valuesPhase = this._valuesPhase = new Array(length);\n\n            for (valuesPhaseIndex = 0; valuesPhaseIndex < length; ++valuesPhaseIndex) {\n              valuesPhase[valuesPhaseIndex] = 0;\n            }\n          }\n\n          valuesPhaseIndex = valuesPhase[index];\n\n          if (index === 0 && this._zerothIsAccum) {\n            this._accum = value;\n            this._gotAccum = gotAccum = true;\n            valuesPhase[index] = valuesPhaseIndex === 0 ? 1 : 2;\n          } else if (index === -1) {\n            this._accum = value;\n            this._gotAccum = gotAccum = true;\n          } else {\n            if (valuesPhaseIndex === 0) {\n              valuesPhase[index] = 1;\n            } else {\n              valuesPhase[index] = 2;\n              this._accum = value;\n            }\n          }\n\n          if (!gotAccum) return;\n          var callback = this._callback;\n\n          var receiver = this._promise._boundValue();\n\n          var ret;\n\n          for (var i = this._reducingIndex; i < length; ++i) {\n            valuesPhaseIndex = valuesPhase[i];\n\n            if (valuesPhaseIndex === 2) {\n              this._reducingIndex = i + 1;\n              continue;\n            }\n\n            if (valuesPhaseIndex !== 1) return;\n            value = values[i];\n\n            this._promise._pushContext();\n\n            if (isEach) {\n              preservedValues.push(value);\n              ret = tryCatch(callback).call(receiver, value, i, length);\n            } else {\n              ret = tryCatch(callback).call(receiver, this._accum, value, i, length);\n            }\n\n            this._promise._popContext();\n\n            if (ret === errorObj) return this._reject(ret.e);\n            var maybePromise = tryConvertToPromise(ret, this._promise);\n\n            if (maybePromise instanceof Promise) {\n              maybePromise = maybePromise._target();\n\n              if (maybePromise._isPending()) {\n                valuesPhase[i] = 4;\n                return maybePromise._proxyPromiseArray(this, i);\n              } else if (maybePromise._isFulfilled()) {\n                ret = maybePromise._value();\n              } else {\n                return this._reject(maybePromise._reason());\n              }\n            }\n\n            this._reducingIndex = i + 1;\n            this._accum = ret;\n          }\n\n          this._resolve(isEach ? preservedValues : this._accum);\n        };\n\n        function reduce(promises, fn, initialValue, _each) {\n          if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n          var array = new ReductionPromiseArray(promises, fn, initialValue, _each);\n          return array.promise();\n        }\n\n        Promise.prototype.reduce = function (fn, initialValue) {\n          return reduce(this, fn, initialValue, null);\n        };\n\n        Promise.reduce = function (promises, fn, initialValue, _each) {\n          return reduce(promises, fn, initialValue, _each);\n        };\n      };\n    }, {\n      \"./async.js\": 2,\n      \"./util.js\": 38\n    }],\n    31: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      var schedule;\n\n      var util = _dereq_(\"./util\");\n\n      var noAsyncScheduler = function () {\n        throw new Error(\"No async scheduler available\\u000a\\u000a    See http://goo.gl/m3OTXk\\u000a\");\n      };\n\n      if (util.isNode && typeof MutationObserver === \"undefined\") {\n        var GlobalSetImmediate = global.setImmediate;\n        var ProcessNextTick = process.nextTick;\n        schedule = util.isRecentNode ? function (fn) {\n          GlobalSetImmediate.call(global, fn);\n        } : function (fn) {\n          ProcessNextTick.call(process, fn);\n        };\n      } else if (typeof MutationObserver !== \"undefined\" && !(typeof window !== \"undefined\" && window.navigator && window.navigator.standalone)) {\n        schedule = function (fn) {\n          var div = document.createElement(\"div\");\n          var observer = new MutationObserver(fn);\n          observer.observe(div, {\n            attributes: true\n          });\n          return function () {\n            div.classList.toggle(\"foo\");\n          };\n        };\n\n        schedule.isStatic = true;\n      } else if (typeof setImmediate !== \"undefined\") {\n        schedule = function (fn) {\n          setImmediate(fn);\n        };\n      } else if (typeof setTimeout !== \"undefined\") {\n        schedule = function (fn) {\n          setTimeout(fn, 0);\n        };\n      } else {\n        schedule = noAsyncScheduler;\n      }\n\n      module.exports = schedule;\n    }, {\n      \"./util\": 38\n    }],\n    32: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise, PromiseArray) {\n        var PromiseInspection = Promise.PromiseInspection;\n\n        var util = _dereq_(\"./util.js\");\n\n        function SettledPromiseArray(values) {\n          this.constructor$(values);\n        }\n\n        util.inherits(SettledPromiseArray, PromiseArray);\n\n        SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {\n          this._values[index] = inspection;\n          var totalResolved = ++this._totalResolved;\n\n          if (totalResolved >= this._length) {\n            this._resolve(this._values);\n          }\n        };\n\n        SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {\n          var ret = new PromiseInspection();\n          ret._bitField = 268435456;\n          ret._settledValue = value;\n\n          this._promiseResolved(index, ret);\n        };\n\n        SettledPromiseArray.prototype._promiseRejected = function (reason, index) {\n          var ret = new PromiseInspection();\n          ret._bitField = 134217728;\n          ret._settledValue = reason;\n\n          this._promiseResolved(index, ret);\n        };\n\n        Promise.settle = function (promises) {\n          return new SettledPromiseArray(promises).promise();\n        };\n\n        Promise.prototype.settle = function () {\n          return new SettledPromiseArray(this).promise();\n        };\n      };\n    }, {\n      \"./util.js\": 38\n    }],\n    33: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise, PromiseArray, apiRejection) {\n        var util = _dereq_(\"./util.js\");\n\n        var RangeError = _dereq_(\"./errors.js\").RangeError;\n\n        var AggregateError = _dereq_(\"./errors.js\").AggregateError;\n\n        var isArray = util.isArray;\n\n        function SomePromiseArray(values) {\n          this.constructor$(values);\n          this._howMany = 0;\n          this._unwrap = false;\n          this._initialized = false;\n        }\n\n        util.inherits(SomePromiseArray, PromiseArray);\n\n        SomePromiseArray.prototype._init = function () {\n          if (!this._initialized) {\n            return;\n          }\n\n          if (this._howMany === 0) {\n            this._resolve([]);\n\n            return;\n          }\n\n          this._init$(undefined, -5);\n\n          var isArrayResolved = isArray(this._values);\n\n          if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {\n            this._reject(this._getRangeError(this.length()));\n          }\n        };\n\n        SomePromiseArray.prototype.init = function () {\n          this._initialized = true;\n\n          this._init();\n        };\n\n        SomePromiseArray.prototype.setUnwrap = function () {\n          this._unwrap = true;\n        };\n\n        SomePromiseArray.prototype.howMany = function () {\n          return this._howMany;\n        };\n\n        SomePromiseArray.prototype.setHowMany = function (count) {\n          this._howMany = count;\n        };\n\n        SomePromiseArray.prototype._promiseFulfilled = function (value) {\n          this._addFulfilled(value);\n\n          if (this._fulfilled() === this.howMany()) {\n            this._values.length = this.howMany();\n\n            if (this.howMany() === 1 && this._unwrap) {\n              this._resolve(this._values[0]);\n            } else {\n              this._resolve(this._values);\n            }\n          }\n        };\n\n        SomePromiseArray.prototype._promiseRejected = function (reason) {\n          this._addRejected(reason);\n\n          if (this.howMany() > this._canPossiblyFulfill()) {\n            var e = new AggregateError();\n\n            for (var i = this.length(); i < this._values.length; ++i) {\n              e.push(this._values[i]);\n            }\n\n            this._reject(e);\n          }\n        };\n\n        SomePromiseArray.prototype._fulfilled = function () {\n          return this._totalResolved;\n        };\n\n        SomePromiseArray.prototype._rejected = function () {\n          return this._values.length - this.length();\n        };\n\n        SomePromiseArray.prototype._addRejected = function (reason) {\n          this._values.push(reason);\n        };\n\n        SomePromiseArray.prototype._addFulfilled = function (value) {\n          this._values[this._totalResolved++] = value;\n        };\n\n        SomePromiseArray.prototype._canPossiblyFulfill = function () {\n          return this.length() - this._rejected();\n        };\n\n        SomePromiseArray.prototype._getRangeError = function (count) {\n          var message = \"Input array must contain at least \" + this._howMany + \" items but contains only \" + count + \" items\";\n          return new RangeError(message);\n        };\n\n        SomePromiseArray.prototype._resolveEmptyArray = function () {\n          this._reject(this._getRangeError(0));\n        };\n\n        function some(promises, howMany) {\n          if ((howMany | 0) !== howMany || howMany < 0) {\n            return apiRejection(\"expecting a positive integer\\u000a\\u000a    See http://goo.gl/1wAmHx\\u000a\");\n          }\n\n          var ret = new SomePromiseArray(promises);\n          var promise = ret.promise();\n          ret.setHowMany(howMany);\n          ret.init();\n          return promise;\n        }\n\n        Promise.some = function (promises, howMany) {\n          return some(promises, howMany);\n        };\n\n        Promise.prototype.some = function (howMany) {\n          return some(this, howMany);\n        };\n\n        Promise._SomePromiseArray = SomePromiseArray;\n      };\n    }, {\n      \"./errors.js\": 13,\n      \"./util.js\": 38\n    }],\n    34: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise) {\n        function PromiseInspection(promise) {\n          if (promise !== undefined) {\n            promise = promise._target();\n            this._bitField = promise._bitField;\n            this._settledValue = promise._settledValue;\n          } else {\n            this._bitField = 0;\n            this._settledValue = undefined;\n          }\n        }\n\n        PromiseInspection.prototype.value = function () {\n          if (!this.isFulfilled()) {\n            throw new TypeError(\"cannot get fulfillment value of a non-fulfilled promise\\u000a\\u000a    See http://goo.gl/hc1DLj\\u000a\");\n          }\n\n          return this._settledValue;\n        };\n\n        PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function () {\n          if (!this.isRejected()) {\n            throw new TypeError(\"cannot get rejection reason of a non-rejected promise\\u000a\\u000a    See http://goo.gl/hPuiwB\\u000a\");\n          }\n\n          return this._settledValue;\n        };\n\n        PromiseInspection.prototype.isFulfilled = Promise.prototype._isFulfilled = function () {\n          return (this._bitField & 268435456) > 0;\n        };\n\n        PromiseInspection.prototype.isRejected = Promise.prototype._isRejected = function () {\n          return (this._bitField & 134217728) > 0;\n        };\n\n        PromiseInspection.prototype.isPending = Promise.prototype._isPending = function () {\n          return (this._bitField & 402653184) === 0;\n        };\n\n        PromiseInspection.prototype.isResolved = Promise.prototype._isResolved = function () {\n          return (this._bitField & 402653184) > 0;\n        };\n\n        Promise.prototype.isPending = function () {\n          return this._target()._isPending();\n        };\n\n        Promise.prototype.isRejected = function () {\n          return this._target()._isRejected();\n        };\n\n        Promise.prototype.isFulfilled = function () {\n          return this._target()._isFulfilled();\n        };\n\n        Promise.prototype.isResolved = function () {\n          return this._target()._isResolved();\n        };\n\n        Promise.prototype._value = function () {\n          return this._settledValue;\n        };\n\n        Promise.prototype._reason = function () {\n          this._unsetRejectionIsUnhandled();\n\n          return this._settledValue;\n        };\n\n        Promise.prototype.value = function () {\n          var target = this._target();\n\n          if (!target.isFulfilled()) {\n            throw new TypeError(\"cannot get fulfillment value of a non-fulfilled promise\\u000a\\u000a    See http://goo.gl/hc1DLj\\u000a\");\n          }\n\n          return target._settledValue;\n        };\n\n        Promise.prototype.reason = function () {\n          var target = this._target();\n\n          if (!target.isRejected()) {\n            throw new TypeError(\"cannot get rejection reason of a non-rejected promise\\u000a\\u000a    See http://goo.gl/hPuiwB\\u000a\");\n          }\n\n          target._unsetRejectionIsUnhandled();\n\n          return target._settledValue;\n        };\n\n        Promise.PromiseInspection = PromiseInspection;\n      };\n    }, {}],\n    35: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise, INTERNAL) {\n        var util = _dereq_(\"./util.js\");\n\n        var errorObj = util.errorObj;\n        var isObject = util.isObject;\n\n        function tryConvertToPromise(obj, context) {\n          if (isObject(obj)) {\n            if (obj instanceof Promise) {\n              return obj;\n            } else if (isAnyBluebirdPromise(obj)) {\n              var ret = new Promise(INTERNAL);\n\n              obj._then(ret._fulfillUnchecked, ret._rejectUncheckedCheckError, ret._progressUnchecked, ret, null);\n\n              return ret;\n            }\n\n            var then = util.tryCatch(getThen)(obj);\n\n            if (then === errorObj) {\n              if (context) context._pushContext();\n              var ret = Promise.reject(then.e);\n              if (context) context._popContext();\n              return ret;\n            } else if (typeof then === \"function\") {\n              return doThenable(obj, then, context);\n            }\n          }\n\n          return obj;\n        }\n\n        function getThen(obj) {\n          return obj.then;\n        }\n\n        var hasProp = {}.hasOwnProperty;\n\n        function isAnyBluebirdPromise(obj) {\n          return hasProp.call(obj, \"_promise0\");\n        }\n\n        function doThenable(x, then, context) {\n          var promise = new Promise(INTERNAL);\n          var ret = promise;\n          if (context) context._pushContext();\n\n          promise._captureStackTrace();\n\n          if (context) context._popContext();\n          var synchronous = true;\n          var result = util.tryCatch(then).call(x, resolveFromThenable, rejectFromThenable, progressFromThenable);\n          synchronous = false;\n\n          if (promise && result === errorObj) {\n            promise._rejectCallback(result.e, true, true);\n\n            promise = null;\n          }\n\n          function resolveFromThenable(value) {\n            if (!promise) return;\n\n            promise._resolveCallback(value);\n\n            promise = null;\n          }\n\n          function rejectFromThenable(reason) {\n            if (!promise) return;\n\n            promise._rejectCallback(reason, synchronous, true);\n\n            promise = null;\n          }\n\n          function progressFromThenable(value) {\n            if (!promise) return;\n\n            if (typeof promise._progress === \"function\") {\n              promise._progress(value);\n            }\n          }\n\n          return ret;\n        }\n\n        return tryConvertToPromise;\n      };\n    }, {\n      \"./util.js\": 38\n    }],\n    36: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise, INTERNAL) {\n        var util = _dereq_(\"./util.js\");\n\n        var TimeoutError = Promise.TimeoutError;\n\n        var afterTimeout = function (promise, message) {\n          if (!promise.isPending()) return;\n          var err;\n\n          if (!util.isPrimitive(message) && message instanceof Error) {\n            err = message;\n          } else {\n            if (typeof message !== \"string\") {\n              message = \"operation timed out\";\n            }\n\n            err = new TimeoutError(message);\n          }\n\n          util.markAsOriginatingFromRejection(err);\n\n          promise._attachExtraTrace(err);\n\n          promise._cancel(err);\n        };\n\n        var afterValue = function (value) {\n          return delay(+this).thenReturn(value);\n        };\n\n        var delay = Promise.delay = function (value, ms) {\n          if (ms === undefined) {\n            ms = value;\n            value = undefined;\n            var ret = new Promise(INTERNAL);\n            setTimeout(function () {\n              ret._fulfill();\n            }, ms);\n            return ret;\n          }\n\n          ms = +ms;\n          return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);\n        };\n\n        Promise.prototype.delay = function (ms) {\n          return delay(this, ms);\n        };\n\n        function successClear(value) {\n          var handle = this;\n          if (handle instanceof Number) handle = +handle;\n          clearTimeout(handle);\n          return value;\n        }\n\n        function failureClear(reason) {\n          var handle = this;\n          if (handle instanceof Number) handle = +handle;\n          clearTimeout(handle);\n          throw reason;\n        }\n\n        Promise.prototype.timeout = function (ms, message) {\n          ms = +ms;\n          var ret = this.then().cancellable();\n          ret._cancellationParent = this;\n          var handle = setTimeout(function timeoutTimeout() {\n            afterTimeout(ret, message);\n          }, ms);\n          return ret._then(successClear, failureClear, undefined, handle, undefined);\n        };\n      };\n    }, {\n      \"./util.js\": 38\n    }],\n    37: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      module.exports = function (Promise, apiRejection, tryConvertToPromise, createContext) {\n        var TypeError = _dereq_(\"./errors.js\").TypeError;\n\n        var inherits = _dereq_(\"./util.js\").inherits;\n\n        var PromiseInspection = Promise.PromiseInspection;\n\n        function inspectionMapper(inspections) {\n          var len = inspections.length;\n\n          for (var i = 0; i < len; ++i) {\n            var inspection = inspections[i];\n\n            if (inspection.isRejected()) {\n              return Promise.reject(inspection.error());\n            }\n\n            inspections[i] = inspection._settledValue;\n          }\n\n          return inspections;\n        }\n\n        function thrower(e) {\n          setTimeout(function () {\n            throw e;\n          }, 0);\n        }\n\n        function castPreservingDisposable(thenable) {\n          var maybePromise = tryConvertToPromise(thenable);\n\n          if (maybePromise !== thenable && typeof thenable._isDisposable === \"function\" && typeof thenable._getDisposer === \"function\" && thenable._isDisposable()) {\n            maybePromise._setDisposable(thenable._getDisposer());\n          }\n\n          return maybePromise;\n        }\n\n        function dispose(resources, inspection) {\n          var i = 0;\n          var len = resources.length;\n          var ret = Promise.defer();\n\n          function iterator() {\n            if (i >= len) return ret.resolve();\n            var maybePromise = castPreservingDisposable(resources[i++]);\n\n            if (maybePromise instanceof Promise && maybePromise._isDisposable()) {\n              try {\n                maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);\n              } catch (e) {\n                return thrower(e);\n              }\n\n              if (maybePromise instanceof Promise) {\n                return maybePromise._then(iterator, thrower, null, null, null);\n              }\n            }\n\n            iterator();\n          }\n\n          iterator();\n          return ret.promise;\n        }\n\n        function disposerSuccess(value) {\n          var inspection = new PromiseInspection();\n          inspection._settledValue = value;\n          inspection._bitField = 268435456;\n          return dispose(this, inspection).thenReturn(value);\n        }\n\n        function disposerFail(reason) {\n          var inspection = new PromiseInspection();\n          inspection._settledValue = reason;\n          inspection._bitField = 134217728;\n          return dispose(this, inspection).thenThrow(reason);\n        }\n\n        function Disposer(data, promise, context) {\n          this._data = data;\n          this._promise = promise;\n          this._context = context;\n        }\n\n        Disposer.prototype.data = function () {\n          return this._data;\n        };\n\n        Disposer.prototype.promise = function () {\n          return this._promise;\n        };\n\n        Disposer.prototype.resource = function () {\n          if (this.promise().isFulfilled()) {\n            return this.promise().value();\n          }\n\n          return null;\n        };\n\n        Disposer.prototype.tryDispose = function (inspection) {\n          var resource = this.resource();\n          var context = this._context;\n          if (context !== undefined) context._pushContext();\n          var ret = resource !== null ? this.doDispose(resource, inspection) : null;\n          if (context !== undefined) context._popContext();\n\n          this._promise._unsetDisposable();\n\n          this._data = null;\n          return ret;\n        };\n\n        Disposer.isDisposer = function (d) {\n          return d != null && typeof d.resource === \"function\" && typeof d.tryDispose === \"function\";\n        };\n\n        function FunctionDisposer(fn, promise, context) {\n          this.constructor$(fn, promise, context);\n        }\n\n        inherits(FunctionDisposer, Disposer);\n\n        FunctionDisposer.prototype.doDispose = function (resource, inspection) {\n          var fn = this.data();\n          return fn.call(resource, resource, inspection);\n        };\n\n        function maybeUnwrapDisposer(value) {\n          if (Disposer.isDisposer(value)) {\n            this.resources[this.index]._setDisposable(value);\n\n            return value.promise();\n          }\n\n          return value;\n        }\n\n        Promise.using = function () {\n          var len = arguments.length;\n          if (len < 2) return apiRejection(\"you must pass at least 2 arguments to Promise.using\");\n          var fn = arguments[len - 1];\n          if (typeof fn !== \"function\") return apiRejection(\"fn must be a function\\u000a\\u000a    See http://goo.gl/916lJJ\\u000a\");\n          var input;\n          var spreadArgs = true;\n\n          if (len === 2 && Array.isArray(arguments[0])) {\n            input = arguments[0];\n            len = input.length;\n            spreadArgs = false;\n          } else {\n            input = arguments;\n            len--;\n          }\n\n          var resources = new Array(len);\n\n          for (var i = 0; i < len; ++i) {\n            var resource = input[i];\n\n            if (Disposer.isDisposer(resource)) {\n              var disposer = resource;\n              resource = resource.promise();\n\n              resource._setDisposable(disposer);\n            } else {\n              var maybePromise = tryConvertToPromise(resource);\n\n              if (maybePromise instanceof Promise) {\n                resource = maybePromise._then(maybeUnwrapDisposer, null, null, {\n                  resources: resources,\n                  index: i\n                }, undefined);\n              }\n            }\n\n            resources[i] = resource;\n          }\n\n          var promise = Promise.settle(resources).then(inspectionMapper).then(function (vals) {\n            promise._pushContext();\n\n            var ret;\n\n            try {\n              ret = spreadArgs ? fn.apply(undefined, vals) : fn.call(undefined, vals);\n            } finally {\n              promise._popContext();\n            }\n\n            return ret;\n          })._then(disposerSuccess, disposerFail, undefined, resources, undefined);\n\n          resources.promise = promise;\n          return promise;\n        };\n\n        Promise.prototype._setDisposable = function (disposer) {\n          this._bitField = this._bitField | 262144;\n          this._disposer = disposer;\n        };\n\n        Promise.prototype._isDisposable = function () {\n          return (this._bitField & 262144) > 0;\n        };\n\n        Promise.prototype._getDisposer = function () {\n          return this._disposer;\n        };\n\n        Promise.prototype._unsetDisposable = function () {\n          this._bitField = this._bitField & ~262144;\n          this._disposer = undefined;\n        };\n\n        Promise.prototype.disposer = function (fn) {\n          if (typeof fn === \"function\") {\n            return new FunctionDisposer(fn, this, createContext());\n          }\n\n          throw new TypeError();\n        };\n      };\n    }, {\n      \"./errors.js\": 13,\n      \"./util.js\": 38\n    }],\n    38: [function (_dereq_, module, exports) {\n      \"use strict\";\n\n      var es5 = _dereq_(\"./es5.js\");\n\n      var canEvaluate = typeof navigator == \"undefined\";\n\n      var haveGetters = function () {\n        try {\n          var o = {};\n          es5.defineProperty(o, \"f\", {\n            get: function () {\n              return 3;\n            }\n          });\n          return o.f === 3;\n        } catch (e) {\n          return false;\n        }\n      }();\n\n      var errorObj = {\n        e: {}\n      };\n      var tryCatchTarget;\n\n      function tryCatcher() {\n        try {\n          var target = tryCatchTarget;\n          tryCatchTarget = null;\n          return target.apply(this, arguments);\n        } catch (e) {\n          errorObj.e = e;\n          return errorObj;\n        }\n      }\n\n      function tryCatch(fn) {\n        tryCatchTarget = fn;\n        return tryCatcher;\n      }\n\n      var inherits = function (Child, Parent) {\n        var hasProp = {}.hasOwnProperty;\n\n        function T() {\n          this.constructor = Child;\n          this.constructor$ = Parent;\n\n          for (var propertyName in Parent.prototype) {\n            if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== \"$\") {\n              this[propertyName + \"$\"] = Parent.prototype[propertyName];\n            }\n          }\n        }\n\n        T.prototype = Parent.prototype;\n        Child.prototype = new T();\n        return Child.prototype;\n      };\n\n      function isPrimitive(val) {\n        return val == null || val === true || val === false || typeof val === \"string\" || typeof val === \"number\";\n      }\n\n      function isObject(value) {\n        return !isPrimitive(value);\n      }\n\n      function maybeWrapAsError(maybeError) {\n        if (!isPrimitive(maybeError)) return maybeError;\n        return new Error(safeToString(maybeError));\n      }\n\n      function withAppended(target, appendee) {\n        var len = target.length;\n        var ret = new Array(len + 1);\n        var i;\n\n        for (i = 0; i < len; ++i) {\n          ret[i] = target[i];\n        }\n\n        ret[i] = appendee;\n        return ret;\n      }\n\n      function getDataPropertyOrDefault(obj, key, defaultValue) {\n        if (es5.isES5) {\n          var desc = Object.getOwnPropertyDescriptor(obj, key);\n\n          if (desc != null) {\n            return desc.get == null && desc.set == null ? desc.value : defaultValue;\n          }\n        } else {\n          return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;\n        }\n      }\n\n      function notEnumerableProp(obj, name, value) {\n        if (isPrimitive(obj)) return obj;\n        var descriptor = {\n          value: value,\n          configurable: true,\n          enumerable: false,\n          writable: true\n        };\n        es5.defineProperty(obj, name, descriptor);\n        return obj;\n      }\n\n      function thrower(r) {\n        throw r;\n      }\n\n      var inheritedDataKeys = function () {\n        var excludedPrototypes = [Array.prototype, Object.prototype, Function.prototype];\n\n        var isExcludedProto = function (val) {\n          for (var i = 0; i < excludedPrototypes.length; ++i) {\n            if (excludedPrototypes[i] === val) {\n              return true;\n            }\n          }\n\n          return false;\n        };\n\n        if (es5.isES5) {\n          var getKeys = Object.getOwnPropertyNames;\n          return function (obj) {\n            var ret = [];\n            var visitedKeys = Object.create(null);\n\n            while (obj != null && !isExcludedProto(obj)) {\n              var keys;\n\n              try {\n                keys = getKeys(obj);\n              } catch (e) {\n                return ret;\n              }\n\n              for (var i = 0; i < keys.length; ++i) {\n                var key = keys[i];\n                if (visitedKeys[key]) continue;\n                visitedKeys[key] = true;\n                var desc = Object.getOwnPropertyDescriptor(obj, key);\n\n                if (desc != null && desc.get == null && desc.set == null) {\n                  ret.push(key);\n                }\n              }\n\n              obj = es5.getPrototypeOf(obj);\n            }\n\n            return ret;\n          };\n        } else {\n          var hasProp = {}.hasOwnProperty;\n          return function (obj) {\n            if (isExcludedProto(obj)) return [];\n            var ret = [];\n            /*jshint forin:false */\n\n            enumeration: for (var key in obj) {\n              if (hasProp.call(obj, key)) {\n                ret.push(key);\n              } else {\n                for (var i = 0; i < excludedPrototypes.length; ++i) {\n                  if (hasProp.call(excludedPrototypes[i], key)) {\n                    continue enumeration;\n                  }\n                }\n\n                ret.push(key);\n              }\n            }\n\n            return ret;\n          };\n        }\n      }();\n\n      var thisAssignmentPattern = /this\\s*\\.\\s*\\S+\\s*=/;\n\n      function isClass(fn) {\n        try {\n          if (typeof fn === \"function\") {\n            var keys = es5.names(fn.prototype);\n            var hasMethods = es5.isES5 && keys.length > 1;\n            var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === \"constructor\");\n            var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + \"\") && es5.names(fn).length > 0;\n\n            if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {\n              return true;\n            }\n          }\n\n          return false;\n        } catch (e) {\n          return false;\n        }\n      }\n\n      function toFastProperties(obj) {\n        /*jshint -W027,-W055,-W031*/\n        function f() {}\n\n        f.prototype = obj;\n        var l = 8;\n\n        while (l--) new f();\n\n        return obj;\n        eval(obj);\n      }\n\n      var rident = /^[a-z$_][a-z$_0-9]*$/i;\n\n      function isIdentifier(str) {\n        return rident.test(str);\n      }\n\n      function filledRange(count, prefix, suffix) {\n        var ret = new Array(count);\n\n        for (var i = 0; i < count; ++i) {\n          ret[i] = prefix + i + suffix;\n        }\n\n        return ret;\n      }\n\n      function safeToString(obj) {\n        try {\n          return obj + \"\";\n        } catch (e) {\n          return \"[no string representation]\";\n        }\n      }\n\n      function markAsOriginatingFromRejection(e) {\n        try {\n          notEnumerableProp(e, \"isOperational\", true);\n        } catch (ignore) {}\n      }\n\n      function originatesFromRejection(e) {\n        if (e == null) return false;\n        return e instanceof Error[\"__BluebirdErrorTypes__\"].OperationalError || e[\"isOperational\"] === true;\n      }\n\n      function canAttachTrace(obj) {\n        return obj instanceof Error && es5.propertyIsWritable(obj, \"stack\");\n      }\n\n      var ensureErrorObject = function () {\n        if (!(\"stack\" in new Error())) {\n          return function (value) {\n            if (canAttachTrace(value)) return value;\n\n            try {\n              throw new Error(safeToString(value));\n            } catch (err) {\n              return err;\n            }\n          };\n        } else {\n          return function (value) {\n            if (canAttachTrace(value)) return value;\n            return new Error(safeToString(value));\n          };\n        }\n      }();\n\n      function classString(obj) {\n        return {}.toString.call(obj);\n      }\n\n      function copyDescriptors(from, to, filter) {\n        var keys = es5.names(from);\n\n        for (var i = 0; i < keys.length; ++i) {\n          var key = keys[i];\n\n          if (filter(key)) {\n            try {\n              es5.defineProperty(to, key, es5.getDescriptor(from, key));\n            } catch (ignore) {}\n          }\n        }\n      }\n\n      var ret = {\n        isClass: isClass,\n        isIdentifier: isIdentifier,\n        inheritedDataKeys: inheritedDataKeys,\n        getDataPropertyOrDefault: getDataPropertyOrDefault,\n        thrower: thrower,\n        isArray: es5.isArray,\n        haveGetters: haveGetters,\n        notEnumerableProp: notEnumerableProp,\n        isPrimitive: isPrimitive,\n        isObject: isObject,\n        canEvaluate: canEvaluate,\n        errorObj: errorObj,\n        tryCatch: tryCatch,\n        inherits: inherits,\n        withAppended: withAppended,\n        maybeWrapAsError: maybeWrapAsError,\n        toFastProperties: toFastProperties,\n        filledRange: filledRange,\n        toString: safeToString,\n        canAttachTrace: canAttachTrace,\n        ensureErrorObject: ensureErrorObject,\n        originatesFromRejection: originatesFromRejection,\n        markAsOriginatingFromRejection: markAsOriginatingFromRejection,\n        classString: classString,\n        copyDescriptors: copyDescriptors,\n        hasDevTools: typeof chrome !== \"undefined\" && chrome && typeof chrome.loadTimes === \"function\",\n        isNode: typeof process !== \"undefined\" && classString(process).toLowerCase() === \"[object process]\"\n      };\n\n      ret.isRecentNode = ret.isNode && function () {\n        var version = process.versions.node.split(\".\").map(Number);\n        return version[0] === 0 && version[1] > 10 || version[0] > 0;\n      }();\n\n      if (ret.isNode) ret.toFastProperties(process);\n\n      try {\n        throw new Error();\n      } catch (e) {\n        ret.lastLineError = e;\n      }\n\n      module.exports = ret;\n    }, {\n      \"./es5.js\": 14\n    }]\n  }, {}, [4])(4);\n});\n;\n\nif (typeof window !== 'undefined' && window !== null) {\n  window.P = window.Promise;\n} else if (typeof self !== 'undefined' && self !== null) {\n  self.P = self.Promise;\n}","map":null,"metadata":{},"sourceType":"script"}