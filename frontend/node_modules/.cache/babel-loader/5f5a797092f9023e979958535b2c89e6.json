{"ast":null,"code":"/**\n * Binary Parser.\n * Jonas Raoni Soares Silva\n * http://jsfromhell.com/classes/binary-parser [v1.0]\n */\nvar chr = String.fromCharCode;\nvar maxBits = [];\n\nfor (var i = 0; i < 64; i++) {\n  maxBits[i] = Math.pow(2, i);\n}\n\nfunction BinaryParser(bigEndian, allowExceptions) {\n  if (!(this instanceof BinaryParser)) return new BinaryParser(bigEndian, allowExceptions);\n  this.bigEndian = bigEndian;\n  this.allowExceptions = allowExceptions;\n}\n\n;\n\nBinaryParser.warn = function warn(msg) {\n  if (this.allowExceptions) {\n    throw new Error(msg);\n  }\n\n  return 1;\n};\n\nBinaryParser.decodeFloat = function decodeFloat(data, precisionBits, exponentBits) {\n  var b = new this.Buffer(this.bigEndian, data);\n  b.checkBuffer(precisionBits + exponentBits + 1);\n  var bias = maxBits[exponentBits - 1] - 1,\n      signal = b.readBits(precisionBits + exponentBits, 1),\n      exponent = b.readBits(precisionBits, exponentBits),\n      significand = 0,\n      divisor = 2,\n      curByte = b.buffer.length + (-precisionBits >> 3) - 1;\n\n  do {\n    for (var byteValue = b.buffer[++curByte], startBit = precisionBits % 8 || 8, mask = 1 << startBit; mask >>= 1; byteValue & mask && (significand += 1 / divisor), divisor *= 2);\n  } while (precisionBits -= startBit);\n\n  return exponent == (bias << 1) + 1 ? significand ? NaN : signal ? -Infinity : +Infinity : (1 + signal * -2) * (exponent || significand ? !exponent ? Math.pow(2, -bias + 1) * significand : Math.pow(2, exponent - bias) * (1 + significand) : 0);\n};\n\nBinaryParser.decodeInt = function decodeInt(data, bits, signed, forceBigEndian) {\n  var b = new this.Buffer(this.bigEndian || forceBigEndian, data),\n      x = b.readBits(0, bits),\n      max = maxBits[bits]; //max = Math.pow( 2, bits );\n\n  return signed && x >= max / 2 ? x - max : x;\n};\n\nBinaryParser.encodeFloat = function encodeFloat(data, precisionBits, exponentBits) {\n  var bias = maxBits[exponentBits - 1] - 1,\n      minExp = -bias + 1,\n      maxExp = bias,\n      minUnnormExp = minExp - precisionBits,\n      n = parseFloat(data),\n      status = isNaN(n) || n == -Infinity || n == +Infinity ? n : 0,\n      exp = 0,\n      len = 2 * bias + 1 + precisionBits + 3,\n      bin = new Array(len),\n      signal = (n = status !== 0 ? 0 : n) < 0,\n      intPart = Math.floor(n = Math.abs(n)),\n      floatPart = n - intPart,\n      lastBit,\n      rounded,\n      result,\n      i,\n      j;\n\n  for (i = len; i; bin[--i] = 0);\n\n  for (i = bias + 2; intPart && i; bin[--i] = intPart % 2, intPart = Math.floor(intPart / 2));\n\n  for (i = bias + 1; floatPart > 0 && i; (bin[++i] = ((floatPart *= 2) >= 1) - 0) && --floatPart);\n\n  for (i = -1; ++i < len && !bin[i];);\n\n  if (bin[(lastBit = precisionBits - 1 + (i = (exp = bias + 1 - i) >= minExp && exp <= maxExp ? i + 1 : bias + 1 - (exp = minExp - 1))) + 1]) {\n    if (!(rounded = bin[lastBit])) {\n      for (j = lastBit + 2; !rounded && j < len; rounded = bin[j++]);\n    }\n\n    for (j = lastBit + 1; rounded && --j >= 0; (bin[j] = !bin[j] - 0) && (rounded = 0));\n  }\n\n  for (i = i - 2 < 0 ? -1 : i - 3; ++i < len && !bin[i];);\n\n  if ((exp = bias + 1 - i) >= minExp && exp <= maxExp) {\n    ++i;\n  } else if (exp < minExp) {\n    exp != bias + 1 - len && exp < minUnnormExp && this.warn(\"encodeFloat::float underflow\");\n    i = bias + 1 - (exp = minExp - 1);\n  }\n\n  if (intPart || status !== 0) {\n    this.warn(intPart ? \"encodeFloat::float overflow\" : \"encodeFloat::\" + status);\n    exp = maxExp + 1;\n    i = bias + 2;\n\n    if (status == -Infinity) {\n      signal = 1;\n    } else if (isNaN(status)) {\n      bin[i] = 1;\n    }\n  }\n\n  for (n = Math.abs(exp + bias), j = exponentBits + 1, result = \"\"; --j; result = n % 2 + result, n = n >>= 1);\n\n  for (n = 0, j = 0, i = (result = (signal ? \"1\" : \"0\") + result + bin.slice(i, i + precisionBits).join(\"\")).length, r = []; i; j = (j + 1) % 8) {\n    n += (1 << j) * result.charAt(--i);\n\n    if (j == 7) {\n      r[r.length] = String.fromCharCode(n);\n      n = 0;\n    }\n  }\n\n  r[r.length] = n ? String.fromCharCode(n) : \"\";\n  return (this.bigEndian ? r.reverse() : r).join(\"\");\n};\n\nBinaryParser.encodeInt = function encodeInt(data, bits, signed, forceBigEndian) {\n  var max = maxBits[bits];\n\n  if (data >= max || data < -(max / 2)) {\n    this.warn(\"encodeInt::overflow\");\n    data = 0;\n  }\n\n  if (data < 0) {\n    data += max;\n  }\n\n  for (var r = []; data; r[r.length] = String.fromCharCode(data % 256), data = Math.floor(data / 256));\n\n  for (bits = -(-bits >> 3) - r.length; bits--; r[r.length] = \"\\0\");\n\n  return (this.bigEndian || forceBigEndian ? r.reverse() : r).join(\"\");\n};\n\nBinaryParser.toSmall = function (data) {\n  return this.decodeInt(data, 8, true);\n};\n\nBinaryParser.fromSmall = function (data) {\n  return this.encodeInt(data, 8, true);\n};\n\nBinaryParser.toByte = function (data) {\n  return this.decodeInt(data, 8, false);\n};\n\nBinaryParser.fromByte = function (data) {\n  return this.encodeInt(data, 8, false);\n};\n\nBinaryParser.toShort = function (data) {\n  return this.decodeInt(data, 16, true);\n};\n\nBinaryParser.fromShort = function (data) {\n  return this.encodeInt(data, 16, true);\n};\n\nBinaryParser.toWord = function (data) {\n  return this.decodeInt(data, 16, false);\n};\n\nBinaryParser.fromWord = function (data) {\n  return this.encodeInt(data, 16, false);\n};\n\nBinaryParser.toInt = function (data) {\n  return this.decodeInt(data, 32, true);\n};\n\nBinaryParser.fromInt = function (data) {\n  return this.encodeInt(data, 32, true);\n};\n\nBinaryParser.toLong = function (data) {\n  return this.decodeInt(data, 64, true);\n};\n\nBinaryParser.fromLong = function (data) {\n  return this.encodeInt(data, 64, true);\n};\n\nBinaryParser.toDWord = function (data) {\n  return this.decodeInt(data, 32, false);\n};\n\nBinaryParser.fromDWord = function (data) {\n  return this.encodeInt(data, 32, false);\n};\n\nBinaryParser.toQWord = function (data) {\n  return this.decodeInt(data, 64, true);\n};\n\nBinaryParser.fromQWord = function (data) {\n  return this.encodeInt(data, 64, true);\n};\n\nBinaryParser.toFloat = function (data) {\n  return this.decodeFloat(data, 23, 8);\n};\n\nBinaryParser.fromFloat = function (data) {\n  return this.encodeFloat(data, 23, 8);\n};\n\nBinaryParser.toDouble = function (data) {\n  return this.decodeFloat(data, 52, 11);\n};\n\nBinaryParser.fromDouble = function (data) {\n  return this.encodeFloat(data, 52, 11);\n}; // Factor out the encode so it can be shared by add_header and push_int32\n\n\nBinaryParser.encode_int32 = function encode_int32(number, asArray) {\n  var a, b, c, d, unsigned;\n  unsigned = number < 0 ? number + 0x100000000 : number;\n  a = Math.floor(unsigned / 0xffffff);\n  unsigned &= 0xffffff;\n  b = Math.floor(unsigned / 0xffff);\n  unsigned &= 0xffff;\n  c = Math.floor(unsigned / 0xff);\n  unsigned &= 0xff;\n  d = Math.floor(unsigned);\n  return asArray ? [chr(a), chr(b), chr(c), chr(d)] : chr(a) + chr(b) + chr(c) + chr(d);\n};\n\nBinaryParser.encode_int64 = function encode_int64(number) {\n  var a, b, c, d, e, f, g, h, unsigned;\n  unsigned = number < 0 ? number + 0x10000000000000000 : number;\n  a = Math.floor(unsigned / 0xffffffffffffff);\n  unsigned &= 0xffffffffffffff;\n  b = Math.floor(unsigned / 0xffffffffffff);\n  unsigned &= 0xffffffffffff;\n  c = Math.floor(unsigned / 0xffffffffff);\n  unsigned &= 0xffffffffff;\n  d = Math.floor(unsigned / 0xffffffff);\n  unsigned &= 0xffffffff;\n  e = Math.floor(unsigned / 0xffffff);\n  unsigned &= 0xffffff;\n  f = Math.floor(unsigned / 0xffff);\n  unsigned &= 0xffff;\n  g = Math.floor(unsigned / 0xff);\n  unsigned &= 0xff;\n  h = Math.floor(unsigned);\n  return chr(a) + chr(b) + chr(c) + chr(d) + chr(e) + chr(f) + chr(g) + chr(h);\n};\n/**\n * UTF8 methods\n */\n// Take a raw binary string and return a utf8 string\n\n\nBinaryParser.decode_utf8 = function decode_utf8(binaryStr) {\n  var len = binaryStr.length,\n      decoded = '',\n      i = 0,\n      c = 0,\n      c1 = 0,\n      c2 = 0,\n      c3;\n\n  while (i < len) {\n    c = binaryStr.charCodeAt(i);\n\n    if (c < 128) {\n      decoded += String.fromCharCode(c);\n      i++;\n    } else if (c > 191 && c < 224) {\n      c2 = binaryStr.charCodeAt(i + 1);\n      decoded += String.fromCharCode((c & 31) << 6 | c2 & 63);\n      i += 2;\n    } else {\n      c2 = binaryStr.charCodeAt(i + 1);\n      c3 = binaryStr.charCodeAt(i + 2);\n      decoded += String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63);\n      i += 3;\n    }\n  }\n\n  return decoded;\n}; // Encode a cstring\n\n\nBinaryParser.encode_cstring = function encode_cstring(s) {\n  return unescape(encodeURIComponent(s)) + BinaryParser.fromByte(0);\n}; // Take a utf8 string and return a binary string\n\n\nBinaryParser.encode_utf8 = function encode_utf8(s) {\n  var a = \"\",\n      c;\n\n  for (var n = 0, len = s.length; n < len; n++) {\n    c = s.charCodeAt(n);\n\n    if (c < 128) {\n      a += String.fromCharCode(c);\n    } else if (c > 127 && c < 2048) {\n      a += String.fromCharCode(c >> 6 | 192);\n      a += String.fromCharCode(c & 63 | 128);\n    } else {\n      a += String.fromCharCode(c >> 12 | 224);\n      a += String.fromCharCode(c >> 6 & 63 | 128);\n      a += String.fromCharCode(c & 63 | 128);\n    }\n  }\n\n  return a;\n};\n\nBinaryParser.hprint = function hprint(s) {\n  var number;\n\n  for (var i = 0, len = s.length; i < len; i++) {\n    if (s.charCodeAt(i) < 32) {\n      number = s.charCodeAt(i) <= 15 ? \"0\" + s.charCodeAt(i).toString(16) : s.charCodeAt(i).toString(16);\n      process.stdout.write(number + \" \");\n    } else {\n      number = s.charCodeAt(i) <= 15 ? \"0\" + s.charCodeAt(i).toString(16) : s.charCodeAt(i).toString(16);\n      process.stdout.write(number + \" \");\n    }\n  }\n\n  process.stdout.write(\"\\n\\n\");\n};\n\nBinaryParser.ilprint = function hprint(s) {\n  var number;\n\n  for (var i = 0, len = s.length; i < len; i++) {\n    if (s.charCodeAt(i) < 32) {\n      number = s.charCodeAt(i) <= 15 ? \"0\" + s.charCodeAt(i).toString(10) : s.charCodeAt(i).toString(10);\n\n      require('util').debug(number + ' : ');\n    } else {\n      number = s.charCodeAt(i) <= 15 ? \"0\" + s.charCodeAt(i).toString(10) : s.charCodeAt(i).toString(10);\n\n      require('util').debug(number + ' : ' + s.charAt(i));\n    }\n  }\n};\n\nBinaryParser.hlprint = function hprint(s) {\n  var number;\n\n  for (var i = 0, len = s.length; i < len; i++) {\n    if (s.charCodeAt(i) < 32) {\n      number = s.charCodeAt(i) <= 15 ? \"0\" + s.charCodeAt(i).toString(16) : s.charCodeAt(i).toString(16);\n\n      require('util').debug(number + ' : ');\n    } else {\n      number = s.charCodeAt(i) <= 15 ? \"0\" + s.charCodeAt(i).toString(16) : s.charCodeAt(i).toString(16);\n\n      require('util').debug(number + ' : ' + s.charAt(i));\n    }\n  }\n};\n/**\n * BinaryParser buffer constructor.\n */\n\n\nfunction BinaryParserBuffer(bigEndian, buffer) {\n  this.bigEndian = bigEndian || 0;\n  this.buffer = [];\n  this.setBuffer(buffer);\n}\n\n;\n\nBinaryParserBuffer.prototype.setBuffer = function setBuffer(data) {\n  var l, i, b;\n\n  if (data) {\n    i = l = data.length;\n    b = this.buffer = new Array(l);\n\n    for (; i; b[l - i] = data.charCodeAt(--i));\n\n    this.bigEndian && b.reverse();\n  }\n};\n\nBinaryParserBuffer.prototype.hasNeededBits = function hasNeededBits(neededBits) {\n  return this.buffer.length >= -(-neededBits >> 3);\n};\n\nBinaryParserBuffer.prototype.checkBuffer = function checkBuffer(neededBits) {\n  if (!this.hasNeededBits(neededBits)) {\n    throw new Error(\"checkBuffer::missing bytes\");\n  }\n};\n\nBinaryParserBuffer.prototype.readBits = function readBits(start, length) {\n  //shl fix: Henri Torgemane ~1996 (compressed by Jonas Raoni)\n  function shl(a, b) {\n    for (; b--; a = ((a %= 0x7fffffff + 1) & 0x40000000) == 0x40000000 ? a * 2 : (a - 0x40000000) * 2 + 0x7fffffff + 1);\n\n    return a;\n  }\n\n  if (start < 0 || length <= 0) {\n    return 0;\n  }\n\n  this.checkBuffer(start + length);\n  var offsetLeft,\n      offsetRight = start % 8,\n      curByte = this.buffer.length - (start >> 3) - 1,\n      lastByte = this.buffer.length + (-(start + length) >> 3),\n      diff = curByte - lastByte,\n      sum = (this.buffer[curByte] >> offsetRight & (1 << (diff ? 8 - offsetRight : length)) - 1) + (diff && (offsetLeft = (start + length) % 8) ? (this.buffer[lastByte++] & (1 << offsetLeft) - 1) << (diff-- << 3) - offsetRight : 0);\n\n  for (; diff; sum += shl(this.buffer[lastByte++], (diff-- << 3) - offsetRight));\n\n  return sum;\n};\n/**\n * Expose.\n */\n\n\nBinaryParser.Buffer = BinaryParserBuffer;\nexports.BinaryParser = BinaryParser;","map":null,"metadata":{},"sourceType":"script"}