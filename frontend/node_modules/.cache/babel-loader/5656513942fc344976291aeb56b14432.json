{"ast":null,"code":"\"use strict\";\n\nvar Logger = require('../../connection/logger'),\n    EventEmitter = require('events').EventEmitter,\n    inherits = require('util').inherits,\n    f = require('util').format;\n/**\n * Creates a new Ping read preference strategy instance\n * @class\n * @param {number} [options.pingInterval=5000] Ping interval to check the response time to the different servers\n * @param {number} [options.acceptableLatency=250] Acceptable latency for selecting a server for reading (in milliseconds)\n * @return {Ping} A cursor instance\n */\n\n\nvar Ping = function (options) {\n  // Add event listener\n  EventEmitter.call(this); // Contains the ping state\n\n  this.s = {\n    // Contains all the ping data\n    pings: {} // Set no options if none provided\n    ,\n    options: options || {} // Logger\n    ,\n    logger: Logger('Ping', options) // Ping interval\n    ,\n    pingInterval: options.pingInterval || 10000,\n    acceptableLatency: options.acceptableLatency || 15 // Debug options\n    ,\n    debug: typeof options.debug == 'boolean' ? options.debug : false // Index\n    ,\n    index: 0 // Current ping time\n    ,\n    lastPing: null\n  }; // Log the options set\n\n  if (this.s.logger.isDebug()) this.s.logger.debug(f('ping strategy interval [%s], acceptableLatency [%s]', this.s.pingInterval, this.s.acceptableLatency)); // If we have enabled debug \n\n  if (this.s.debug) {\n    // Add access to the read Preference Strategies\n    Object.defineProperty(this, 'data', {\n      enumerable: true,\n      get: function () {\n        return this.s.pings;\n      }\n    });\n  }\n};\n\ninherits(Ping, EventEmitter);\n/**\n * @ignore\n */\n\nvar filterByTags = function (readPreference, servers) {\n  if (readPreference.tags == null) return servers;\n  var filteredServers = [];\n  var tags = readPreference.tags; // Iterate over all the servers\n\n  for (var i = 0; i < servers.length; i++) {\n    var serverTag = servers[i].lastIsMaster().tags || {}; // Did we find the a matching server\n\n    var found = true; // Check if the server is valid\n\n    for (var name in tags) {\n      if (serverTag[name] != tags[name]) found = false;\n    } // Add to candidate list\n\n\n    if (found) filteredServers.push(servers[i]);\n  } // Returned filtered servers\n\n\n  return filteredServers;\n};\n/**\n * Pick a server\n * @method\n * @param {State} set The current replicaset state object \n * @param {ReadPreference} readPreference The current readPreference object\n * @param {readPreferenceResultCallback} callback The callback to return the result from the function\n * @return {object}\n */\n\n\nPing.prototype.pickServer = function (set, readPreference) {\n  var self = this; // Only get primary and secondaries as seeds\n\n  var seeds = {};\n  var servers = [];\n\n  if (set.primary) {\n    servers.push(set.primary);\n  }\n\n  for (var i = 0; i < set.secondaries.length; i++) {\n    servers.push(set.secondaries[i]);\n  } // Filter by tags\n\n\n  servers = filterByTags(readPreference, servers); // Transform the list\n\n  var serverList = []; // for(var name in seeds) {\n\n  for (var i = 0; i < servers.length; i++) {\n    serverList.push({\n      name: servers[i].name,\n      time: self.s.pings[servers[i].name] || 0\n    });\n  } // Sort by time\n\n\n  serverList.sort(function (a, b) {\n    return a.time > b.time;\n  }); // Locate lowest time (picked servers are lowest time + acceptable Latency margin)\n\n  var lowest = serverList.length > 0 ? serverList[0].time : 0; // Filter by latency\n\n  serverList = serverList.filter(function (s) {\n    return s.time <= lowest + self.s.acceptableLatency;\n  }); // No servers, default to primary\n\n  if (serverList.length == 0 && set.primary) {\n    if (self.s.logger.isInfo()) self.s.logger.info(f('picked primary server [%s]', set.primary.name));\n    return set.primary;\n  } else if (serverList.length == 0) {\n    return null;\n  } // We picked first server\n\n\n  if (self.s.logger.isInfo()) self.s.logger.info(f('picked server [%s] with ping latency [%s]', serverList[0].name, serverList[0].time)); // Add to the index\n\n  self.s.index = self.s.index + 1; // Select the index\n\n  self.s.index = self.s.index % serverList.length; // Return the first server of the sorted and filtered list\n\n  return set.get(serverList[self.s.index].name);\n};\n/**\n * Start of an operation\n * @method\n * @param {Server} server The server the operation is running against\n * @param {object} query The operation running\n * @param {Date} date The start time of the operation\n * @return {object}\n */\n\n\nPing.prototype.startOperation = function (server, query, date) {};\n/**\n * End of an operation\n * @method\n * @param {Server} server The server the operation is running against\n * @param {error} err An error from the operation\n * @param {object} result The result from the operation\n * @param {Date} date The start time of the operation\n * @return {object}\n */\n\n\nPing.prototype.endOperation = function (server, err, result, date) {};\n/**\n * High availability process running\n * @method\n * @param {State} set The current replicaset state object \n * @param {resultCallback} callback The callback to return the result from the function\n * @return {object}\n */\n\n\nPing.prototype.ha = function (topology, state, callback) {\n  var self = this;\n  var servers = state.getAll();\n  var count = servers.length; // No servers return\n\n  if (servers.length == 0) return callback(null, null); // Return if we have not yet reached the ping interval\n\n  if (self.s.lastPing != null) {\n    var diff = new Date().getTime() - self.s.lastPing.getTime();\n    if (diff < self.s.pingInterval) return callback(null, null);\n  } // Execute operation\n\n\n  var operation = function (_server) {\n    var start = new Date(); // Execute ping against server\n\n    _server.command('system.$cmd', {\n      ismaster: 1\n    }, function (err, r) {\n      count = count - 1;\n      var time = new Date().getTime() - start.getTime();\n      self.s.pings[_server.name] = time; // Log info for debug\n\n      if (self.s.logger.isDebug()) self.s.logger.debug(f('ha latency for server [%s] is [%s] ms', _server.name, time)); // We are done with all the servers\n\n      if (count == 0) {\n        // Emit ping event\n        topology.emit('ping', err, r ? r.result : null); // Update the last ping time\n\n        self.s.lastPing = new Date(); // Return\n\n        callback(null, null);\n      }\n    });\n  }; // Let's ping all servers\n\n\n  while (servers.length > 0) {\n    operation(servers.shift());\n  }\n};\n\nvar removeServer = function (self, server) {\n  delete self.s.pings[server.name];\n};\n/**\n * Server connection closed\n * @method\n * @param {Server} server The server that closed\n */\n\n\nPing.prototype.close = function (server) {\n  removeServer(this, server);\n};\n/**\n * Server connection errored out\n * @method\n * @param {Server} server The server that errored out\n */\n\n\nPing.prototype.error = function (server) {\n  removeServer(this, server);\n};\n/**\n * Server connection timeout\n * @method\n * @param {Server} server The server that timed out\n */\n\n\nPing.prototype.timeout = function (server) {\n  removeServer(this, server);\n};\n/**\n * Server connection happened\n * @method\n * @param {Server} server The server that connected\n * @param {resultCallback} callback The callback to return the result from the function\n */\n\n\nPing.prototype.connect = function (server, callback) {\n  var self = this; // Get the command start date\n\n  var start = new Date(); // Execute ping against server\n\n  server.command('system.$cmd', {\n    ismaster: 1\n  }, function (err, r) {\n    var time = new Date().getTime() - start.getTime();\n    self.s.pings[server.name] = time; // Log info for debug\n\n    if (self.s.logger.isDebug()) self.s.logger.debug(f('connect latency for server [%s] is [%s] ms', server.name, time)); // Set last ping\n\n    self.s.lastPing = new Date(); // Done, return\n\n    callback(null, null);\n  });\n};\n/**\n * This is a result from a readPreference strategy\n *\n * @callback readPreferenceResultCallback\n * @param {error} error An error object. Set to null if no error present\n * @param {Server} server The server picked by the strategy\n */\n\n\nmodule.exports = Ping;","map":null,"metadata":{},"sourceType":"script"}