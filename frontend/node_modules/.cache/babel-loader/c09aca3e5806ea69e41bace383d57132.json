{"ast":null,"code":"\"use strict\";\n\nvar inherits = require('util').inherits,\n    f = require('util').format,\n    b = require('bson'),\n    bindToCurrentDomain = require('../connection/utils').bindToCurrentDomain,\n    debugOptions = require('../connection/utils').debugOptions,\n    EventEmitter = require('events').EventEmitter,\n    Server = require('./server'),\n    ReadPreference = require('./read_preference'),\n    MongoError = require('../error'),\n    Ping = require('./strategies/ping'),\n    Session = require('./session'),\n    BasicCursor = require('../cursor'),\n    BSON = require('bson').native().BSON,\n    State = require('./replset_state'),\n    MongoCR = require('../auth/mongocr'),\n    X509 = require('../auth/x509'),\n    Plain = require('../auth/plain'),\n    GSSAPI = require('../auth/gssapi'),\n    SSPI = require('../auth/sspi'),\n    ScramSHA1 = require('../auth/scram'),\n    Logger = require('../connection/logger');\n/**\n * @fileOverview The **ReplSet** class is a class that represents a Replicaset topology and is\n * used to construct connecctions.\n *\n * @example\n * var ReplSet = require('mongodb-core').ReplSet\n *   , ReadPreference = require('mongodb-core').ReadPreference\n *   , assert = require('assert');\n *\n * var server = new ReplSet([{host: 'localhost', port: 30000}], {setName: 'rs'});\n * // Wait for the connection event\n * server.on('connect', function(server) {\n *   server.destroy();\n * });\n *\n * // Start connecting\n * server.connect();\n */\n\n\nvar DISCONNECTED = 'disconnected';\nvar CONNECTING = 'connecting';\nvar CONNECTED = 'connected';\nvar DESTROYED = 'destroyed'; //\n// ReplSet instance id\n\nvar replSetId = 1; //\n// Clone the options\n\nvar cloneOptions = function (options) {\n  var opts = {};\n\n  for (var name in options) {\n    opts[name] = options[name];\n  }\n\n  return opts;\n}; // All bson types\n\n\nvar bsonTypes = [b.Long, b.ObjectID, b.Binary, b.Code, b.DBRef, b.Symbol, b.Double, b.Timestamp, b.MaxKey, b.MinKey]; // BSON parser\n\nvar bsonInstance = null;\n/**\n * Creates a new Replset instance\n * @class\n * @param {array} seedlist A list of seeds for the replicaset\n * @param {boolean} options.setName The Replicaset set name\n * @param {boolean} [options.secondaryOnlyConnectionAllowed=false] Allow connection to a secondary only replicaset\n * @param {number} [options.haInterval=10000] The High availability period for replicaset inquiry\n * @param {boolean} [options.emitError=false] Server will emit errors events\n * @param {Cursor} [options.cursorFactory=Cursor] The cursor factory class used for all query cursors\n * @param {number} [options.size=5] Server connection pool size\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=10000] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n * @param {number} [options.monitoringSocketTimeout=30000] TCP Socket timeout setting for replicaset monitoring socket\n * @param {boolean} [options.singleBufferSerializtion=true] Serialize into single buffer, trade of peak memory for serialization speed\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passphrase] SSL Certificate pass phrase\n * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @param {number} [options.pingInterval=5000] Ping interval to check the response time to the different servers\n * @param {number} [options.acceptableLatency=250] Acceptable latency for selecting a server for reading (in milliseconds)\n * @return {ReplSet} A cursor instance\n * @fires ReplSet#connect\n * @fires ReplSet#ha\n * @fires ReplSet#joined\n * @fires ReplSet#left\n */\n\nvar ReplSet = function (seedlist, options) {\n  var self = this;\n  options = options || {}; // Clone the options\n\n  options = cloneOptions(options); // Validate seedlist\n\n  if (!Array.isArray(seedlist)) throw new MongoError(\"seedlist must be an array\"); // Validate list\n\n  if (seedlist.length == 0) throw new MongoError(\"seedlist must contain at least one entry\"); // Validate entries\n\n  seedlist.forEach(function (e) {\n    if (typeof e.host != 'string' || typeof e.port != 'number') throw new MongoError(\"seedlist entry must contain a host and port\");\n  }); // Add event listener\n\n  EventEmitter.call(this); // Set the bson instance\n\n  bsonInstance = bsonInstance == null ? new BSON(bsonTypes) : bsonInstance; // Internal state hash for the object\n\n  this.s = {\n    options: options // Logger instance\n    ,\n    logger: Logger('ReplSet', options) // Uniquely identify the replicaset instance\n    ,\n    id: replSetId++ // Index\n    ,\n    index: 0 // Ha Index\n    ,\n    haId: 0 // Current credentials used for auth\n    ,\n    credentials: [] // Factory overrides\n    ,\n    Cursor: options.cursorFactory || BasicCursor // BSON Parser, ensure we have a single instance\n    ,\n    bsonInstance: bsonInstance // Pick the right bson parser\n    ,\n    bson: options.bson ? options.bson : bsonInstance // Special replicaset options\n    ,\n    secondaryOnlyConnectionAllowed: typeof options.secondaryOnlyConnectionAllowed == 'boolean' ? options.secondaryOnlyConnectionAllowed : false,\n    haInterval: options.haInterval || 10000 // Current haInterval\n    ,\n    currentHaInterval: options.haInterval || 10000 // Are we running in debug mode\n    ,\n    debug: typeof options.debug == 'boolean' ? options.debug : false // The replicaset name\n    ,\n    setName: options.setName // Swallow or emit errors\n    ,\n    emitError: typeof options.emitError == 'boolean' ? options.emitError : false // Grouping tag used for debugging purposes\n    ,\n    tag: options.tag // Do we have a not connected handler\n    ,\n    disconnectHandler: options.disconnectHandler // Contains any alternate strategies for picking\n    ,\n    readPreferenceStrategies: {} // Auth providers\n    ,\n    authProviders: {} // All the servers\n    ,\n    disconnectedServers: [] // Initial connection servers\n    ,\n    initialConnectionServers: [] // High availability process running\n    ,\n    highAvailabilityProcessRunning: false // Full setup\n    ,\n    fullsetup: false // All servers accounted for (used for testing)\n    ,\n    all: false // Seedlist\n    ,\n    seedlist: seedlist // Authentication in progress\n    ,\n    authInProgress: false // Servers added while auth in progress\n    ,\n    authInProgressServers: [] // Minimum heartbeat frequency used if we detect a server close\n    ,\n    minHeartbeatFrequencyMS: 500 // stores high availability timer to allow efficient destroy\n    ,\n    haTimer: null\n  }; // Add bson parser to options\n\n  options.bson = this.s.bson; // Set up the connection timeout for the options\n\n  options.connectionTimeout = options.connectionTimeout || 10000; // Replicaset state\n\n  var replState = new State(this, {\n    id: this.s.id,\n    setName: this.s.setName // , connectingServers: this.s.connectingServers\n    ,\n    secondaryOnlyConnectionAllowed: this.s.secondaryOnlyConnectionAllowed\n  }); // Add Replicaset state to our internal state\n\n  this.s.replState = replState; // Add the authentication mechanisms\n\n  this.addAuthProvider('mongocr', new MongoCR());\n  this.addAuthProvider('x509', new X509());\n  this.addAuthProvider('plain', new Plain());\n  this.addAuthProvider('gssapi', new GSSAPI());\n  this.addAuthProvider('sspi', new SSPI());\n  this.addAuthProvider('scram-sha-1', new ScramSHA1()); // BSON property (find a server and pass it along)\n\n  Object.defineProperty(this, 'bson', {\n    enumerable: true,\n    get: function () {\n      var servers = self.s.replState.getAll();\n      return servers.length > 0 ? servers[0].bson : null;\n    }\n  });\n  Object.defineProperty(this, 'id', {\n    enumerable: true,\n    get: function () {\n      return self.s.id;\n    }\n  });\n  Object.defineProperty(this, 'haInterval', {\n    enumerable: true,\n    get: function () {\n      return self.s.haInterval;\n    }\n  });\n  Object.defineProperty(this, 'state', {\n    enumerable: true,\n    get: function () {\n      return self.s.replState;\n    }\n  }); //\n  // Debug options\n\n  if (self.s.debug) {\n    // Add access to the read Preference Strategies\n    Object.defineProperty(this, 'readPreferenceStrategies', {\n      enumerable: true,\n      get: function () {\n        return self.s.readPreferenceStrategies;\n      }\n    });\n  }\n\n  Object.defineProperty(this, 'type', {\n    enumerable: true,\n    get: function () {\n      return 'replset';\n    }\n  }); // Add the ping strategy for nearest\n\n  this.addReadPreferenceStrategy('nearest', new Ping(options));\n};\n\ninherits(ReplSet, EventEmitter); //\n// Plugin methods\n//\n\n/**\n * Add custom read preference strategy\n * @method\n * @param {string} name Name of the read preference strategy\n * @param {object} strategy Strategy object instance\n */\n\nReplSet.prototype.addReadPreferenceStrategy = function (name, func) {\n  this.s.readPreferenceStrategies[name] = func;\n};\n/**\n * Add custom authentication mechanism\n * @method\n * @param {string} name Name of the authentication mechanism\n * @param {object} provider Authentication object instance\n */\n\n\nReplSet.prototype.addAuthProvider = function (name, provider) {\n  if (this.s.authProviders == null) this.s.authProviders = {};\n  this.s.authProviders[name] = provider;\n};\n/**\n * Name of BSON parser currently used\n * @method\n * @return {string}\n */\n\n\nReplSet.prototype.parserType = function () {\n  if (this.s.bson.serialize.toString().indexOf('[native code]') != -1) return 'c++';\n  return 'js';\n};\n/**\n * Execute a command\n * @method\n * @param {string} type Type of BSON parser to use (c++ or js)\n */\n\n\nReplSet.prototype.setBSONParserType = function (type) {\n  var nBSON = null;\n\n  if (type == 'c++') {\n    nBSON = require('bson').native().BSON;\n  } else if (type == 'js') {\n    nBSON = require('bson').pure().BSON;\n  } else {\n    throw new MongoError(f(\"% parser not supported\", type));\n  }\n\n  this.s.options.bson = new nBSON(bsonTypes);\n};\n/**\n * Returns the last known ismaster document for this server\n * @method\n * @return {object}\n */\n\n\nReplSet.prototype.lastIsMaster = function () {\n  return this.s.replState.lastIsMaster();\n};\n/**\n * Get connection\n * @method\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @return {Connection}\n */\n\n\nReplSet.prototype.getConnection = function (options) {\n  // Ensure we have no options\n  options = options || {}; // Pick the right server based on readPreference\n\n  var server = pickServer(this, this.s, options.readPreference);\n  if (server == null) return null; // Return connection\n\n  return server.getConnection();\n};\n/**\n * All raw connections\n * @method\n * @return {Connection[]}\n */\n\n\nReplSet.prototype.connections = function () {\n  return this.s.replState.getAllConnections({\n    includeArbiters: true\n  });\n};\n/**\n * Get server\n * @method\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @return {Server}\n */\n\n\nReplSet.prototype.getServer = function (options) {\n  // Ensure we have no options\n  options = options || {}; // Pick the right server based on readPreference\n\n  return pickServer(this, this.s, options.readPreference);\n};\n/**\n * Get correct server for a given connection\n * @method\n * @param {Connection} [connection] A Connection showing a current server\n * @return {Server}\n */\n\n\nReplSet.prototype.getServerFrom = function (connection) {\n  var servers = this.s.replState.getAll(); // Go through all the server\n\n  for (var i = 0; i < servers.length; i++) {\n    if (servers[i].equals(connection.name)) return servers[i];\n  }\n\n  return null;\n};\n/**\n * Perform one or more remove operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {{object}|{Long}} cmd Can be either a command returning a cursor or a cursorId\n * @param {object} [options.batchSize=0] Batchsize for the operation\n * @param {array} [options.documents=[]] Initial documents list for cursor\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {opResultCallback} callback A callback function\n */\n\n\nReplSet.prototype.cursor = function (ns, cmd, cursorOptions) {\n  cursorOptions = cursorOptions || {};\n  var FinalCursor = cursorOptions.cursorFactory || this.s.Cursor;\n  return new FinalCursor(this.s.bson, ns, cmd, cursorOptions, this, this.s.options);\n}; //\n// Execute write operation\n\n\nvar executeWriteOperation = function (self, op, ns, ops, options, callback) {\n  if (typeof options == 'function') {\n    callback = options;\n    options = {};\n  }\n\n  var server = null; // Ensure we have no options\n\n  options = options || {}; // Get a primary\n\n  try {\n    server = pickServer(self, self.s, ReadPreference.primary);\n    if (self.s.debug) self.emit('pickedServer', ReadPreference.primary, server);\n  } catch (err) {\n    return callback(err);\n  } // No server returned we had an error\n\n\n  if (server == null) return callback(new MongoError(\"no server found\")); // Handler\n\n  var handler = function (err, r) {\n    // We have a no master error, immediately refresh the view of the replicaset\n    if ((notMasterError(r) || notMasterError(err)) && !self.s.highAvailabilityProcessRunning) {\n      // Set he current interval to minHeartbeatFrequencyMS\n      self.s.currentHaInterval = self.s.minHeartbeatFrequencyMS; // Attempt to locate the current master immediately\n\n      replicasetInquirer(self, self.s, true)();\n    } // Return the result\n\n\n    callback(err, r);\n  }; // Add operationId if existing\n\n\n  if (callback.operationId) handler.operationId = callback.operationId; // Execute the command\n\n  server[op](ns, ops, options, handler);\n};\n/**\n * Execute a command\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {object} cmd The command hash\n * @param {ReadPreference} [options.readPreference] Specify read preference if command supports it\n * @param {Connection} [options.connection] Specify connection object to execute command against\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {opResultCallback} callback A callback function\n */\n\n\nReplSet.prototype.command = function (ns, cmd, options, callback) {\n  if (typeof options == 'function') callback = options, options = {};\n  if (this.s.replState.state == DESTROYED) return callback(new MongoError(f('topology was destroyed')));\n  var server = null;\n  var self = this; // Ensure we have no options\n\n  options = options || {}; // Topology is not connected, save the call in the provided store to be\n  // Executed at some point when the handler deems it's reconnected\n\n  if (!this.isConnected(options) && this.s.disconnectHandler != null) {\n    callback = bindToCurrentDomain(callback);\n    return this.s.disconnectHandler.add('command', ns, cmd, options, callback);\n  } // We need to execute the command on all servers\n\n\n  if (options.onAll) {\n    var servers = this.s.replState.getAll();\n    var count = servers.length;\n    var cmdErr = null;\n\n    for (var i = 0; i < servers.length; i++) {\n      servers[i].command(ns, cmd, options, function (err, r) {\n        count = count - 1; // Finished executing command\n\n        if (count == 0) {\n          // Was it a logout command clear any credentials\n          if (cmd.logout) clearCredentials(self.s, ns); // We have a no master error, immediately refresh the view of the replicaset\n\n          if ((notMasterError(r) || notMasterError(err)) && !self.s.highAvailabilityProcessRunning) {\n            replicasetInquirer(self, self.s, true)();\n          } // Return the error\n\n\n          callback(err, r);\n        }\n      });\n    }\n\n    return;\n  } // Pick the right server based on readPreference\n\n\n  try {\n    server = pickServer(self, self.s, options.writeConcern ? ReadPreference.primary : options.readPreference);\n    if (self.s.debug) self.emit('pickedServer', options.writeConcern ? ReadPreference.primary : options.readPreference, server);\n  } catch (err) {\n    return callback(err);\n  } // No server returned we had an error\n\n\n  if (server == null) return callback(new MongoError(\"no server found\")); // Execute the command\n\n  server.command(ns, cmd, options, function (err, r) {\n    // Was it a logout command clear any credentials\n    if (cmd.logout) clearCredentials(self.s, ns); // We have a no master error, immediately refresh the view of the replicaset\n\n    if ((notMasterError(r) || notMasterError(err)) && !self.s.highAvailabilityProcessRunning) {\n      replicasetInquirer(self, self.s, true)();\n    } // Return the error\n\n\n    callback(err, r);\n  });\n};\n/**\n * Perform one or more remove operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of removes\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {opResultCallback} callback A callback function\n */\n\n\nReplSet.prototype.remove = function (ns, ops, options, callback) {\n  if (typeof options == 'function') callback = options, options = {};\n  if (this.s.replState.state == DESTROYED) return callback(new MongoError(f('topology was destroyed'))); // Topology is not connected, save the call in the provided store to be\n  // Executed at some point when the handler deems it's reconnected\n\n  if (!this.isConnected() && this.s.disconnectHandler != null) {\n    callback = bindToCurrentDomain(callback);\n    return this.s.disconnectHandler.add('remove', ns, ops, options, callback);\n  }\n\n  executeWriteOperation(this, 'remove', ns, ops, options, callback);\n};\n/**\n * Insert one or more documents\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of documents to insert\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {opResultCallback} callback A callback function\n */\n\n\nReplSet.prototype.insert = function (ns, ops, options, callback) {\n  if (typeof options == 'function') callback = options, options = {};\n  if (this.s.replState.state == DESTROYED) return callback(new MongoError(f('topology was destroyed'))); // Topology is not connected, save the call in the provided store to be\n  // Executed at some point when the handler deems it's reconnected\n\n  if (!this.isConnected() && this.s.disconnectHandler != null) {\n    callback = bindToCurrentDomain(callback);\n    return this.s.disconnectHandler.add('insert', ns, ops, options, callback);\n  }\n\n  executeWriteOperation(this, 'insert', ns, ops, options, callback);\n};\n/**\n * Perform one or more update operations\n * @method\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {array} ops An array of updates\n * @param {boolean} [options.ordered=true] Execute in order or out of order\n * @param {object} [options.writeConcern={}] Write concern for the operation\n * @param {Boolean} [options.serializeFunctions=false] Specify if functions on an object should be serialized.\n * @param {Boolean} [options.ignoreUndefined=false] Specify if the BSON serializer should ignore undefined fields.\n * @param {opResultCallback} callback A callback function\n */\n\n\nReplSet.prototype.update = function (ns, ops, options, callback) {\n  if (typeof options == 'function') callback = options, options = {};\n  if (this.s.replState.state == DESTROYED) return callback(new MongoError(f('topology was destroyed'))); // Topology is not connected, save the call in the provided store to be\n  // Executed at some point when the handler deems it's reconnected\n\n  if (!this.isConnected() && this.s.disconnectHandler != null) {\n    callback = bindToCurrentDomain(callback);\n    return this.s.disconnectHandler.add('update', ns, ops, options, callback);\n  }\n\n  executeWriteOperation(this, 'update', ns, ops, options, callback);\n};\n/**\n * Authenticate using a specified mechanism\n * @method\n * @param {string} mechanism The Auth mechanism we are invoking\n * @param {string} db The db we are invoking the mechanism against\n * @param {...object} param Parameters for the specific mechanism\n * @param {authResultCallback} callback A callback function\n */\n\n\nReplSet.prototype.auth = function (mechanism, db) {\n  var allArgs = Array.prototype.slice.call(arguments, 0).slice(0);\n  var self = this;\n  var args = Array.prototype.slice.call(arguments, 2);\n  var callback = args.pop(); // If we don't have the mechanism fail\n\n  if (this.s.authProviders[mechanism] == null && mechanism != 'default') {\n    throw new MongoError(f(\"auth provider %s does not exist\", mechanism));\n  } // Authenticate against all the servers\n\n\n  var servers = this.s.replState.getAll().slice(0);\n  var count = servers.length; // Correct authentication\n\n  var authenticated = true;\n  var authErr = null; // Set auth in progress\n\n  this.s.authInProgress = true; // Authenticate against all servers\n\n  while (servers.length > 0) {\n    var server = servers.shift(); // Arguments without a callback\n\n    var argsWithoutCallback = [mechanism, db].concat(args.slice(0)); // Create arguments\n\n    var finalArguments = argsWithoutCallback.concat([function (err, r) {\n      count = count - 1;\n      if (err) authErr = err;\n      if (!r) authenticated = false; // We are done\n\n      if (count == 0) {\n        // We have more servers that are not authenticated, let's authenticate\n        if (self.s.authInProgressServers.length > 0) {\n          self.s.authInProgressServers = [];\n          return self.auth.apply(self, [mechanism, db].concat(args).concat([callback]));\n        } // Auth is done\n\n\n        self.s.authInProgress = false; // Add successful credentials\n\n        if (authErr == null) addCredentials(self.s, db, argsWithoutCallback); // Return the auth error\n\n        if (authErr) return callback(authErr, false); // Successfully authenticated session\n\n        callback(null, new Session({}, self));\n      }\n    }]); // Execute the auth\n\n    server.auth.apply(server, finalArguments);\n  }\n};\n\nReplSet.prototype.state = function () {\n  return this.s.replState.state;\n};\n/**\n * Ensure single socket connections to arbiters and hidden servers\n * @method\n */\n\n\nvar handleIsmaster = function (self) {\n  return function (ismaster, _server) {\n    if (ismaster.arbiterOnly) {\n      _server.s.options.size = 1;\n    } else if (ismaster.hidden) {\n      _server.s.options.size = 1;\n    }\n  };\n};\n/**\n * Emit event if it exists\n * @method\n */\n\n\nfunction emitSDAMEvent(self, event, description) {\n  if (self.listeners(event).length > 0) {\n    self.emit(event, description);\n  }\n}\n/**\n * Initiate server connect\n * @method\n */\n\n\nReplSet.prototype.connect = function (_options) {\n  var self = this; // Start replicaset inquiry process\n\n  setHaTimer(self, self.s); // Additional options\n\n  if (_options) for (var name in _options) this.s.options[name] = _options[name]; // Set the state as connecting\n\n  this.s.replState.state = CONNECTING; // No fullsetup reached\n\n  this.s.fullsetup = false; // Reset the replState\n\n  this.s.replState.resetDescription(); // For all entries in the seedlist build a server instance\n\n  this.s.seedlist.forEach(function (e) {\n    // Clone options\n    var opts = cloneOptions(self.s.options); // Add host and port\n\n    opts.host = e.host;\n    opts.port = e.port;\n    opts.reconnect = false;\n    opts.readPreferenceStrategies = self.s.readPreferenceStrategies;\n    opts.emitError = true; // Add a reserved connection for monitoring\n\n    opts.size = opts.size + 1;\n    opts.monitoring = true;\n    opts.topologyId = self.s.id; // Server is in topology\n\n    opts.inTopology = true; // Set up tags if any\n\n    if (self.s.tag) opts.tag = self.s.tag; // Share the auth store\n\n    opts.authProviders = self.s.authProviders; // Create a new Server\n\n    var server = new Server(opts); // Handle the ismaster\n\n    server.on('ismaster', handleIsmaster(self)); // Add to list of disconnected servers\n\n    self.s.disconnectedServers.push(server); // Add to list of inflight Connections\n\n    self.s.initialConnectionServers.push(server);\n  }); // Emit the topology opening event\n\n  emitSDAMEvent(this, 'topologyOpening', {\n    topologyId: this.s.id\n  }); // Attempt to connect to all the servers\n\n  while (this.s.disconnectedServers.length > 0) {\n    // Get the server\n    var server = self.s.disconnectedServers.shift(); // Ensure the server is properly disconnected\n\n    server.destroy(); // Set up the event handlers\n\n    server.once('error', errorHandlerTemp(self, self.s, 'error'));\n    server.once('close', errorHandlerTemp(self, self.s, 'close'));\n    server.once('timeout', errorHandlerTemp(self, self.s, 'timeout'));\n    server.once('connect', connectHandler(self, self.s, false)); // SDAM Monitoring events\n\n    server.on('serverOpening', function (e) {\n      self.emit('serverOpening', e);\n    });\n    server.on('serverDescriptionChanged', function (e) {\n      self.emit('serverDescriptionChanged', e);\n    });\n    server.on('serverHeartbeatStarted', function (e) {\n      self.emit('serverHeartbeatStarted', e);\n    });\n    server.on('serverHeartbeatSucceeded', function (e) {\n      self.emit('serverHeartbeatSucceeded', e);\n    });\n    server.on('serverHearbeatFailed', function (e) {\n      self.emit('serverHearbeatFailed', e);\n    });\n    server.on('serverClosed', function (e) {\n      self.emit('serverClosed', e);\n    }); // Ensure we schedule the opening of new socket\n    // on separate ticks of the event loop\n\n    var execute = function (_server) {\n      // Attempt to connect\n      process.nextTick(function () {\n        _server.connect();\n      });\n    };\n\n    execute(server);\n  }\n};\n/**\n * Figure out if the server is connected\n * @method\n * @return {boolean}\n */\n\n\nReplSet.prototype.isConnected = function (options) {\n  options = options || {}; // If we specified a read preference check if we are connected to something\n  // than can satisfy this\n\n  if (options.readPreference && options.readPreference.equals(ReadPreference.secondary)) {\n    return this.s.replState.isSecondaryConnected();\n  }\n\n  if (options.readPreference && options.readPreference.equals(ReadPreference.primary)) {\n    return this.s.replState.isPrimaryConnected();\n  }\n\n  if (options.readPreference && options.readPreference.equals(ReadPreference.primaryPreferred)) {\n    return this.s.replState.isSecondaryConnected() || this.s.replState.isPrimaryConnected();\n  }\n\n  if (options.readPreference && options.readPreference.equals(ReadPreference.secondaryPreferred)) {\n    return this.s.replState.isSecondaryConnected() || this.s.replState.isPrimaryConnected();\n  }\n\n  if (this.s.secondaryOnlyConnectionAllowed && this.s.replState.isSecondaryConnected()) {\n    return true;\n  }\n\n  return this.s.replState.isPrimaryConnected();\n};\n/**\n * Figure out if the replicaset instance was destroyed by calling destroy\n * @method\n * @return {boolean}\n */\n\n\nReplSet.prototype.isDestroyed = function () {\n  return this.s.replState.state == DESTROYED;\n};\n/**\n * Unref all connections belong to this server\n * @method\n */\n\n\nReplSet.prototype.unref = function (emitClose) {\n  var self = this;\n  if (this.s.logger.isInfo()) this.s.logger.info(f('[%s] unreferenced', this.s.id)); // Emit close\n\n  if (emitClose && self.listeners('close').length > 0) self.emit('close', self); // Unref sockets\n\n  this.s.replState.unref(); // Clear out any listeners\n\n  var events = ['timeout', 'error', 'close', 'joined', 'left', 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHearbeatFailed', 'serverClosed'];\n  events.forEach(function (e) {\n    self.removeAllListeners(e);\n  });\n  clearTimeout(self.s.haTimer);\n};\n/**\n * Destroy the server connection\n * @method\n */\n\n\nReplSet.prototype.destroy = function (emitClose) {\n  var self = this;\n  if (this.s.logger.isInfo()) this.s.logger.info(f('[%s] destroyed', this.s.id));\n  this.s.replState.state = DESTROYED; // Clear the ha timer\n\n  if (self.s.haTimer) clearTimeout(self.s.haTimer); // Emit close\n\n  if (emitClose && self.listeners('close').length > 0) self.emit('close', self); // Destroy state\n\n  this.s.replState.destroy(); // Emit toplogy closing event\n\n  emitSDAMEvent(this, 'topologyClosed', {\n    topologyId: this.s.id\n  }); // Clear out any listeners\n\n  var events = ['timeout', 'error', 'close', 'joined', 'left', 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHearbeatFailed', 'serverClosed'];\n  events.forEach(function (e) {\n    self.removeAllListeners(e);\n  });\n  clearTimeout(self.s.haTimer);\n};\n/**\n * A replset connect event, used to verify that the connection is up and running\n *\n * @event ReplSet#connect\n * @type {ReplSet}\n */\n\n/**\n * The replset high availability event\n *\n * @event ReplSet#ha\n * @type {function}\n * @param {string} type The stage in the high availability event (start|end)\n * @param {boolean} data.norepeat This is a repeating high availability process or a single execution only\n * @param {number} data.id The id for this high availability request\n * @param {object} data.state An object containing the information about the current replicaset\n */\n\n/**\n * A server member left the replicaset\n *\n * @event ReplSet#left\n * @type {function}\n * @param {string} type The type of member that left (primary|secondary|arbiter)\n * @param {Server} server The server object that left\n */\n\n/**\n * A server member joined the replicaset\n *\n * @event ReplSet#joined\n * @type {function}\n * @param {string} type The type of member that joined (primary|secondary|arbiter)\n * @param {Server} server The server object that joined\n */\n//\n// Inquires about state changes\n//\n// Add the new credential for a db, removing the old\n// credential from the cache\n\n\nvar addCredentials = function (s, db, argsWithoutCallback) {\n  // Remove any credentials for the db\n  clearCredentials(s, db + \".dummy\"); // Add new credentials to list\n\n  s.credentials.push(argsWithoutCallback);\n}; // Clear out credentials for a namespace\n\n\nvar clearCredentials = function (s, ns) {\n  var db = ns.split('.')[0];\n  var filteredCredentials = []; // Filter out all credentials for the db the user is logging out off\n\n  for (var i = 0; i < s.credentials.length; i++) {\n    if (s.credentials[i][1] != db) filteredCredentials.push(s.credentials[i]);\n  } // Set new list of credentials\n\n\n  s.credentials = filteredCredentials;\n}; //\n// Filter serves by tags\n\n\nvar filterByTags = function (readPreference, servers) {\n  if (readPreference.tags == null) return servers;\n  var filteredServers = [];\n  var tagsArray = !Array.isArray(readPreference.tags) ? [tags] : tags; // Iterate over the tags\n\n  for (var j = 0; j < tagsArray.length; j++) {\n    var tags = tagsArray[j]; // Iterate over all the servers\n\n    for (var i = 0; i < servers.length; i++) {\n      var serverTag = servers[i].lastIsMaster().tags || {}; // Did we find the a matching server\n\n      var found = true; // Check if the server is valid\n\n      for (var name in tags) {\n        if (serverTag[name] != tags[name]) found = false;\n      } // Add to candidate list\n\n\n      if (found) {\n        filteredServers.push(servers[i]);\n      }\n    } // We found servers by the highest priority\n\n\n    if (found) break;\n  } // Returned filtered servers\n\n\n  return filteredServers;\n};\n\nvar eventHandler = {\n  fullsetup: function (self, state) {\n    // If no more initial servers and new scheduled servers to connect\n    if (!state.replState.primary) return;\n    if (state.replState.secondaries.length === 0) return;\n    if (state.fullsetup) return; // Only emit if there is a listener\n\n    if (self.listeners('fullsetup').length > 0) {\n      state.fullsetup = true;\n      self.emit('fullsetup', self);\n    }\n  },\n  all: function (self, state) {\n    // If all servers are accounted for and we have not sent the all event\n    if (!state.replState.primary) return;\n    if (!self.lastIsMaster()) return;\n    if (!Array.isArray(self.lastIsMaster().hosts)) return;\n    if (state.all) return;\n    var length = 1 + state.replState.secondaries.length; // If we have all secondaries + primary\n\n    if (length !== self.lastIsMaster().hosts.length) return; // Only emit if there is a listener\n\n    if (self.listeners('all').length > 0) {\n      state.all = true;\n      self.emit('all', self);\n    }\n  }\n};\n\nvar checkAndEmitEvent = function (self, state, event) {\n  var handler = eventHandler[event];\n  if (!handler) throw new MongoError(event + \" event not implemented\");\n  handler(self, state);\n}; //\n// Pick a server based on readPreference\n\n\nvar pickServer = function (self, s, readPreference) {\n  // If no read Preference set to primary by default\n  readPreference = readPreference || ReadPreference.primary; // Do we have a custom readPreference strategy, use it\n\n  if (s.readPreferenceStrategies != null && s.readPreferenceStrategies[readPreference.preference] != null) {\n    if (s.readPreferenceStrategies[readPreference.preference] == null) throw new MongoError(f(\"cannot locate read preference handler for %s\", readPreference.preference));\n    var server = s.readPreferenceStrategies[readPreference.preference].pickServer(s.replState, readPreference);\n    if (s.debug) self.emit('pickedServer', readPreference, server);\n    return server;\n  } // Get all the secondaries\n\n\n  var secondaries = s.replState.getSecondaries(); // Check if we can satisfy and of the basic read Preferences\n\n  if (readPreference.equals(ReadPreference.secondary) && secondaries.length == 0) throw new MongoError(\"no secondary server available\");\n  if (readPreference.equals(ReadPreference.secondaryPreferred) && secondaries.length == 0 && s.replState.primary == null) throw new MongoError(\"no secondary or primary server available\");\n  if (readPreference.equals(ReadPreference.primary) && s.replState.primary == null) throw new MongoError(\"no primary server available\"); // Secondary\n\n  if (readPreference.equals(ReadPreference.secondary)) {\n    s.index = (s.index + 1) % secondaries.length;\n    return secondaries[s.index];\n  } // Secondary preferred\n\n\n  if (readPreference.equals(ReadPreference.secondaryPreferred)) {\n    if (secondaries.length > 0) {\n      // Apply tags if present\n      var servers = filterByTags(readPreference, secondaries); // If have a matching server pick one otherwise fall through to primary\n\n      if (servers.length > 0) {\n        s.index = (s.index + 1) % servers.length;\n        return servers[s.index];\n      }\n    }\n\n    return s.replState.primary;\n  } // Primary preferred\n\n\n  if (readPreference.equals(ReadPreference.primaryPreferred)) {\n    if (s.replState.primary) return s.replState.primary;\n\n    if (secondaries.length > 0) {\n      // Apply tags if present\n      var servers = filterByTags(readPreference, secondaries); // If have a matching server pick one otherwise fall through to primary\n\n      if (servers.length > 0) {\n        s.index = (s.index + 1) % servers.length;\n        return servers[s.index];\n      } // Throw error a we have not valid secondary or primary servers\n\n\n      throw new MongoError(\"no secondary or primary server available\");\n    }\n  } // Return the primary\n\n\n  return s.replState.primary;\n};\n\nvar setHaTimer = function (self, state) {\n  if (state.highAvailabilityProcessRunning) return; // all haTimers are set to to repeat, so we pass norepeat false\n\n  self.s.haTimer = setTimeout(replicasetInquirer(self, state, false), state.currentHaInterval);\n  return self.s.haTimer;\n};\n\nvar haveAvailableServers = function (state) {\n  if (state.disconnectedServers.length == 0 && state.replState.secondaries.length == 0 && state.replState.arbiters.length == 0 && state.replState.primary == null) return false;\n  return true;\n};\n\nvar merge = function (list, newList) {\n  var finalList = list.slice(0);\n\n  for (var i = 0; i < newList.length; i++) {\n    if (finalList.indexOf(newList[i]) == -1) finalList.push(newList[i]);\n  }\n\n  return finalList;\n};\n\nvar replicasetInquirer = function (self, state, norepeat) {\n  return function () {\n    // Process already running or state destroyed, don't rerun\n    if (state.highAvailabilityProcessRunning || state.replState.state == DESTROYED) {\n      return;\n    } // Do we have a primary, ensure we only monitor by the haInterval\n\n\n    if (state.replState.isPrimaryConnected()) {\n      self.s.currentHaInterval = self.s.haInterval;\n    } else {\n      self.s.currentHaInterval = self.s.minHeartbeatFrequencyMS;\n    } // Clean out any failed connection attempts\n\n\n    state.replState.clearConnectingServers(); // Cleanup state (removed disconnected servers)\n\n    state.replState.clean(); // Started processes\n\n    state.highAvailabilityProcessRunning = true; // We have no connections we need to reseed the disconnected list\n\n    if (!haveAvailableServers(state)) {\n      // For all entries in the seedlist build a server instance\n      state.disconnectedServers = state.seedlist.map(function (e) {\n        // Clone options\n        var opts = cloneOptions(state.options); // Add host and port\n\n        opts.host = e.host;\n        opts.port = e.port;\n        opts.reconnect = false;\n        opts.readPreferenceStrategies = state.readPreferenceStrategies;\n        opts.emitError = true; // Add a reserved connection for monitoring\n\n        opts.size = opts.size + 1;\n        opts.monitoring = true;\n        opts.topologyId = self.s.id; // Server is in topology\n\n        opts.inTopology = true; // Set up tags if any\n\n        if (state.tag) opts.tag = state.tag; // Share the auth store\n\n        opts.authProviders = state.authProviders; // Create a new Server\n\n        var server = new Server(opts); // Handle the ismaster\n\n        server.on('ismaster', handleIsmaster(self));\n        return server;\n      });\n    }\n\n    if (state.logger.isInfo()) state.logger.info(f('[%s] monitoring process running %s', state.id, JSON.stringify(state.replState))); // Unique HA id to identify the current look running\n\n    var localHaId = state.haId++; // Controls if we are doing a single inquiry or repeating\n\n    norepeat = typeof norepeat == 'boolean' ? norepeat : false; // If we have a primary and a disconnect handler, execute\n    // buffered operations\n\n    if (state.replState.isPrimaryConnected() && state.replState.isSecondaryConnected() && state.disconnectHandler) {\n      state.disconnectHandler.execute();\n    } // Emit replicasetInquirer\n\n\n    self.emit('ha', 'start', {\n      norepeat: norepeat,\n      id: localHaId,\n      state: state.replState ? state.replState.toJSON() : {}\n    }); // Let's process all the disconnected servers\n\n    while (state.disconnectedServers.length > 0) {\n      // Get the first disconnected server\n      var server = state.disconnectedServers.shift();\n      if (state.logger.isInfo()) state.logger.info(f('[%s] monitoring attempting to connect to %s', state.id, server.lastIsMaster() ? server.lastIsMaster().me : server.name)); // Set up the event handlers\n\n      server.once('error', errorHandlerTemp(self, state, 'error'));\n      server.once('close', errorHandlerTemp(self, state, 'close'));\n      server.once('timeout', errorHandlerTemp(self, state, 'timeout'));\n      server.once('connect', connectHandler(self, state, true)); // SDAM Monitoring events\n\n      server.on('serverOpening', function (e) {\n        self.emit('serverOpening', e);\n      });\n      server.on('serverDescriptionChanged', function (e) {\n        self.emit('serverDescriptionChanged', e);\n      });\n      server.on('serverHeartbeatStarted', function (e) {\n        self.emit('serverHeartbeatStarted', e);\n      });\n      server.on('serverHeartbeatSucceeded', function (e) {\n        self.emit('serverHeartbeatSucceeded', e);\n      });\n      server.on('serverHearbeatFailed', function (e) {\n        self.emit('serverHearbeatFailed', e);\n      });\n      server.on('serverClosed', function (e) {\n        self.emit('serverClosed', e);\n      }); // Ensure we schedule the opening of new socket\n      // on separate ticks of the event loop\n\n      var execute = function (_server) {\n        // Attempt to connect\n        process.nextTick(function () {\n          _server.connect();\n        });\n      };\n\n      execute(server);\n    } // We need to query all servers\n\n\n    var servers = state.replState.getAll({\n      includeArbiters: true\n    });\n    var serversLeft = servers.length; // If no servers and we are not destroyed keep pinging\n\n    if (servers.length == 0 && state.replState.state == CONNECTED) {\n      // Emit ha process end\n      self.emit('ha', 'end', {\n        norepeat: norepeat,\n        id: localHaId,\n        state: state.replState ? state.replState.toJSON() : {}\n      }); // Ended highAvailabilityProcessRunning\n\n      state.highAvailabilityProcessRunning = false; // Restart ha process\n\n      if (!norepeat) {\n        setHaTimer(self, state);\n      }\n\n      return;\n    } //\n    // ismaster for Master server\n\n\n    var primaryIsMaster = null; //\n    // Inspect a specific servers ismaster\n\n    var inspectServer = function (server, callback) {\n      // If the server is not connected or the topology was destroyed\n      if (server && !server.isConnected() || state.replState.state == DESTROYED) {\n        return callback();\n      } // Did we get a server\n\n\n      if (server && server.isConnected()) {\n        // Execute ismaster\n        server.command('admin.$cmd', {\n          ismaster: true\n        }, {\n          monitoring: true\n        }, function (err, r) {\n          // If the state was destroyed\n          if (state.replState.state == DESTROYED) {\n            // Destroy server instance\n            server.destroy(false, false); // Return\n\n            return callback();\n          } // Count down the number of servers left\n\n\n          serversLeft = serversLeft - 1; // If we have an error but still outstanding server request return\n\n          if (err && serversLeft > 0) {\n            return callback();\n          } // We had an error and have no more servers to inspect, schedule a new check\n\n\n          if (err && serversLeft == 0) {\n            self.emit('ha', 'end', {\n              norepeat: norepeat,\n              id: localHaId,\n              state: state.replState ? state.replState.toJSON() : {}\n            }); // Ended highAvailabilityProcessRunning\n\n            state.highAvailabilityProcessRunning = false; // Return the replicasetInquirer\n\n            return callback();\n          } // Let all the read Preferences do things to the servers\n\n\n          var rPreferencesCount = Object.keys(state.readPreferenceStrategies).length; // console.log(\"=========================== ismaster 0\")\n          // console.log(r.connection.socketTimeoutMS)\n          // Set socketTimeoutMS back\n\n          r.connection.socketTimeoutMS = r.connection.initialSocketTimeout; // console.log(\"=========================== ismaster 1\")\n          // console.log(r.connection.socketTimeoutMS)\n          // Handle the primary\n\n          var ismaster = r.result;\n          if (state.logger.isDebug()) state.logger.debug(f('[%s] monitoring process ismaster %s', state.id, JSON.stringify(ismaster))); // Update server instance ismaster to ensure proper sync\n          // when producing SDAM monitoring events\n\n          server.s.ismaster = ismaster; // Update the replicaset state\n\n          if (!state.replState.update(ismaster, server) && !state.replState.contains(server)) {\n            // Destroy the instance\n            server.destroy(); // Return\n\n            return callback();\n          } //\n          // Process hosts list from ismaster under two conditions\n          // 1. Ismaster result is from primary\n          // 2. There is no primary and the ismaster result is from a non-primary\n\n\n          if (err == null && (ismaster.ismaster || !state.primary) && Array.isArray(ismaster.hosts)) {\n            // Hosts to process\n            var hosts = ismaster.hosts; // Add arbiters to list of hosts if we have any\n\n            if (Array.isArray(ismaster.arbiters)) {\n              hosts = hosts.concat(ismaster.arbiters.map(function (x) {\n                return {\n                  host: x,\n                  arbiter: true\n                };\n              }));\n            }\n\n            if (Array.isArray(ismaster.passives)) hosts = hosts.concat(ismaster.passives); // Process all the hsots\n\n            processHosts(self, state, hosts, true);\n          } else if (err == null && !Array.isArray(ismaster.hosts)) {\n            // Destroy the instance\n            server.destroy(); // Return\n\n            return callback();\n          } // No read Preferences strategies\n\n\n          if (rPreferencesCount == 0) {\n            // Don't schedule a new inquiry\n            if (serversLeft > 0) {\n              return callback();\n            } // Emit ha process end\n\n\n            self.emit('ha', 'end', {\n              norepeat: norepeat,\n              id: localHaId,\n              state: state.replState ? state.replState.toJSON() : {}\n            }); // Ended highAvailabilityProcessRunning\n\n            state.highAvailabilityProcessRunning = false;\n            return callback();\n          } // No servers left to query, execute read preference strategies\n\n\n          if (serversLeft == 0) {\n            // Go over all the read preferences\n            for (var name in state.readPreferenceStrategies) {\n              state.readPreferenceStrategies[name].ha(self, state.replState, function () {\n                rPreferencesCount = rPreferencesCount - 1;\n\n                if (rPreferencesCount == 0) {\n                  // Add any new servers in primary ismaster\n                  if (err == null && ismaster.ismaster && Array.isArray(ismaster.hosts)) {\n                    processHosts(self, state, ismaster.hosts, true);\n                  } // Emit ha process end\n\n\n                  self.emit('ha', 'end', {\n                    norepeat: norepeat,\n                    id: localHaId,\n                    state: state.replState ? state.replState.toJSON() : {}\n                  }); // Ended highAvailabilityProcessRunning\n\n                  state.highAvailabilityProcessRunning = false;\n                  return callback();\n                }\n              });\n            }\n          }\n\n          callback();\n        });\n      }\n    }; // Go over all the servers\n\n\n    if (servers.length == 0) {\n      // Set the high availability\n      state.highAvailabilityProcessRunning = false; // Check if we need to emit a fullsetup event\n\n      checkAndEmitEvent(self, state, 'fullsetup'); // Check if we need to emit the all event\n\n      checkAndEmitEvent(self, state, 'all'); // Repeat the process\n\n      if (!norepeat) {\n        setHaTimer(self, state);\n      }\n    } // Ge the number of servers left\n\n\n    var left = servers.length; // Call ismaster on all servers\n\n    for (var i = 0; i < servers.length; i++) {\n      inspectServer(servers[i], function () {\n        left = left - 1;\n\n        if (left == 0) {\n          // Do not schedule any more replica monitoring checks\n          if (state.replState.state == DESTROYED) {\n            return;\n          } // Set the high availability\n\n\n          state.highAvailabilityProcessRunning = false; // Check if we need to emit a fullsetup event\n\n          checkAndEmitEvent(self, state, 'fullsetup'); // Check if we need to emit the all event\n\n          checkAndEmitEvent(self, state, 'all'); // Repeat the process\n\n          if (!norepeat) {\n            setHaTimer(self, state);\n          }\n        }\n      });\n    }\n  };\n}; // Error handler for initial connect\n\n\nvar errorHandlerTemp = function (self, state, event) {\n  return function (err, server) {\n    // Destroy the server\n    server.destroy(); // Log the information\n\n    if (state.logger.isInfo()) state.logger.info(f('[%s] server %s disconnected', state.id, server.lastIsMaster() ? server.lastIsMaster().me : server.name)); // Filter out any connection servers\n\n    state.initialConnectionServers = state.initialConnectionServers.filter(function (_server) {\n      return server.name != _server.name;\n    }); // Remove from list of connected servers\n\n    state.replState.removeConnectingServer(server.name); // Connection is destroyed, ignore\n\n    if (state.replState.state == DESTROYED) return; // Remove any non used handlers\n\n    ['error', 'close', 'timeout', 'connect', 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHearbeatFailed', 'serverClosed'].forEach(function (e) {\n      server.removeAllListeners(e);\n    }); // Push to list of disconnected servers\n\n    addToListIfNotExist(state.disconnectedServers, server); // End connection operation if we have no legal replicaset state\n\n    if (state.initialConnectionServers == 0 && state.replState.state == CONNECTING) {\n      if (state.secondaryOnlyConnectionAllowed && !state.replState.isSecondaryConnected() && !state.replState.isPrimaryConnected() || !state.secondaryOnlyConnectionAllowed && !state.replState.isPrimaryConnected()) {\n        if (state.logger.isInfo()) state.logger.info(f('[%s] no valid seed servers in list', state.id));\n\n        if (self.listeners('error').length > 0) {\n          return self.emit('error', new MongoError('no valid seed servers in list'));\n        }\n      }\n    } // If the number of disconnected servers is equal to\n    // the number of seed servers we cannot connect\n\n\n    if (state.disconnectedServers.length == state.seedlist.length && state.replState.state == CONNECTING) {\n      if (state.emitError && self.listeners('error').length > 0) {\n        if (state.logger.isInfo()) state.logger.info(f('[%s] no valid seed servers in list', state.id));\n\n        if (self.listeners('error').length > 0) {\n          self.emit('error', new MongoError('no valid seed servers in list'));\n        }\n      }\n    }\n  };\n}; // Connect handler\n\n\nvar connectHandler = function (self, state, calledFromSDAM) {\n  return function (server) {\n    if (state.logger.isInfo()) state.logger.info(f('[%s] connected to %s', state.id, server.name)); // Destroyed connection\n\n    if (state.replState.state == DESTROYED) {\n      return server.destroy(false, false);\n    } // Filter out any connection servers\n\n\n    state.initialConnectionServers = state.initialConnectionServers.filter(function (_server) {\n      return server.name != _server.name;\n    });\n    var ismaster = server.lastIsMaster(); // Process the new server\n\n    var processNewServer = function () {\n      // Discover any additional servers\n      var ismaster = server.lastIsMaster(); // Deal with events\n\n      var events = ['error', 'close', 'timeout', 'connect', 'message', 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHearbeatFailed', 'serverClosed']; // Remove any non used handlers\n\n      events.forEach(function (e) {\n        server.removeAllListeners(e);\n      }); // Clean up\n      // delete state.connectingServers[server.name];\n\n      state.replState.removeConnectingServer(server.name); // Update the replicaset state, destroy if not added\n\n      if (!state.replState.update(ismaster, server) && !state.replState.contains(server)) {\n        // Destroy the server instance\n        server.destroy(); // No more candiate servers\n\n        if (state.state == CONNECTING && state.initialConnectionServers.length == 0 && state.replState.primary == null && state.replState.secondaries.length == 0) {\n          return self.emit('error', new MongoError(\"no replicaset members found in seedlist\"));\n        }\n\n        return;\n      } // Add the server handling code\n\n\n      if (server.isConnected()) {\n        server.on('error', errorHandler(self, state));\n        server.on('close', closeHandler(self, state));\n        server.on('timeout', timeoutHandler(self, state)); // SDAM Monitoring events\n\n        server.on('serverOpening', function (e) {\n          self.emit('serverOpening', e);\n        });\n        server.on('serverDescriptionChanged', function (e) {\n          self.emit('serverDescriptionChanged', e);\n        });\n        server.on('serverHeartbeatStarted', function (e) {\n          self.emit('serverHeartbeatStarted', e);\n        });\n        server.on('serverHeartbeatSucceeded', function (e) {\n          self.emit('serverHeartbeatSucceeded', e);\n        });\n        server.on('serverHearbeatFailed', function (e) {\n          self.emit('serverHearbeatFailed', e);\n        });\n        server.on('serverClosed', function (e) {\n          self.emit('serverClosed', e);\n        });\n      } // Hosts to process\n\n\n      var hosts = ismaster.hosts; // Add arbiters to list of hosts if we have any\n\n      if (Array.isArray(ismaster.arbiters)) {\n        hosts = hosts.concat(ismaster.arbiters.map(function (x) {\n          return {\n            host: x,\n            arbiter: true\n          };\n        }));\n      }\n\n      if (Array.isArray(ismaster.passives)) hosts = hosts.concat(ismaster.passives); // Add any new servers\n\n      processHosts(self, state, hosts, calledFromSDAM); // If have the server instance already destroy it\n\n      if (!calledFromSDAM && state.initialConnectionServers.length == 0 && state.replState.connectingServersCount() == 0 && !state.replState.isPrimaryConnected() && !state.secondaryOnlyConnectionAllowed && state.replState.state == CONNECTING) {\n        if (state.logger.isInfo()) state.logger.info(f('[%s] no primary found in replicaset', state.id));\n        self.emit('error', new MongoError(\"no primary found in replicaset\"));\n        return self.destroy();\n      } // Check if we need to emit a fullsetup event\n\n\n      checkAndEmitEvent(self, state, 'fullsetup'); // Check if we need to emit the all event\n\n      checkAndEmitEvent(self, state, 'all');\n    }; // Save up new members to be authenticated against\n\n\n    if (self.s.authInProgress) {\n      self.s.authInProgressServers.push(server);\n    } // No credentials just process server\n\n\n    if (state.credentials.length == 0) {\n      return processNewServer();\n    } // Apply all the credentials serially\n\n\n    var applyCredentials = function (server, index, credentials, callback) {\n      // Do not apply credentials if we have an arbiter\n      if (server.lastIsMaster() && server.lastIsMaster().arbiterOnly) return callback(); // Done applying the credentials return\n\n      if (index >= credentials.length || credentials.length == 0) return callback(); // Apply the credential\n\n      server.auth.apply(server, credentials[index].concat([function (err, r) {\n        if (err) return callback(err);\n        applyCredentials(server, index + 1, credentials, callback);\n      }]));\n    };\n\n    applyCredentials(server, 0, state.credentials, function (err) {\n      if (err || state.replState.state == DESTROYED) {\n        return server.destroy(false, false);\n      } // Did not fail the authentication, process the instance\n\n\n      processNewServer();\n    });\n  };\n}; //\n// Detect if we need to add new servers\n\n\nvar processHosts = function (self, state, hosts, calledFromSDAM) {\n  if (state.replState.state == DESTROYED) return;\n\n  if (Array.isArray(hosts)) {\n    // Check any hosts exposed by ismaster\n    for (var i = 0; i < hosts.length; i++) {\n      // Get the object\n      var host = hosts[i];\n      var options = {}; // Do we have an arbiter\n\n      if (typeof host == 'object') {\n        host = host.host;\n        options.arbiter = host.arbiter;\n      } // If not found we need to create a new connection\n\n\n      if (!state.replState.contains(host)) {\n        if (!state.replState.isConnectingServer(host) && !inInitialConnectingServers(self, state, host)) {\n          if (state.logger.isInfo()) state.logger.info(f('[%s] scheduled server %s for connection', state.id, host)); // Make sure we know what is trying to connect\n\n          state.replState.addConnectingServer(host, host); // Connect the server\n\n          connectToServer(self, state, host.split(':')[0], parseInt(host.split(':')[1], 10), calledFromSDAM, options);\n        }\n      }\n    }\n  }\n};\n\nvar inInitialConnectingServers = function (self, state, address) {\n  for (var i = 0; i < state.initialConnectionServers.length; i++) {\n    if (state.initialConnectionServers[i].name == address) return true;\n  }\n\n  return false;\n}; // Connect to a new server\n\n\nvar connectToServer = function (self, state, host, port, calledFromSDAM, options) {\n  options = options || {};\n  var opts = cloneOptions(state.options);\n  opts.host = host;\n  opts.port = port;\n  opts.reconnect = false;\n  opts.readPreferenceStrategies = state.readPreferenceStrategies;\n  if (state.tag) opts.tag = state.tag; // Share the auth store\n\n  opts.authProviders = state.authProviders;\n  opts.emitError = true; // Server is in topology\n\n  opts.inTopology = true; // Set the size to size + 1 and mark monitoring\n\n  opts.size = opts.size + 1;\n  opts.monitoring = true;\n  opts.topologyId = self.s.id; // Do we have an arbiter set the poolSize to 1\n\n  if (options.arbiter) {\n    opts.size = 1;\n  } // Do not create a new server instance\n\n\n  if (self.s.replState.state == DESTROYED) return; // Create a new server instance\n\n  var server = new Server(opts); // Handle the ismaster\n\n  server.on('ismaster', handleIsmaster(self)); // Set up the event handlers\n\n  server.once('error', errorHandlerTemp(self, state, 'error'));\n  server.once('close', errorHandlerTemp(self, state, 'close'));\n  server.once('timeout', errorHandlerTemp(self, state, 'timeout'));\n  server.once('connect', connectHandler(self, state, calledFromSDAM)); // SDAM Monitoring events\n\n  server.on('serverOpening', function (e) {\n    self.emit('serverOpening', e);\n  });\n  server.on('serverDescriptionChanged', function (e) {\n    self.emit('serverDescriptionChanged', e);\n  });\n  server.on('serverHeartbeatStarted', function (e) {\n    self.emit('serverHeartbeatStarted', e);\n  });\n  server.on('serverHeartbeatSucceeded', function (e) {\n    self.emit('serverHeartbeatSucceeded', e);\n  });\n  server.on('serverHearbeatFailed', function (e) {\n    self.emit('serverHearbeatFailed', e);\n  });\n  server.on('serverClosed', function (e) {\n    self.emit('serverClosed', e);\n  }); // Ensure we schedule the opening of new socket\n  // on separate ticks of the event loop\n\n  var execute = function (_server) {\n    // Attempt to connect\n    process.nextTick(function () {\n      if (self.s.replState.state == DESTROYED) return;\n\n      _server.connect();\n    });\n  }; // Add server as connecting\n\n\n  state.replState.addConnectingServer(server.name, host); // Attempt connection of server\n\n  execute(server);\n}; //\n// Add server to the list if it does not exist\n\n\nvar addToListIfNotExist = function (list, server) {\n  var found = false; // If the server is a null value return false\n\n  if (server == null) return found; // Remove any non used handlers\n\n  ['error', 'close', 'timeout', 'connect', 'serverOpening', 'serverDescriptionChanged', 'serverHeartbeatStarted', 'serverHeartbeatSucceeded', 'serverHearbeatFailed', 'serverClosed'].forEach(function (e) {\n    server.removeAllListeners(e);\n  }); // Check if the server already exists\n\n  for (var i = 0; i < list.length; i++) {\n    if (list[i].equals(server)) found = true;\n  }\n\n  if (!found) {\n    list.push(server);\n  }\n\n  return found;\n};\n\nvar errorHandler = function (self, state) {\n  return function (err, server) {\n    // Destroy the server\n    server.destroy(); // Remove from list of connected servers\n\n    state.replState.removeConnectingServer(server.name); // Check if destroyed the topology\n\n    if (state.replState.state == DESTROYED) return;\n    if (state.logger.isInfo()) state.logger.info(f('[%s] server %s errored out with %s', state.id, server.lastIsMaster() ? server.lastIsMaster().me : server.name, JSON.stringify(err)));\n    var found = addToListIfNotExist(state.disconnectedServers, server);\n    if (!found) self.emit('left', state.replState.remove(server), server);\n    if (found && state.emitError && self.listeners('error').length > 0) self.emit('error', err, server);\n  };\n};\n\nvar timeoutHandler = function (self, state) {\n  return function (err, server) {\n    // Destroy the server\n    server.destroy(); // Remove from list of connected servers\n\n    state.replState.removeConnectingServer(server.name); // Check if destroyed the topology\n\n    if (state.replState.state == DESTROYED) return;\n    if (state.logger.isInfo()) state.logger.info(f('[%s] server %s timed out', state.id, server.lastIsMaster() ? server.lastIsMaster().me : server.name));\n    var found = addToListIfNotExist(state.disconnectedServers, server);\n    if (!found) self.emit('left', state.replState.remove(server), server);\n  };\n};\n\nvar closeHandler = function (self, state) {\n  return function (err, server) {\n    // Destroy the server\n    server.destroy(); // Remove from list of connected servers\n\n    state.replState.removeConnectingServer(server.name); // Check if destroyed the topology\n\n    if (state.replState.state == DESTROYED) return;\n    if (state.logger.isInfo()) state.logger.info(f('[%s] server %s closed', state.id, server.lastIsMaster() ? server.lastIsMaster().me : server.name));\n    var found = addToListIfNotExist(state.disconnectedServers, server);\n\n    if (!found) {\n      self.emit('left', state.replState.remove(server), server);\n    }\n  };\n}; //\n// Validate if a non-master or recovering error\n\n\nvar notMasterError = function (r) {\n  // Get result of any\n  var result = r && r.result ? r.result : r; // Explore if we have a not master error\n\n  if (result && (result.err == 'not master' || result.errmsg == 'not master' || result['$err'] && result['$err'].indexOf('not master or secondary') != -1 || result['$err'] && result['$err'].indexOf(\"not master and slaveOk=false\") != -1 || result.errmsg == 'node is recovering')) {\n    return true;\n  }\n\n  return false;\n};\n\nmodule.exports = ReplSet;","map":null,"metadata":{},"sourceType":"script"}