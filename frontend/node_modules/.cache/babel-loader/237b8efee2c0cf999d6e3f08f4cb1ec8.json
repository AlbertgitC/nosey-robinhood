{"ast":null,"code":"var ansiRegex = require('ansi-regex');\n\nvar wcwidth;\n\ntry {\n  wcwidth = require('wcwidth');\n} catch (e) {}\n\nmodule.exports = Table;\n\nfunction Table() {\n  this.rows = [];\n  this.row = {\n    __printers: {}\n  };\n}\n/**\n * Push the current row to the table and start a new one\n *\n * @returns {Table} `this`\n */\n\n\nTable.prototype.newRow = function () {\n  this.rows.push(this.row);\n  this.row = {\n    __printers: {}\n  };\n  return this;\n};\n/**\n * Write cell in the current row\n *\n * @param {String} col          - Column name\n * @param {Any} val             - Cell value\n * @param {Function} [printer]  - Printer function to format the value\n * @returns {Table} `this`\n */\n\n\nTable.prototype.cell = function (col, val, printer) {\n  this.row[col] = val;\n  this.row.__printers[col] = printer || string;\n  return this;\n};\n/**\n * String to separate columns\n */\n\n\nTable.prototype.separator = '  ';\n\nfunction string(val) {\n  return val === undefined ? '' : '' + val;\n}\n\nfunction length(str) {\n  var s = str.replace(ansiRegex(), '');\n  return wcwidth == null ? s.length : wcwidth(s);\n}\n/**\n * Default printer\n */\n\n\nTable.string = string;\n/**\n * Create a printer which right aligns the content by padding with `ch` on the left\n *\n * @param {String} ch\n * @returns {Function}\n */\n\nTable.leftPadder = leftPadder;\n\nfunction leftPadder(ch) {\n  return function (val, width) {\n    var str = string(val);\n    var len = length(str);\n    var pad = width > len ? Array(width - len + 1).join(ch) : '';\n    return pad + str;\n  };\n}\n/**\n * Printer which right aligns the content\n */\n\n\nvar padLeft = Table.padLeft = leftPadder(' ');\n/**\n * Create a printer which pads with `ch` on the right\n *\n * @param {String} ch\n * @returns {Function}\n */\n\nTable.rightPadder = rightPadder;\n\nfunction rightPadder(ch) {\n  return function padRight(val, width) {\n    var str = string(val);\n    var len = length(str);\n    var pad = width > len ? Array(width - len + 1).join(ch) : '';\n    return str + pad;\n  };\n}\n\nvar padRight = rightPadder(' ');\n/**\n * Create a printer for numbers\n *\n * Will do right alignment and optionally fix the number of digits after decimal point\n *\n * @param {Number} [digits] - Number of digits for fixpoint notation\n * @returns {Function}\n */\n\nTable.number = function (digits) {\n  return function (val, width) {\n    if (val == null) return '';\n    if (typeof val != 'number') throw new Error('' + val + ' is not a number');\n    var str = digits == null ? val + '' : val.toFixed(digits);\n    return padLeft(str, width);\n  };\n};\n\nfunction each(row, fn) {\n  for (var key in row) {\n    if (key == '__printers') continue;\n    fn(key, row[key]);\n  }\n}\n/**\n * Get list of columns in printing order\n *\n * @returns {string[]}\n */\n\n\nTable.prototype.columns = function () {\n  var cols = {};\n\n  for (var i = 0; i < 2; i++) {\n    // do 2 times\n    this.rows.forEach(function (row) {\n      var idx = 0;\n      each(row, function (key) {\n        idx = Math.max(idx, cols[key] || 0);\n        cols[key] = idx;\n        idx++;\n      });\n    });\n  }\n\n  return Object.keys(cols).sort(function (a, b) {\n    return cols[a] - cols[b];\n  });\n};\n/**\n * Format just rows, i.e. print the table without headers and totals\n *\n * @returns {String} String representaion of the table\n */\n\n\nTable.prototype.print = function () {\n  var cols = this.columns();\n  var separator = this.separator;\n  var widths = {};\n  var out = ''; // Calc widths\n\n  this.rows.forEach(function (row) {\n    each(row, function (key, val) {\n      var str = row.__printers[key].call(row, val);\n\n      widths[key] = Math.max(length(str), widths[key] || 0);\n    });\n  }); // Now print\n\n  this.rows.forEach(function (row) {\n    var line = '';\n    cols.forEach(function (key) {\n      var width = widths[key];\n      var str = row.hasOwnProperty(key) ? '' + row.__printers[key].call(row, row[key], width) : '';\n      line += padRight(str, width) + separator;\n    });\n    line = line.slice(0, -separator.length);\n    out += line + '\\n';\n  });\n  return out;\n};\n/**\n * Format the table\n *\n * @returns {String}\n */\n\n\nTable.prototype.toString = function () {\n  var cols = this.columns();\n  var out = new Table(); // copy options\n\n  out.separator = this.separator; // Write header\n\n  cols.forEach(function (col) {\n    out.cell(col, col);\n  });\n  out.newRow();\n  out.pushDelimeter(cols); // Write body\n\n  out.rows = out.rows.concat(this.rows); // Totals\n\n  if (this.totals && this.rows.length) {\n    out.pushDelimeter(cols);\n    this.forEachTotal(out.cell.bind(out));\n    out.newRow();\n  }\n\n  return out.print();\n};\n/**\n * Push delimeter row to the table (with each cell filled with dashs during printing)\n *\n * @param {String[]} [cols]\n * @returns {Table} `this`\n */\n\n\nTable.prototype.pushDelimeter = function (cols) {\n  cols = cols || this.columns();\n  cols.forEach(function (col) {\n    this.cell(col, undefined, leftPadder('-'));\n  }, this);\n  return this.newRow();\n};\n/**\n * Compute all totals and yield the results to `cb`\n *\n * @param {Function} cb - Callback function with signature `(column, value, printer)`\n */\n\n\nTable.prototype.forEachTotal = function (cb) {\n  for (var key in this.totals) {\n    var aggr = this.totals[key];\n    var acc = aggr.init;\n    var len = this.rows.length;\n    this.rows.forEach(function (row, idx) {\n      acc = aggr.reduce.call(row, acc, row[key], idx, len);\n    });\n    cb(key, acc, aggr.printer);\n  }\n};\n/**\n * Format the table so that each row represents column and each column represents row\n *\n * @param {Object} [opts]\n * @param {String} [ops.separator] - Column separation string\n * @param {Function} [opts.namePrinter] - Printer to format column names\n * @returns {String}\n */\n\n\nTable.prototype.printTransposed = function (opts) {\n  opts = opts || {};\n  var out = new Table();\n  out.separator = opts.separator || this.separator;\n  this.columns().forEach(function (col) {\n    out.cell(0, col, opts.namePrinter);\n    this.rows.forEach(function (row, idx) {\n      out.cell(idx + 1, row[col], row.__printers[col]);\n    });\n    out.newRow();\n  }, this);\n  return out.print();\n};\n/**\n * Sort the table\n *\n * @param {Function|string[]} [cmp] - Either compare function or a list of columns to sort on\n * @returns {Table} `this`\n */\n\n\nTable.prototype.sort = function (cmp) {\n  if (typeof cmp == 'function') {\n    this.rows.sort(cmp);\n    return this;\n  }\n\n  var keys = Array.isArray(cmp) ? cmp : this.columns();\n  var comparators = keys.map(function (key) {\n    var order = 'asc';\n    var m = /(.*)\\|\\s*(asc|des)\\s*$/.exec(key);\n\n    if (m) {\n      key = m[1];\n      order = m[2];\n    }\n\n    return function (a, b) {\n      return order == 'asc' ? compare(a[key], b[key]) : compare(b[key], a[key]);\n    };\n  });\n  return this.sort(function (a, b) {\n    for (var i = 0; i < comparators.length; i++) {\n      var order = comparators[i](a, b);\n      if (order != 0) return order;\n    }\n\n    return 0;\n  });\n};\n\nfunction compare(a, b) {\n  if (a === b) return 0;\n  if (a === undefined) return 1;\n  if (b === undefined) return -1;\n  if (a === null) return 1;\n  if (b === null) return -1;\n  if (a > b) return 1;\n  if (a < b) return -1;\n  return compare(String(a), String(b));\n}\n/**\n * Add a total for the column\n *\n * @param {String} col - column name\n * @param {Object} [opts]\n * @param {Function} [opts.reduce = sum] - reduce(acc, val, idx, length) function to compute the total value\n * @param {Function} [opts.printer = padLeft] - Printer to format the total cell\n * @param {Any} [opts.init = 0] - Initial value for reduction\n * @returns {Table} `this`\n */\n\n\nTable.prototype.total = function (col, opts) {\n  opts = opts || {};\n  this.totals = this.totals || {};\n  this.totals[col] = {\n    reduce: opts.reduce || Table.aggr.sum,\n    printer: opts.printer || padLeft,\n    init: opts.init == null ? 0 : opts.init\n  };\n  return this;\n};\n/**\n * Predefined helpers for totals\n */\n\n\nTable.aggr = {};\n/**\n * Create a printer which formats the value with `printer`,\n * adds the `prefix` to it and right aligns the whole thing\n *\n * @param {String} prefix\n * @param {Function} printer\n * @returns {printer}\n */\n\nTable.aggr.printer = function (prefix, printer) {\n  printer = printer || string;\n  return function (val, width) {\n    return padLeft(prefix + printer(val), width);\n  };\n};\n/**\n * Sum reduction\n */\n\n\nTable.aggr.sum = function (acc, val) {\n  return acc + val;\n};\n/**\n * Average reduction\n */\n\n\nTable.aggr.avg = function (acc, val, idx, len) {\n  acc = acc + val;\n  return idx + 1 == len ? acc / len : acc;\n};\n/**\n * Print the array or object\n *\n * @param {Array|Object} obj - Object to print\n * @param {Function|Object} [format] - Format options\n * @param {Function} [cb] - Table post processing and formating\n * @returns {String}\n */\n\n\nTable.print = function (obj, format, cb) {\n  var opts = format || {};\n  format = typeof format == 'function' ? format : function (obj, cell) {\n    for (var key in obj) {\n      if (!obj.hasOwnProperty(key)) continue;\n      var params = opts[key] || {};\n      cell(params.name || key, obj[key], params.printer);\n    }\n  };\n  var t = new Table();\n  var cell = t.cell.bind(t);\n\n  if (Array.isArray(obj)) {\n    cb = cb || function (t) {\n      return t.toString();\n    };\n\n    obj.forEach(function (item) {\n      format(item, cell);\n      t.newRow();\n    });\n  } else {\n    cb = cb || function (t) {\n      return t.printTransposed({\n        separator: ' : '\n      });\n    };\n\n    format(obj, cell);\n    t.newRow();\n  }\n\n  return cb(t);\n};\n/**\n * Same as `Table.print()` but yields the result to `console.log()`\n */\n\n\nTable.log = function (obj, format, cb) {\n  console.log(Table.print(obj, format, cb));\n};\n/**\n * Same as `.toString()` but yields the result to `console.log()`\n */\n\n\nTable.prototype.log = function () {\n  console.log(this.toString());\n};","map":null,"metadata":{},"sourceType":"script"}