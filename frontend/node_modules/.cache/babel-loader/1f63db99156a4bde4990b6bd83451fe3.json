{"ast":null,"code":"\"use strict\";\n\nvar inherits = require('util').inherits,\n    EventEmitter = require('events').EventEmitter,\n    Connection = require('./connection'),\n    Query = require('./commands').Query,\n    Logger = require('./logger'),\n    f = require('util').format;\n\nvar DISCONNECTED = 'disconnected';\nvar CONNECTING = 'connecting';\nvar CONNECTED = 'connected';\nvar DESTROYED = 'destroyed';\nvar _id = 0;\n/**\n * Creates a new Pool instance\n * @class\n * @param {string} options.host The server host\n * @param {number} options.port The server port\n * @param {number} [options.size=1] Max server connection pool size\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=0] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n * @param {number} [options.monitoringSocketTimeout=30000] TCP Socket timeout setting for replicaset monitoring socket\n * @param {boolean} [options.singleBufferSerializtion=true] Serialize into single buffer, trade of peak memory for serialization speed\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passPhrase] SSL Certificate pass phrase\n * @param {boolean} [options.rejectUnauthorized=false] Reject unauthorized server certificates\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @fires Pool#connect\n * @fires Pool#close\n * @fires Pool#error\n * @fires Pool#timeout\n * @fires Pool#parseError\n * @return {Pool} A cursor instance\n */\n\nvar Pool = function (options) {\n  var self = this; // Add event listener\n\n  EventEmitter.call(this); // Set empty if no options passed\n\n  this.options = options || {};\n  this.size = typeof options.size == 'number' && !isNaN(options.size) ? options.size : 5;\n  this.waitMS = typeof options.waitMS == 'number' && !isNaN(options.waitMS) ? options.waitMS : 1000; // Save host and port\n\n  this.host = options.host;\n  this.port = options.port; // Message handler\n\n  this.messageHandler = options.messageHandler; // No bson parser passed in\n\n  if (!options.bson) throw new Error(\"must pass in valid bson parser\"); // // Contains all connections\n  // this.connections = [];\n  // Contains all available connections\n\n  this.availableConnections = [];\n  this.inUseConnections = [];\n  this.newConnections = [];\n  this.connectingConnections = []; // Current status of the pool\n\n  this.state = DISCONNECTED; // Round robin index\n\n  this.index = 0;\n  this.dead = false; // Logger instance\n\n  this.logger = Logger('Pool', options); // Pool id\n\n  this.id = _id++; // Grouping tag used for debugging purposes\n\n  this.tag = options.tag; // Operation work queue\n\n  this.queue = []; // Currently executing\n\n  this.executing = false; // Unref pool\n\n  this.unreference = false; // Set the monitoring connection timeout\n\n  this.monitoringSocketTimeout = typeof options.monitoringSocketTimeout == 'number' ? options.monitoringSocketTimeout : options.connectionTimeout;\n  this.monitoringSocketTimeout = typeof this.monitoringSocketTimeout == 'number' ? this.monitoringSocketTimeout : 30000;\n};\n\ninherits(Pool, EventEmitter);\n\nvar removeConnection = function (self, connection) {\n  // Destroy connection\n  connection.destroy(); // Remove connection method\n\n  var remove = function (connections) {\n    for (var i = 0; i < connections.length; i++) {\n      if (connections[i] === connection) {\n        connections.splice(i, 1);\n        return true;\n      }\n    }\n  }; // Clean out the connection\n\n\n  if (remove(self.availableConnections)) return;\n  if (remove(self.inUseConnections)) return;\n  if (remove(self.newConnections)) return;\n  if (remove(self.connectingConnections)) return;\n};\n\nvar errorHandler = function (self) {\n  return function (err, connection) {\n    if (self.logger.isDebug()) self.logger.debug(f('pool [%s] errored out [%s] with connection [%s]', this.dead, JSON.stringify(err), JSON.stringify(connection))); // Destroy the connection\n\n    connection.destroy(); // Remove the connection\n\n    removeConnection(self, connection); // Emit error\n\n    if (self.listeners('error').length > 0) {\n      self.emit('error', err, connection);\n    }\n  };\n};\n\nvar timeoutHandler = function (self) {\n  return function (err, connection) {\n    if (self.logger.isDebug()) self.logger.debug(f('pool [%s] timed out [%s] with connection [%s]', this.dead, JSON.stringify(err), JSON.stringify(connection))); // Destroy the connection\n\n    connection.destroy(); // Remove the connection\n\n    removeConnection(self, connection); // Set disconnected if pool is empty\n\n    if (self.getAll().length == 0) self.state = DISCONNECTED; // Emit connection timeout to server instance\n\n    self.emit('timeout', err, connection);\n  };\n};\n\nvar closeHandler = function (self) {\n  return function (err, connection) {\n    if (self.logger.isDebug()) self.logger.debug(f('pool [%s] closed [%s] with connection [%s]', this.dead, JSON.stringify(err), JSON.stringify(connection))); // Destroy the connection\n\n    connection.destroy(); // Remove the connection\n\n    removeConnection(self, connection); // Set disconnected if pool is empty\n\n    if (self.getAll().length == 0) self.state = DISCONNECTED; // Emit connection close to server instance\n\n    self.emit('close', err, connection);\n  };\n};\n\nvar parseErrorHandler = function (self) {\n  return function (err, connection) {\n    if (self.logger.isDebug()) self.logger.debug(f('pool [%s] errored out [%s] with connection [%s]', this.dead, JSON.stringify(err), JSON.stringify(connection))); // Destroy the connection\n\n    connection.destroy(); // Remove the connection\n\n    removeConnection(self, connection); // Set disconnected if pool is empty\n\n    if (self.getAll().length == 0) self.state = DISCONNECTED; // Emit error to server instance\n\n    self.emit('parseError', err, connection);\n  };\n};\n/**\n * Unref the pool\n * @method\n */\n\n\nPool.prototype.unref = function () {\n  this.unreference = true;\n  this.getAll().forEach(function (c) {\n    c.unref();\n  });\n};\n/**\n * Destroy pool\n * @method\n */\n\n\nPool.prototype.destroy = function () {\n  this.state = DESTROYED; // Set dead\n\n  this.dead = true; // Get all the connections\n\n  var connections = this.getAll(); // Destroy all the connections\n\n  connections.forEach(function (c) {\n    // Destroy all event emitters\n    [\"close\", \"message\", \"error\", \"timeout\", \"parseError\", \"connect\"].forEach(function (e) {\n      c.removeAllListeners(e);\n    }); // Destroy the connection\n\n    c.destroy();\n  }); // Wipe out all connection arrays\n\n  this.availableConnections = [];\n  this.connectingConnections = [];\n  this.inUseConnections = [];\n  this.newConnections = [];\n};\n/**\n * Connect pool\n * @method\n */\n\n\nPool.prototype.connect = function (_options) {\n  var self = this; // Set to connecting\n\n  this.state = CONNECTING; // No dead\n\n  this.dead = false; // Set the message handler\n\n  self.options.messageHandler = self.messageHandler; // Create a new connection\n\n  var connection = new Connection(self.options); // Delete all the event handlers\n\n  ['close', 'error', 'timeout', 'parseError', 'connect'].forEach(function (x) {\n    connection.removeAllListeners(x);\n  }); // Add all handlers\n\n  connection.once('close', closeHandler(self));\n  connection.once('error', errorHandler(self));\n  connection.once('timeout', timeoutHandler(self));\n  connection.once('parseError', parseErrorHandler(self));\n  connection.on('connect', function (connection) {\n    if (self.state == DESTROYED) {\n      return connection.destroy();\n    }\n\n    if (self.state == CONNECTING) {\n      self.state = CONNECTED;\n    } // Add the connection to the list of available connections\n\n\n    self.availableConnections.push(connection); // Emit connected event\n\n    self.emit(\"connect\", self);\n  }); // Start connection\n\n  connection.connect(_options);\n};\n\nvar _createConnection = function (self) {\n  self.options.messageHandler = self.messageHandler;\n  var connection = new Connection(self.options); // Push the connection\n\n  self.connectingConnections.push(connection); // Handle any errors\n\n  var tempErrorHandler = function (_connection) {\n    return function (err) {\n      // Destroy the connection\n      _connection.destroy(); // Remove the connection from the connectingConnections list\n\n\n      removeConnection(self, connection);\n    };\n  }; // All event handlers\n\n\n  var handlers = [\"close\", \"message\", \"error\", \"timeout\", \"parseError\", \"connect\"]; // Handle successful connection\n\n  var tempConnectHandler = function (_connection) {\n    return function () {\n      if (self.state == DESTROYED) {\n        // Remove the connection from the connectingConnections\n        var index = self.connectingConnections.indexOf(_connection);\n\n        if (index != -1) {\n          self.connectingConnections.splice(index, 1);\n        }\n\n        return _connection.destroy();\n      } // Destroy all event emitters\n\n\n      handlers.forEach(function (e) {\n        _connection.removeAllListeners(e);\n      }); // Add the final handlers\n\n      _connection.once('close', closeHandler(self));\n\n      _connection.once('error', errorHandler(self));\n\n      _connection.once('timeout', timeoutHandler(self));\n\n      _connection.once('parseError', parseErrorHandler(self)); // Remove the connection from the connectingConnections\n\n\n      var index = self.connectingConnections.indexOf(_connection);\n\n      if (index != -1) {\n        self.connectingConnections.splice(index, 1);\n      } // Add to queue of new connection\n\n\n      self.newConnections.push(_connection); // Emit connection to server instance\n      // alowing it to apply any needed authentication\n\n      self.emit('connection', _connection); // Execute any work waiting\n\n      _execute(self)();\n    };\n  }; // Add all handlers\n\n\n  connection.once('close', tempErrorHandler(connection));\n  connection.once('error', tempErrorHandler(connection));\n  connection.once('timeout', tempErrorHandler(connection));\n  connection.once('parseError', tempErrorHandler(connection));\n  connection.once('connect', tempConnectHandler(connection)); // Start connection\n\n  connection.connect();\n};\n\nvar _execute = function (self) {\n  return function () {\n    if (self.state == DESTROYED) return; // Already executing, skip\n\n    if (self.executing) return; // Set pool as executing\n\n    self.executing = true; // Total availble connections\n\n    var totalConnections = self.availableConnections.length + self.connectingConnections.length + self.inUseConnections.length + self.newConnections.length; // Have we not reached the max connection size yet\n\n    if (self.availableConnections.length == 0 && self.connectingConnections.length == 0 && totalConnections < self.size && self.queue.length > 0) {\n      // Create a new connection\n      _createConnection(self); // Attempt to execute again\n\n\n      self.executing = false;\n      return;\n    } // Number of ops to do\n\n\n    var numberOfOps = self.availableConnections.length > self.queue.length ? self.queue.length : self.availableConnections.length; // As long as we have available connections\n\n    while (true) {\n      // No available connections available\n      if (self.availableConnections.length == 0) break;\n      if (self.queue.length == 0) break; // Get a connection\n\n      var connection = self.availableConnections.pop();\n\n      if (connection.isConnected()) {\n        var workItem = self.queue.shift(); // Add connection to callback so we can flush out\n        // only ops for that connection on a socket closure\n\n        if (workItem.cb) {\n          workItem.cb.connection = connection;\n        } // Get actual binary commands\n\n\n        var buffer = workItem.buffer; // Add connection to workers in flight\n\n        self.inUseConnections.push(connection);\n\n        if (Array.isArray(buffer)) {\n          for (var i = 0; i < buffer.length; i++) {\n            connection.write(buffer[i]);\n          }\n        } else {\n          connection.write(buffer);\n        } // If we are monitoring, set the socket timeout to\n        // different value until it returns\n\n\n        if (workItem.monitoring) {\n          connection.socketTimeoutMS = self.monitoringSocketTimeout;\n        } // Fire and forgot message\n\n\n        if (workItem.immediateRelease) {\n          self.availableConnections.push(connection);\n          self.inUseConnections.pop();\n        }\n      }\n    }\n\n    self.executing = false;\n  };\n};\n/**\n * Write a message to MongoDB\n * @method\n * @return {Connection}\n */\n\n\nPool.prototype.write = function (buffer, cb, options) {\n  // Do we have an operation\n  var operation = {\n    buffer: buffer,\n    cb: cb\n  }; // Is it a monitoring operation\n\n  if (options && options.monitoring) {\n    operation.monitoring = true;\n  } // Do we immediately release the connection back to available (fire and forget)\n\n\n  if (options && options.immediateRelease) {\n    operation.immediateRelease = true;\n  } // Push the operation to the queue of operations in progress\n\n\n  this.queue.push(operation); // Attempt to write all buffers out\n\n  _execute(this)();\n};\n/**\n * Make a passed connection available\n * @method\n * @return {Connection}\n */\n\n\nPool.prototype.connectionAvailable = function (connection) {\n  // Get the connection from the newConnections\n  var index = this.newConnections.indexOf(connection);\n\n  if (index != -1) {\n    this.newConnections.splice(index, 1);\n  } // If it's in the inUseConnections\n\n\n  index = this.inUseConnections.indexOf(connection);\n\n  if (index != -1) {\n    this.inUseConnections.splice(index, 1);\n  } // Add the connection to available connections if it's not a monitoring threads\n\n\n  if (this.availableConnections.indexOf(connection) == -1) {\n    this.availableConnections.push(connection);\n  } // Fire execute loop\n\n\n  _execute(this)();\n};\n/**\n * Get a pool connection (round-robin)\n * @method\n * @return {Connection}\n */\n\n\nPool.prototype.get = function (options) {\n  options = options || {}; // Set the current index\n\n  this.index = this.index + 1; // Get all connections\n\n  var connections = this.availableConnections.slice(0);\n\n  if (connections.length == 1) {\n    return connections[0];\n  } else {\n    this.index = this.index % connections.length;\n    return connections[this.index];\n  }\n};\n/**\n * Get all pool connections\n * @method\n * @return {array}\n */\n\n\nPool.prototype.getAll = function () {\n  return this.availableConnections.concat(this.inUseConnections).concat(this.connectingConnections).concat(this.newConnections);\n};\n/**\n * Is the pool connected\n * @method\n * @return {boolean}\n */\n\n\nPool.prototype.isConnected = function () {\n  // Available connections\n  for (var i = 0; i < this.availableConnections.length; i++) {\n    if (this.availableConnections[i].isConnected()) return true;\n  } // inUseConnections\n\n\n  for (var i = 0; i < this.inUseConnections.length; i++) {\n    if (this.inUseConnections[i].isConnected()) return true;\n  }\n\n  for (var i = 0; i < this.newConnections.length; i++) {\n    if (this.newConnections[i].isConnected()) return true;\n  }\n\n  return false;\n};\n/**\n * Was the pool destroyed\n * @method\n * @return {boolean}\n */\n\n\nPool.prototype.isDestroyed = function () {\n  return this.state == DESTROYED;\n};\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Pool#connect\n * @type {Pool}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Pool#close\n * @type {Pool}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Pool#error\n * @type {Pool}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Pool#timeout\n * @type {Pool}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Pool#parseError\n * @type {Pool}\n */\n\n\nmodule.exports = Pool;","map":null,"metadata":{},"sourceType":"script"}