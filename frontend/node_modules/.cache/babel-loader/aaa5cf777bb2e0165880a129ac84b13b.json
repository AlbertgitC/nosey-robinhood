{"ast":null,"code":"\"use strict\";\n\nvar f = require('util').format,\n    crypto = require('crypto'),\n    require_optional = require('require_optional'),\n    MongoError = require('../error');\n\nvar AuthSession = function (db, username, password, options) {\n  this.db = db;\n  this.username = username;\n  this.password = password;\n  this.options = options;\n};\n\nAuthSession.prototype.equal = function (session) {\n  return session.db == this.db && session.username == this.username && session.password == this.password;\n}; // Kerberos class\n\n\nvar Kerberos = null;\nvar MongoAuthProcess = null; // Try to grab the Kerberos class\n\ntry {\n  Kerberos = require_optional('kerberos').Kerberos; // Authentication process for Mongo\n\n  MongoAuthProcess = require_optional('kerberos').processes.MongoAuthProcess;\n} catch (err) {}\n/**\n * Creates a new GSSAPI authentication mechanism\n * @class\n * @return {GSSAPI} A cursor instance\n */\n\n\nvar GSSAPI = function () {\n  this.authStore = [];\n};\n/**\n * Authenticate\n * @method\n * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on\n * @param {[]Connections} connections Connections to authenticate using this authenticator\n * @param {string} db Name of the database\n * @param {string} username Username\n * @param {string} password Password\n * @param {authResultCallback} callback The callback to return the result from the authentication\n * @return {object}\n */\n\n\nGSSAPI.prototype.auth = function (server, connections, db, username, password, options, callback) {\n  var self = this; // We don't have the Kerberos library\n\n  if (Kerberos == null) return callback(new Error(\"Kerberos library is not installed\"));\n  var gssapiServiceName = options['gssapiServiceName'] || 'mongodb'; // Total connections\n\n  var count = connections.length;\n  if (count == 0) return callback(null, null); // Valid connections\n\n  var numberOfValidConnections = 0;\n  var credentialsValid = false;\n  var errorObject = null; // For each connection we need to authenticate\n\n  while (connections.length > 0) {\n    // Execute MongoCR\n    var execute = function (connection) {\n      // Start Auth process for a connection\n      GSSAPIInitialize(db, username, password, db, gssapiServiceName, server, connection, options, function (err, r) {\n        // Adjust count\n        count = count - 1; // If we have an error\n\n        if (err) {\n          errorObject = err;\n        } else if (r.result['$err']) {\n          errorObject = r.result;\n        } else if (r.result['errmsg']) {\n          errorObject = r.result;\n        } else {\n          credentialsValid = true;\n          numberOfValidConnections = numberOfValidConnections + 1;\n        } // We have authenticated all connections\n\n\n        if (count == 0 && numberOfValidConnections > 0) {\n          // Store the auth details\n          addAuthSession(self.authStore, new AuthSession(db, username, password, options)); // Return correct authentication\n\n          callback(null, true);\n        } else if (count == 0) {\n          if (errorObject == null) errorObject = new MongoError(f(\"failed to authenticate using mongocr\"));\n          callback(errorObject, false);\n        }\n      });\n    };\n\n    var _execute = function (_connection) {\n      process.nextTick(function () {\n        execute(_connection);\n      });\n    };\n\n    _execute(connections.shift());\n  }\n}; //\n// Initialize step\n\n\nvar GSSAPIInitialize = function (db, username, password, authdb, gssapiServiceName, server, connection, options, callback) {\n  // Create authenticator\n  var mongo_auth_process = new MongoAuthProcess(connection.host, connection.port, gssapiServiceName, options); // Perform initialization\n\n  mongo_auth_process.init(username, password, function (err, context) {\n    if (err) return callback(err, false); // Perform the first step\n\n    mongo_auth_process.transition('', function (err, payload) {\n      if (err) return callback(err, false); // Call the next db step\n\n      MongoDBGSSAPIFirstStep(mongo_auth_process, payload, db, username, password, authdb, server, connection, callback);\n    });\n  });\n}; //\n// Perform first step against mongodb\n\n\nvar MongoDBGSSAPIFirstStep = function (mongo_auth_process, payload, db, username, password, authdb, server, connection, callback) {\n  // Build the sasl start command\n  var command = {\n    saslStart: 1,\n    mechanism: 'GSSAPI',\n    payload: payload,\n    autoAuthorize: 1\n  }; // Execute first sasl step\n\n  server.command(\"$external.$cmd\", command, {\n    connection: connection\n  }, function (err, r) {\n    if (err) return callback(err, false);\n    var doc = r.result; // Execute mongodb transition\n\n    mongo_auth_process.transition(r.result.payload, function (err, payload) {\n      if (err) return callback(err, false); // MongoDB API Second Step\n\n      MongoDBGSSAPISecondStep(mongo_auth_process, payload, doc, db, username, password, authdb, server, connection, callback);\n    });\n  });\n}; //\n// Perform first step against mongodb\n\n\nvar MongoDBGSSAPISecondStep = function (mongo_auth_process, payload, doc, db, username, password, authdb, server, connection, callback) {\n  // Build Authentication command to send to MongoDB\n  var command = {\n    saslContinue: 1,\n    conversationId: doc.conversationId,\n    payload: payload\n  }; // Execute the command\n\n  server.command(\"$external.$cmd\", command, {\n    connection: connection\n  }, function (err, r) {\n    if (err) return callback(err, false);\n    var doc = r.result; // Call next transition for kerberos\n\n    mongo_auth_process.transition(doc.payload, function (err, payload) {\n      if (err) return callback(err, false); // Call the last and third step\n\n      MongoDBGSSAPIThirdStep(mongo_auth_process, payload, doc, db, username, password, authdb, server, connection, callback);\n    });\n  });\n};\n\nvar MongoDBGSSAPIThirdStep = function (mongo_auth_process, payload, doc, db, username, password, authdb, server, connection, callback) {\n  // Build final command\n  var command = {\n    saslContinue: 1,\n    conversationId: doc.conversationId,\n    payload: payload\n  }; // Execute the command\n\n  server.command(\"$external.$cmd\", command, {\n    connection: connection\n  }, function (err, r) {\n    if (err) return callback(err, false);\n    mongo_auth_process.transition(null, function (err, payload) {\n      if (err) return callback(err, null);\n      callback(null, r);\n    });\n  });\n}; // Add to store only if it does not exist\n\n\nvar addAuthSession = function (authStore, session) {\n  var found = false;\n\n  for (var i = 0; i < authStore.length; i++) {\n    if (authStore[i].equal(session)) {\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) authStore.push(session);\n};\n/**\n * Re authenticate pool\n * @method\n * @param {{Server}|{ReplSet}|{Mongos}} server Topology the authentication method is being called on\n * @param {[]Connections} connections Connections to authenticate using this authenticator\n * @param {authResultCallback} callback The callback to return the result from the authentication\n * @return {object}\n */\n\n\nGSSAPI.prototype.reauthenticate = function (server, connections, callback) {\n  var authStore = this.authStore.slice(0);\n  var err = null;\n  var count = authStore.length;\n  if (count == 0) return callback(null, null); // Iterate over all the auth details stored\n\n  for (var i = 0; i < authStore.length; i++) {\n    this.auth(server, connections, authStore[i].db, authStore[i].username, authStore[i].password, authStore[i].options, function (err, r) {\n      if (err) err = err;\n      count = count - 1; // Done re-authenticating\n\n      if (count == 0) {\n        callback(err, null);\n      }\n    });\n  }\n};\n/**\n * This is a result from a authentication strategy\n *\n * @callback authResultCallback\n * @param {error} error An error object. Set to null if no error present\n * @param {boolean} result The result of the authentication process\n */\n\n\nmodule.exports = GSSAPI;","map":null,"metadata":{},"sourceType":"script"}