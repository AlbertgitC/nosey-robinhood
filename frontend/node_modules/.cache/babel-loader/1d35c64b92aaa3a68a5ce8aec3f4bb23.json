{"ast":null,"code":"'use strict'; // \n// Base class for series classes.\n//\n\nvar assert = require('chai').assert;\n\nvar E = require('linq');\n\nvar moment = require('moment');\n\nvar ArrayIterator = require('./iterators/array');\n\nvar validateIterator = require('./iterators/validate');\n\nvar SkipIterator = require('./iterators/skip');\n\nvar SkipWhileIterator = require('./iterators/skip-while');\n\nvar TakeIterator = require('../src/iterators/take');\n\nvar TakeWhileIterator = require('../src/iterators/take-while');\n\nvar SelectIterator = require('../src/iterators/select');\n\nvar SelectManyIterator = require('../src/iterators/select-many');\n\nvar PairIterator = require('../src/iterators/pair');\n\nvar WhereIterator = require('../src/iterators/where');\n\nvar CountIterator = require('../src/iterators/count');\n\nvar EmptyIterator = require('../src/iterators/empty');\n\nvar PairsIterable = require('../src/iterables/pairs');\n\nvar SelectValuesIterable = require('../src/iterables/select-values');\n\nvar ArrayIterable = require('../src/iterables/array');\n\nvar EmptyIterable = require('../src/iterables/empty');\n\nvar CountIterable = require('../src/iterables/count');\n\nvar ExtractIterable = require('../src/iterables/extract');\n\nvar SkipIterable = require('../src/iterables/skip');\n\nvar SkipWhileIterable = require('../src/iterables/skip-while');\n\nvar TakeIterable = require('../src/iterables/take');\n\nvar TakeWhileIterable = require('../src/iterables/take-while');\n\nvar WhereIterable = require('../src/iterables/where');\n\nvar SelectPairsIterable = require('../src/iterables/select-pairs');\n\nvar extend = require('extend'); //\n// Create an iterable for use as an index.\n//\n\n\nvar createIndexIterable = function (index) {\n  if (!index) {\n    return new CountIterable();\n  } else if (Object.isFunction(index)) {\n    return {\n      getIterator: index\n    };\n  } else if (Object.isArray(index)) {\n    return new ArrayIterable(index);\n  } else {\n    return new ExtractIterable(index, 1);\n  }\n}; //\n// Create an iterable from values.\n//\n\n\nvar createValuesIterable = function (values) {\n  if (!values) {\n    return new EmptyIterable();\n  } else if (Object.isFunction(values)) {\n    return {\n      getIterator: values\n    };\n  } else if (Object.isArray(values)) {\n    return new ArrayIterable(values);\n  } else {\n    return values;\n  }\n};\n/**\r\n * Constructor for Series.\r\n * @constructor\r\n * @memberof dataForge\r\n * @param {object|array} config|values - Specifies content and configuration for the Series.\r\n */\n\n\nvar Series = function (config) {\n  var self = this;\n\n  if (!self.factory) {\n    self.factory = function (config) {\n      return new Series(config);\n    };\n  }\n\n  if (!config) {\n    self.iterable = new EmptyIterable();\n    return;\n  }\n\n  if (Object.isObject(config)) {\n    if (config.iterable) {\n      assert.isObject(config.iterable, \"Expect 'iterable' field of 'config' parameter to Series constructor to be an object that implements getIterator and getColumnNames.\");\n      assert.isFunction(config.iterable.getIterator, \"Expect 'iterable' field of 'config' parameter to Series constructor to be an object that implements getIterator and getColumnNames.\"); // Setting the inner iterable directly.\n      // Power to you!\n\n      self.iterable = config.iterable;\n      return;\n    }\n\n    if (config.values) {\n      if (!Object.isFunction(config.values) && !Object.isArray(config.values)) {\n        assert.isObject(config.values, \"Expected 'values' field of 'config' parameter to Series constructor be an array of values, a function that returns an iterator or an iterable.\");\n        assert.isFunction(config.values.getIterator, \"Expected 'values' field of 'config' parameter to Series constructor be an array of values, a function that returns an iterator or an iterable.\");\n      }\n    }\n\n    if (config.index) {\n      if (!Object.isFunction(config.index) && !Object.isArray(config.index)) {\n        assert.isObject(config.index, \"Expected 'index' field of 'config' parameter to Series constructor to be an array, function that returns an iterator, Series, DataFrame or iterable.\");\n        assert.isFunction(config.index.getIterator, \"Expected 'index' field of 'config' parameter to Series constructor to be an array, function that returns an iterator, Series, DataFrame or iterable.\");\n      }\n    }\n\n    self.iterable = new PairsIterable(createIndexIterable(config.index), createValuesIterable(config.values));\n  } else {\n    assert.isArray(config, \"Expected 'config' parameter to Series or DataFrame constructor to be an array of values or a configuration object with options for initialisation.\");\n    self.iterable = new PairsIterable(new CountIterable(), new ArrayIterable(config));\n  }\n};\n\nmodule.exports = Series;\n\nvar concatSeries = require('./concat-series');\n\nvar DataFrame = require('./dataframe');\n\nvar zip = require('./zip');\n\nvar SelectManyIterable = require('../src/iterables/select-many');\n\nvar SelectManyPairsIterable = require('../src/iterables/select-many-pairs');\n\nvar Index = require(\"./index\");\n\nvar Pairs = require(\"./pairs\");\n/**\r\n * Get an iterator for index & values of the series.\r\n * \r\n * @returns {iterator} Returns an iterator that can be used to enumerate and lazily evalute the contents of the series or dataframe. \r\n */\n\n\nSeries.prototype.getIterator = function () {\n  var self = this;\n  return self.iterable.getIterator();\n};\n/**\r\n * Retreive the index of the series.\r\n * \r\n * @returns {Series} Returns a new series that contains the values of the index for this series.\r\n */\n\n\nSeries.prototype.getIndex = function () {\n  var self = this;\n  return new Index({\n    //todo: Should cache index.\n    values: new ExtractIterable(self.iterable, 0) // Extract the index. \n\n  });\n};\n/**\r\n * Apply a new index to the Series.\r\n * \r\n * @param {array|Series} newIndex - The new index to apply to the Series.\r\n * \r\n * @returns {Series|DataFrame} Returns a new series or dataframe with the specified index attached.\r\n */\n\n\nSeries.prototype.withIndex = function (newIndex) {\n  if (!Object.isArray(newIndex)) {\n    assert.isObject(newIndex, \"'Expected 'newIndex' parameter to 'Series.withIndex' to be an array, Series or DataFrame.\");\n    assert.isFunction(newIndex.getIterator, \"'Expected 'newIndex' parameter to 'Series.withIndex' to be an array, Series or DataFrame.\");\n  }\n\n  var self = this;\n  var indexIterable = Object.isArray(newIndex) ? new ArrayIterable(newIndex) : new ExtractIterable(newIndex, 1) // Extract index value.\n  ;\n  var pairsIterable = new PairsIterable(indexIterable, new ExtractIterable(self.iterable, 1) // Extract value.\n  );\n  return self.factory({\n    iterable: pairsIterable\n  });\n};\n/**\r\n * Reset the index of the data frame back to the default sequential integer index.\r\n * \r\n * @returns {Series|DataFrame} Returns a new series or dataframe with the index reset to the default zero-based index. \r\n */\n\n\nSeries.prototype.resetIndex = function () {\n  var self = this;\n  return self.factory({\n    iterable: new PairsIterable(new CountIterable(), // Reset index.\n    new ExtractIterable(self.iterable, 1) // Extract value.\n    )\n  });\n};\n/**\r\n * Skip a number of rows in the series.\r\n *\r\n * @param {int} numRows - Number of rows to skip.\r\n * \r\n * @returns {Series|DataFrame} Returns a new series or dataframe with the specified number of values skipped. \r\n */\n\n\nSeries.prototype.skip = function (numRows) {\n  assert.isNumber(numRows, \"Expected 'numRows' parameter to 'skip' function to be a number.\");\n  var self = this;\n  return self.factory({\n    iterable: new SkipIterable(self.iterable, numRows)\n  });\n};\n/**\r\n * Skips values in the series while a condition is met.\r\n *\r\n * @param {function} predicate - Return true to indicate the condition met.\r\n * \r\n * @returns {Series|DataFrame} Returns a new series or dataframe with all initial sequential values removed that match the predicate.  \r\n */\n\n\nSeries.prototype.skipWhile = function (predicate) {\n  assert.isFunction(predicate, \"Expected 'predicate' parameter to 'skipWhile' function to be a predicate function that returns true/false.\");\n  var self = this;\n  return self.factory({\n    iterable: new SkipWhileIterable(self.iterable, function (pair) {\n      return predicate(pair[1]);\n    })\n  });\n};\n/**\r\n * Skips values in the series until a condition is met.\r\n *\r\n * @param {function} predicate - Return true to indicate the condition met.\r\n * \r\n * @returns {Series|DataFrame} Returns a new series or dataframe with all initial sequential values removed that don't match the predicate.\r\n */\n\n\nSeries.prototype.skipUntil = function (predicate) {\n  assert.isFunction(predicate, \"Expected 'predicate' parameter to 'skipUntil' function to be a predicate function that returns true/false.\");\n  var self = this;\n  return self.skipWhile(function (value) {\n    return !predicate(value);\n  });\n};\n/**\r\n * Take a number of rows in the series.\r\n *\r\n * @param {int} numRows - Number of rows to take.\r\n * \r\n * @returns {Series|DataFrame} Returns a new series or dataframe with up to the specified number of values included.\r\n */\n\n\nSeries.prototype.take = function (numRows) {\n  assert.isNumber(numRows, \"Expected 'numRows' parameter to 'take' function to be a number.\");\n  var self = this;\n  return self.factory({\n    iterable: new TakeIterable(self.iterable, numRows)\n  });\n};\n/**\r\n * Take values from the series while a condition is met.\r\n *\r\n * @param {function} predicate - Return true to indicate the condition met.\r\n * \r\n * @returns {Series|DataFrame} Returns a new series or dataframe that only includes the initial sequential values that have matched the predicate.\r\n */\n\n\nSeries.prototype.takeWhile = function (predicate) {\n  assert.isFunction(predicate, \"Expected 'predicate' parameter to 'takeWhile' function to be a predicate function that returns true/false.\");\n  var self = this;\n  return self.factory({\n    iterable: new TakeWhileIterable(self.iterable, function (pair) {\n      return predicate(pair[1]);\n    })\n  });\n};\n/**\r\n * Take values from the series until a condition is met.\r\n *\r\n * @param {function} predicate - Return true to indicate the condition met.\r\n * \r\n * @returns {Series|DataFrame} Returns a new series or dataframe that only includes the initial sequential values that have not matched the predicate.\r\n */\n\n\nSeries.prototype.takeUntil = function (predicate) {\n  assert.isFunction(predicate, \"Expected 'predicate' parameter to 'takeUntil' function to be a predicate function that returns true/false.\");\n  var self = this;\n  return self.takeWhile(function (value) {\n    return !predicate(value);\n  });\n};\n/**\r\n * Filter a series by a predicate selector.\r\n *\r\n * @param {function} predicate - Predicte function to filter rows of the series.\r\n * \r\n * @returns {Series|DataFrame} Returns a new series or dataframe containing only the values that match the predicate. \r\n */\n\n\nSeries.prototype.where = function (predicate) {\n  assert.isFunction(predicate, \"Expected 'predicate' parameter to 'where' function to be a function.\");\n  var self = this;\n  return self.factory({\n    iterable: new WhereIterable(self.iterable, function (pair) {\n      return predicate(pair[1]);\n    })\n  });\n};\n/**\r\n * Generate a new series based on the results of the selector function.\r\n *\r\n * @param {function} selector - Selector function that transforms each value to create a new series or dataframe.\r\n * \r\n * @returns {Series|DataFrame} Returns a new series or dataframe that has been transformed by the selector function.\r\n */\n\n\nSeries.prototype.select = function (selector) {\n  assert.isFunction(selector, \"Expected 'selector' parameter to 'select' function to be a function.\");\n  var self = this;\n  return self.factory({\n    iterable: new SelectValuesIterable(self.iterable, selector)\n  });\n};\n/**\r\n * Generate a new series based on the results of the selector function.\r\n *\r\n * @param {function} generator - Generator function that may generator 0 or more new values from value in the series or dataframe.\r\n * \r\n * @returns {Series|DataFrame} Returns a new series or dataframe with values that have been produced by the generator function. \r\n */\n\n\nSeries.prototype.selectMany = function (generator) {\n  assert.isFunction(generator, \"Expected 'generator' parameter to 'Series.selectMany' function to be a function.\");\n  var self = this;\n  return self.factory({\n    iterable: new SelectManyIterable(self.iterable, generator)\n  });\n}; //\n// Throw an exception if the sort method doesn't make sense.\n//\n\n\nvar validateSortMethod = function (sortMethod) {\n  assert.isString(sortMethod);\n  assert(sortMethod === 'orderBy' || sortMethod === 'orderByDescending' || sortMethod === 'thenBy' || sortMethod === 'thenByDescending', \"Expected 'sortMethod' to be one of 'orderBy', 'orderByDescending', 'thenBy' or 'thenByDescending', instead it is '\" + sortMethod + \"'.\");\n}; //\n// Execute a batched sorting command.\n//\n\n\nvar executeOrderBy = function (self, batch) {\n  assert.isObject(self);\n  assert.isArray(batch);\n  assert(batch.length > 0); //\n  // Don't invoke the sort until we really know what we need.\n  //\n\n  var executeLazySort = function () {\n    batch.forEach(function (orderCmd) {\n      assert.isObject(orderCmd);\n      assert.isFunction(orderCmd.sortSelector);\n      validateSortMethod(orderCmd.sortMethod);\n    });\n    var pairs = self.toPairs();\n    return E.from(batch).aggregate(E.from(pairs), function (unsorted, orderCmd) {\n      return unsorted[orderCmd.sortMethod](function (pair) {\n        return orderCmd.sortSelector(pair[1]);\n      });\n    }).toArray();\n  };\n\n  return self.factory({\n    iterable: {\n      getIterator: function () {\n        return new ArrayIterator(executeLazySort());\n      },\n      getColumnNames: function () {\n        return self.iterable.getColumnNames();\n      }\n    }\n  });\n}; //\n// Order by values in a partcular series, either ascending or descending\n//\n\n\nvar orderBy = function (self, sortMethod, sortSelector) {\n  assert.isObject(self);\n  validateSortMethod(sortMethod);\n  assert.isFunction(sortSelector);\n  var batchOrder = [{\n    sortSelector: sortSelector,\n    sortMethod: sortMethod\n  }];\n  var sortedDataFrame = executeOrderBy(self, batchOrder);\n  sortedDataFrame.thenBy = orderThenBy(self, batchOrder, 'thenBy');\n  sortedDataFrame.thenByDescending = orderThenBy(self, batchOrder, 'thenByDescending');\n  return sortedDataFrame;\n}; //\n// Generates a thenBy function that is attached to already ordered data frames.\n//\n\n\nvar orderThenBy = function (self, batch, nextSortMethod) {\n  assert.isObject(self);\n  assert.isArray(batch);\n  assert(batch.length > 0);\n  validateSortMethod(nextSortMethod);\n  return function (sortSelector) {\n    assert.isFunction(sortSelector, \"Expected parameter 'sortSelector' to be a function\");\n    var extendedBatch = batch.concat([{\n      sortSelector: sortSelector,\n      sortMethod: nextSortMethod\n    }]);\n    var sortedDataFrame = executeOrderBy(self, extendedBatch);\n    /** \r\n     * Performs additional sorting (ascending).\r\n     * \r\n     * @public\r\n     * @instance\r\n     * @memberof dataForge.Series\r\n     * @param {function} sortSelector - Selects the value to sort by.\r\n     * \r\n     * @returns {Series|DataFrame} Returns a new series or dataframe that has been sorted by the value returned by the selector. \r\n     */\n\n    var thenBy = orderThenBy(self, extendedBatch, 'thenBy');\n    sortedDataFrame.thenBy = thenBy;\n    /** \r\n     * Performs additional sorting (descending). \r\n     * \r\n     * @public\r\n     * @instance\r\n     * @memberof dataForge.Series\r\n     * @param {function} sortSelector - Selects the value to sort by.\r\n     * \r\n     * @returns {Series|DataFrame} Returns a new series or dataframe that has been sorted by the value returned by the selector. \r\n     */\n\n    var thenByDescending = orderThenBy(self, extendedBatch, 'thenByDescending');\n    sortedDataFrame.thenByDescending = thenByDescending;\n    return sortedDataFrame;\n  };\n};\n/**\r\n * Sorts the series or dataframe (ascending). \r\n * \r\n * @param {function} sortSelector - Selects the value to sort by.\r\n * \r\n * @returns {Series|DataFrame} Returns a new series or dataframe that has been sorted by the value returned by the selector. \r\n */\n\n\nSeries.prototype.orderBy = function (sortSelector) {\n  assert.isFunction;\n  var self = this;\n  return orderBy(self, 'orderBy', sortSelector);\n};\n/**\r\n * Sorts the series or dataframe (descending). \r\n * \r\n * @param {function} sortSelector - Selects the value to sort by.\r\n * \r\n * @returns {Series|DataFrame} Returns a new series or dataframe that has been sorted by the value returned by the selector.\r\n */\n\n\nSeries.prototype.orderByDescending = function (sortSelector) {\n  var self = this;\n  return orderBy(self, 'orderByDescending', sortSelector);\n};\n/**\r\n * Segment a Series into 'windows'. Returns a new Series. Each value in the new Series contains a 'window' (or segment) of the original series or dataframe.\r\n * Use select or selectPairs to aggregate.\r\n *\r\n * @param {integer} period - The number of values in the window.\r\n * \r\n * @returns {Series} Returns a new series, each value of which is a 'window' (or segment) of the original series or dataframe.  \r\n */\n\n\nSeries.prototype.window = function (period, obsoleteSelector) {\n  assert.isNumber(period, \"Expected 'period' parameter to 'window' to be a number.\");\n  assert(!obsoleteSelector, \"Selector parameter is obsolete and no longer required.\");\n  var self = this;\n  return new Series({\n    iterable: {\n      getIterator: function () {\n        var curOutput = undefined;\n        var windowIndex = 0;\n        return {\n          moveNext: function () {\n            var window = self.skip(windowIndex * period).take(period);\n\n            if (window.none(function () {\n              return true;\n            })) {\n              //todo: Shouldn't have to pass a predicate.\n              return false; // Nothing left.\n            }\n\n            curOutput = [windowIndex, window];\n            ++windowIndex;\n            return true;\n          },\n          getCurrent: function () {\n            return curOutput;\n          }\n        };\n      }\n    }\n  });\n};\n/** \r\n * Segment a Series into 'rolling windows'. Returns a new Series. Each value in the new Series contains a 'window' (or segment) of the original Series.\r\n * Use select or selectPairs to aggregate.\r\n *\r\n * @param {integer} period - The number of values in the window.\r\n * \r\n * @returns {Series} Returns a new series, each value of which is a 'window' (or segment) of the original series or dataframe.\r\n */\n\n\nSeries.prototype.rollingWindow = function (period, obsoleteSelector) {\n  assert.isNumber(period, \"Expected 'period' parameter to 'rollingWindow' to be a number.\");\n  assert(!obsoleteSelector, \"Selector parameter is obsolete and no longer required.\");\n  var self = this;\n  return new Series({\n    iterable: {\n      getIterator: function () {\n        var curOutput = undefined;\n        var done = false;\n        var windowIndex = 0;\n        return {\n          moveNext: function () {\n            var window = self.skip(windowIndex).take(period);\n\n            if (window.count() < period) {\n              return false;\n            }\n\n            curOutput = [windowIndex, window];\n            ++windowIndex;\n            return true;\n          },\n          getCurrent: function () {\n            return curOutput;\n          }\n        };\n      }\n    }\n  });\n};\n/** \r\n * Format the data frame for display as a string.\r\n * \r\n * @returns {string} Generates and returns a string representation of the series or dataframe.\r\n */\n\n\nSeries.prototype.toString = function () {\n  var self = this;\n\n  var Table = require('easy-table');\n\n  var index = self.getIndex().toArray();\n  var header = [\"__index__\", \"__value__\"];\n  var rows = E.from(self.toArray()).select(function (value, rowIndex) {\n    return [index[rowIndex], value];\n  }).toArray();\n  var t = new Table();\n  rows.forEach(function (row, rowIndex) {\n    row.forEach(function (cell, cellIndex) {\n      t.cell(header[cellIndex], cell);\n    });\n    t.newRow();\n  });\n  return t.toString();\n};\n/**\r\n * Compute the percent change for each row after the first.\r\n * Percentages are expressed as 0-1 values.\r\n * \r\n * @returns {Series} Returns a new series where each value indicates the percent change from the previous number value in the original series.  \r\n */\n\n\nSeries.prototype.percentChange = function () {\n  var self = this;\n  return self.rollingWindow(2).asPairs().select(function (pair) {\n    var window = pair[1];\n    var values = window.toArray();\n    var amountChange = values[1] - values[0]; // Compute amount of change.\n\n    var pctChange = amountChange / values[0]; // Compute % change.\n\n    return [window.getIndex().last(), pctChange]; // Return new index and value.\n  }).asValues() // Result is always a series.\n  ;\n};\n/**\r\n * Parse a series with string values to a series with int values.\r\n * \r\n * @returns {Series} Returns a new series where string values from the original series have been parsed to integer values.\r\n */\n\n\nSeries.prototype.parseInts = function () {\n  var self = this;\n  return self.select(function (value, valueIndex) {\n    if (value === undefined) {\n      return undefined;\n    } else {\n      assert.isString(value, \"Called parseInts on series, expected all values in the series to be strings, instead found a '\" + typeof value + \"' at index \" + valueIndex);\n\n      if (value.length === 0) {\n        return undefined;\n      }\n\n      return parseInt(value);\n    }\n  });\n};\n/**\r\n * Parse a series with string values to a series with float values.\r\n * \r\n * @returns {Series} Returns a new series where string values from the original series have been parsed to floating-point values.\r\n */\n\n\nSeries.prototype.parseFloats = function () {\n  var self = this;\n  return self.select(function (value, valueIndex) {\n    if (value === undefined) {\n      return undefined;\n    } else {\n      assert.isString(value, \"Called parseFloats on series, expected all values in the series to be strings, instead found a '\" + typeof value + \"' at index \" + valueIndex);\n\n      if (value.length === 0) {\n        return undefined;\n      }\n\n      return parseFloat(value);\n    }\n  });\n};\n/**\r\n * Parse a series with string values to a series with date values.\r\n *\r\n * @param {string} [formatString] - Optional formatting string for dates.\r\n * \r\n * @returns {Series} Returns a new series where string values from the original series have been parsed to Date values.\r\n */\n\n\nSeries.prototype.parseDates = function (formatString) {\n  if (formatString) {\n    assert.isString(formatString, \"Expected optional 'formatString' parameter to parseDates to be a string (if specified).\");\n  }\n\n  var self = this;\n  return self.select(function (value, valueIndex) {\n    if (value === undefined) {\n      return undefined;\n    } else {\n      assert.isString(value, \"Called parseDates on series, expected all values in the series to be strings, instead found a '\" + typeof value + \"' at index \" + valueIndex);\n\n      if (value.length === 0) {\n        return undefined;\n      }\n\n      return moment(value, formatString).toDate();\n    }\n  });\n};\n/**\r\n * Convert a series of values of different types to a series of string values.\r\n *\r\n * @param {string} [formatString] - Optional formatting string for dates.\r\n * \r\n * @returns {Series} Returns a new series where the values from the original series have been stringified. \r\n */\n\n\nSeries.prototype.toStrings = function (formatString) {\n  if (formatString) {\n    assert.isString(formatString, \"Expected optional 'formatString' parameter to parseDates to be a string (if specified).\");\n  }\n\n  var self = this;\n  return self.select(function (value) {\n    if (value === undefined) {\n      return undefined;\n    } else if (value === null) {\n      return null;\n    } else if (formatString && Object.isDate(value)) {\n      return moment(value).format(formatString);\n    } else if (formatString && moment.isMoment(value)) {\n      return value.format(formatString);\n    } else {\n      return value.toString();\n    }\n  });\n};\n/** \r\n  * Detect the types of the values in the sequence.\r\n  *\r\n  * @returns {DataFrame} Returns a dataframe that describes the data types contained in the input series or dataframe.\r\n  */\n\n\nSeries.prototype.detectTypes = function () {\n  var self = this;\n  return new DataFrame({\n    columnNames: [\"Type\", \"Frequency\"],\n    values: function () {\n      var values = self.toArray();\n      var totalValues = values.length;\n      var typeFrequencies = E.from(values).select(function (value) {\n        var valueType = typeof value;\n\n        if (valueType === 'object') {\n          if (Object.isDate(value)) {\n            valueType = 'date';\n          }\n        }\n\n        return valueType;\n      }).aggregate({}, function (accumulated, valueType) {\n        var typeInfo = accumulated[valueType];\n\n        if (!typeInfo) {\n          typeInfo = {\n            count: 0\n          };\n          accumulated[valueType] = typeInfo;\n        }\n\n        ++typeInfo.count;\n        return accumulated;\n      });\n      return new ArrayIterator(E.from(Object.keys(typeFrequencies)).select(function (valueType) {\n        return [valueType, typeFrequencies[valueType].count / totalValues * 100];\n      }).toArray());\n    }\n  });\n};\n/** \r\n  * Detect the frequency of values in the sequence.\r\n  *\r\n  * @returns {DataFrame} Returns a dataframe that describes the values contained in the input sequence.\r\n  */\n\n\nSeries.prototype.detectValues = function () {\n  var self = this;\n  return new DataFrame({\n    columnNames: [\"Value\", \"Frequency\"],\n    values: function () {\n      var values = self.toArray();\n      var totalValues = values.length;\n      var valueFrequencies = E.from(values).aggregate({}, function (accumulated, value) {\n        var valueKey = (value !== null && value.toString() || \"null\") + \"-\" + typeof value;\n        var valueInfo = accumulated[valueKey];\n\n        if (!valueInfo) {\n          valueInfo = {\n            count: 0,\n            value: value\n          };\n          accumulated[valueKey] = valueInfo;\n        }\n\n        ++valueInfo.count;\n        return accumulated;\n      });\n      return new ArrayIterator(E.from(Object.keys(valueFrequencies)).select(function (valueKey) {\n        var valueInfo = valueFrequencies[valueKey];\n        return [valueInfo.value, valueInfo.count / totalValues * 100];\n      }).toArray());\n    }\n  });\n};\n/**\r\n * Produces a new series with all string values truncated to the requested maximum length.\r\n *\r\n * @param {int} maxLength - The maximum length of the string values after truncation.\r\n * \r\n * @returns {Series} Returns a new series with strings that are truncated to the specified maximum length. \r\n */\n\n\nSeries.prototype.truncateStrings = function (maxLength) {\n  assert.isNumber(maxLength, \"Expected 'maxLength' parameter to 'truncateStrings' to be an integer.\");\n  var self = this;\n  return self.select(function (value) {\n    if (Object.isString(value)) {\n      if (value.length > maxLength) {\n        return value.substring(0, maxLength);\n      }\n    }\n\n    return value;\n  });\n};\n/*\r\n * Extract values from the series. This forces lazy evaluation to complete.\r\n * \r\n * @returns {array} Returns an array of values contained within the series or dataframe.  \r\n */\n\n\nSeries.prototype.toArray = function () {\n  var self = this;\n  var iterator = self.getIterator();\n  validateIterator(iterator);\n  var values = [];\n\n  while (iterator.moveNext()) {\n    var value = iterator.getCurrent()[1]; // Extract value.\n\n    if (value !== undefined) {\n      values.push(value);\n    }\n  }\n\n  return values;\n};\n/**\r\n * Forces lazy evaluation to complete and 'bakes' the series into memory.\r\n * \r\n * @returns {Series|DataFrame} Returns a series or dataframe that has been 'baked', all lazy evaluation has completed.  \r\n */\n\n\nSeries.prototype.bake = function () {\n  var self = this;\n\n  if (self._baked) {\n    // Already baked, just return self.\n    return self;\n  }\n\n  var pairs = self.toPairs();\n  var baked = self.factory({\n    iterable: {\n      getIterator: function () {\n        return new ArrayIterator(pairs);\n      },\n      getColumnNames: function () {\n        return self.iterable.getColumnNames();\n      }\n    }\n  });\n  baked._baked = true;\n  return baked;\n};\n/**\r\n * Retreive the data as pairs of [index, value].\r\n * \r\n * @returns {array} Returns an array of pairs for the content of the series or dataframe. Each pair is a two element array that contains an index and a value.  \r\n */\n\n\nSeries.prototype.toPairs = function () {\n  var self = this;\n  var iterator = self.getIterator();\n  validateIterator(iterator);\n  var pairs = [];\n\n  while (iterator.moveNext()) {\n    var pair = iterator.getCurrent();\n\n    if (pair[1] !== undefined) {\n      pairs.push(pair);\n    }\n  }\n\n  return pairs;\n};\n/**\r\n * Count the number of rows in the series.\r\n *\r\n * @returns {array} Returns the count of all values in the series or dataframes.   \r\n */\n\n\nSeries.prototype.count = function () {\n  var self = this;\n  var total = 0;\n  var iterator = self.getIterator();\n\n  while (iterator.moveNext()) {\n    ++total;\n  }\n\n  return total;\n};\n/**\r\n * Get the first value of the series or dataframe.\r\n *\r\n * @returns {value} Returns the first value of the series or dataframe.   \r\n */\n\n\nSeries.prototype.first = function () {\n  var self = this;\n  var iterator = self.getIterator();\n\n  if (!iterator.moveNext()) {\n    throw new Error(\"No values in Series.\");\n  }\n\n  return iterator.getCurrent()[1]; // Extract value.\n};\n/**\r\n * Get the last value of the series or dataframe.\r\n *\r\n * @returns {value} Returns the last value of the series or dataframe.   \r\n */\n\n\nSeries.prototype.last = function () {\n  var self = this;\n  var iterator = self.getIterator();\n\n  if (!iterator.moveNext()) {\n    throw new Error(\"No values in Series.\");\n  }\n\n  while (iterator.moveNext()) {\n    ; // Don't evaluate each item, it's too expensive.\n  }\n\n  return iterator.getCurrent()[1]; // Just evaluate the last item of the iterator.\n};\n/** \r\n * Reverse the series or dataframe.\r\n * \r\n * @returns {Series|DataFrame} Returns a new series or dataframe that is the reverse of the input.\r\n */\n\n\nSeries.prototype.reverse = function () {\n  var self = this;\n  return self.factory({\n    iterable: {\n      getIterator: function () {\n        var pairs = [];\n        var iterator = self.iterable.getIterator();\n\n        while (iterator.moveNext()) {\n          pairs.push(iterator.getCurrent());\n        }\n\n        return new ArrayIterator(pairs.reverse());\n      },\n      getColumnNames: function () {\n        return self.iterable.getColumnNames();\n      }\n    }\n  });\n};\n/** \r\n * Inflate a series to a data-frame.\r\n *\r\n * @param {function} [selector] - Optional selector function that transforms each value in the series to a row in the new data-frame.\r\n *\r\n * @returns {DataFrame} Returns a new dataframe that has been created from the input series via the 'selector' function.\r\n */\n\n\nSeries.prototype.inflate = function (selector) {\n  var self = this;\n\n  if (selector) {\n    assert.isFunction(selector, \"Expected 'selector' parameter to 'inflate' function to be a function.\");\n  } else {\n    selector = function (value) {\n      return value;\n    };\n  }\n\n  return new DataFrame({\n    iterable: new SelectValuesIterable(self.iterable, selector)\n  });\n};\n/** \r\n * Get X values from the start of the series or dataframe.\r\n *\r\n * @param {int} values - Number of values to take.\r\n * \r\n * @returns {Series|DataFrame} Returns a new series or dataframe that has only the specified number of values taken from the start of the input sequence.  \r\n */\n\n\nSeries.prototype.head = function (values) {\n  assert.isNumber(values, \"Expected 'values' parameter to 'head' function to be a function.\");\n  var self = this;\n  return self.take(values);\n};\n/** \r\n * Get X values from the end of the series or dataframe.\r\n *\r\n * @param {int} values - Number of values to take.\r\n * \r\n * @returns {Series|DataFrame} Returns a new series or dataframe that has only the specified number of values taken from the end of the input sequence.  \r\n */\n\n\nSeries.prototype.tail = function (values) {\n  assert.isNumber(values, \"Expected 'values' parameter to 'tail' function to be a function.\");\n  var self = this;\n  return self.skip(self.count() - values);\n};\n/**\r\n * Sum the values in a series.\r\n * \r\n * @returns {number} Returns the sum of the number values in the series.\r\n */\n\n\nSeries.prototype.sum = function () {\n  var self = this;\n\n  if (self.none()) {\n    return 0;\n  }\n\n  return self.aggregate(function (prev, value) {\n    return prev + value;\n  });\n};\n/**\r\n * Average the values in a series.\r\n * \r\n * @returns {number} Returns the average of the number values in the series.\r\n */\n\n\nSeries.prototype.average = function () {\n  var self = this;\n  var count = self.count();\n\n  if (count > 0) {\n    return self.sum() / count;\n  } else {\n    return 0;\n  }\n};\n/**\r\n * Get the median value in the series. Not this sorts the series, so can be expensive.\r\n * \r\n * @returns {Number} Returns the median of the values in the series.\r\n */\n\n\nSeries.prototype.median = function () {\n  //\n  // From here: http://stackoverflow.com/questions/5275115/add-a-median-method-to-a-list\n  //\n  var self = this;\n  var count = self.count();\n\n  if (count === 0) {\n    return 0;\n  }\n\n  var ordered = self.orderBy(function (value) {\n    return value;\n  });\n\n  if (count % 2 == 0) {\n    // Even.\n    var a = ordered.at(count / 2 - 1);\n    var b = ordered.at(count / 2);\n    return (a + b) / 2;\n  } // Odd\n\n\n  return ordered.at(Math.floor(count / 2));\n};\n/**\r\n * Get the min value in the series.\r\n * \r\n * @returns {number} Returns the minimum of the number values in the series.\r\n */\n\n\nSeries.prototype.min = function () {\n  var self = this;\n  return self.aggregate(function (prev, value) {\n    return Math.min(prev, value);\n  });\n};\n/**\r\n * Get the max value in the series.\r\n * \r\n * @returns {number} Returns the maximum of the number values in the series.\r\n */\n\n\nSeries.prototype.max = function () {\n  var self = this;\n  return self.aggregate(function (prev, value) {\n    return Math.max(prev, value);\n  });\n};\n/**\r\n * Aggregate the values in the series.\r\n *\r\n * @param {object} [seed] - The seed value for producing the aggregation.\r\n * @param {function} selector - Function that takes the seed and then each value in the series and produces the aggregate value.\r\n * \r\n * @returns {value} Returns a new value that has been aggregated from the input sequence by the 'selector' function. \r\n */\n\n\nSeries.prototype.aggregate = function (seedOrSelector, selector) {\n  var self = this;\n\n  if (Object.isFunction(seedOrSelector) && !selector) {\n    return self.skip(1).aggregate(self.first(), seedOrSelector);\n  } else {\n    assert.isFunction(selector, \"Expected 'selector' parameter to aggregate to be a function.\");\n    var working = seedOrSelector;\n    var it = self.iterable.getIterator();\n\n    while (it.moveNext()) {\n      var curValue = it.getCurrent()[1];\n      working = selector(working, curValue); //todo: should pass index in here as well.\n    }\n\n    return working;\n  }\n};\n/**\r\n * Convert the series to a JavaScript object.\r\n *\r\n * @param {function} keySelector - Function that selects keys for the resulting object.\r\n * @param {valueSelector} keySelector - Function that selects values for the resulting object.\r\n * \r\n * @returns {object} Returns a JavaScript object generated from the input sequence by the key and value selector funtions. \r\n */\n\n\nSeries.prototype.toObject = function (keySelector, valueSelector) {\n  var self = this;\n  assert.isFunction(keySelector, \"Expected 'keySelector' parameter to toObject to be a function.\");\n  assert.isFunction(valueSelector, \"Expected 'valueSelector' parameter to toObject to be a function.\");\n  return E.from(self.toArray()).toObject(keySelector, valueSelector);\n};\n/**\r\n * Zip together multiple series or dataframes to produce a new series or dataframe.\r\n *\r\n * @param {...Series|DataFrame} sequence - Multiple parameters, one for each sequence to be zipped.\r\n * @param {function} selector - Selector function that produces a new series or dataframe based on the inputs.\r\n * \r\n * @returns {Series|DataFrame} Returns a single series or dataframe that is the combination of multiple input sequences that have been 'zipped' together by the 'selector' function.\r\n */\n\n\nSeries.prototype.zip = function () {\n  var self = this;\n  var inputSeries = E.from(arguments).takeWhile(function (arg) {\n    return arg && !Object.isFunction(arg);\n  }).toArray();\n  assert(inputSeries.length >= 0, \"Expected 1 or more 'series' or 'dataframe' parameters to the Series.zip function.\");\n  inputSeries = [this].concat(inputSeries);\n  var selector = E.from(arguments).skipWhile(function (arg) {\n    return arg && !Object.isFunction(arg);\n  }).firstOrDefault();\n  assert.isFunction(selector, \"Expect 'selector' parameter to Series.zip to be a function.\");\n  return zip(inputSeries, function (series) {\n    return selector.apply(undefined, series.toArray());\n  }, self.factory);\n};\n/**\r\n * Invoke a callback function for each value in the series.\r\n *\r\n * @param {function} callback - The calback to invoke for each value.\r\n * \r\n * @returns {Series|DataFrame} Returns the input sequence with no modifications.   \r\n */\n\n\nSeries.prototype.forEach = function (callback) {\n  assert.isFunction(callback, \"Expected 'callback' parameter to 'forEach' function to be a function.\");\n  var self = this;\n  var iterator = self.getIterator();\n  validateIterator(iterator);\n\n  while (iterator.moveNext()) {\n    var pair = iterator.getCurrent();\n    callback(pair[1]);\n  }\n\n  return self;\n};\n/**\r\n * Determine if the predicate returns truthy for all values in the sequence.\r\n * Returns false as soon as the predicate evaluates to falsy.\r\n * Returns true if the predicate returns truthy for all values in the Series.\r\n * Returns false if the series is empty.\r\n *\r\n * @param {function} predicate - Predicate function that receives each value in turn and returns truthy for a match, otherwise falsy.\r\n *\r\n * @returns {boolean} Returns true if the predicate has returned truthy for every value in the sequence, otherwise returns false. \r\n */\n\n\nSeries.prototype.all = function (predicate) {\n  assert.isFunction(predicate, \"Expected 'predicate' parameter to 'all' to be a function.\");\n  var self = this;\n  var iterator = self.iterable.getIterator();\n  validateIterator(iterator);\n  var count = 0;\n\n  while (iterator.moveNext()) {\n    var pair = iterator.getCurrent();\n\n    if (!predicate(pair[1])) {\n      return false;\n    }\n\n    ++count;\n  }\n\n  return count > 0;\n};\n/**\r\n * Determine if the predicate returns truthy for any of the values in the sequence.\r\n * Returns true as soon as the predicate returns truthy.\r\n * Returns false if the predicate never returns truthy.\r\n * If no predicate is specified the value itself is checked. \r\n *\r\n * @param {function} [predicate] - Optional predicate function that receives each value in turn and returns truthy for a match, otherwise falsy.\r\n *\r\n * @returns {boolean} Returns true if the predicate has returned truthy for any value in the sequence, otherwise returns false. \r\n */\n\n\nSeries.prototype.any = function (predicate) {\n  if (predicate) {\n    assert.isFunction(predicate, \"Expected 'predicate' parameter to 'any' to be a function.\");\n  }\n\n  var self = this;\n  var iterator = self.iterable.getIterator();\n  validateIterator(iterator);\n\n  if (!predicate) {\n    return iterator.moveNext();\n  }\n\n  while (iterator.moveNext()) {\n    var pair = iterator.getCurrent();\n\n    if (predicate(pair[1])) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\r\n * Determine if the predicate returns truthy for none of the values in the sequence.\r\n * Returns true for an empty Series.\r\n * Returns true if the predicate always returns falsy.\r\n * Otherwise returns false.\r\n * If no predicate is specified the value itself is checked.\r\n *\r\n * @param {function} [predicate] - Optional predicate function that receives each value in turn and returns truthy for a match, otherwise falsy.\r\n * \r\n * @returns {boolean} Returns true if the predicate has returned truthy for no values in the sequence, otherwise returns false. \r\n */\n\n\nSeries.prototype.none = function (predicate) {\n  if (predicate) {\n    assert.isFunction(predicate, \"Expected 'predicate' parameter to 'none' to be a function.\");\n  }\n\n  var self = this;\n  var iterator = self.iterable.getIterator();\n  validateIterator(iterator);\n\n  if (!predicate) {\n    return !iterator.moveNext();\n  }\n\n  while (iterator.moveNext()) {\n    var pair = iterator.getCurrent();\n\n    if (predicate(pair[1])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\r\n * Group sequential duplicate values into a Series of windows.\r\n *\r\n * @param {function} selector - Selects the value used to compare for duplicates.\r\n * \r\n * @returns {Series|DataFrame} Returns a series of groups. Each group is itself a series or dataframe. \r\n */\n\n\nSeries.prototype.sequentialDistinct = function (selector) {\n  if (selector) {\n    assert.isFunction(selector, \"Expected 'selector' parameter to 'Series.sequentialDistinct' to be a selector function that determines the value to compare for duplicates.\");\n  } else {\n    selector = function (value) {\n      return value;\n    };\n  }\n\n  var self = this;\n  return self.variableWindow(function (a, b) {\n    return selector(a) === selector(b);\n  }).asPairs().select(function (pair) {\n    var window = pair[1];\n    return [window.getIndex().first(), window.first()];\n  }).asValues();\n};\n/**\r\n * Group distinct values in the Series into a Series of windows.\r\n *\r\n * @param {function} selector - Selects the value used to compare for duplicates.\r\n * \r\n * @returns {Series|DataFrame} Returns a series or dataframe containing only unique values as determined by the 'selector' function. \r\n */\n\n\nSeries.prototype.distinct = function (selector) {\n  if (selector) {\n    assert.isFunction(selector, \"Expected 'selector' parameter to 'Series.distinct' to be a selector function that determines the value to compare for duplicates.\");\n  } else {\n    selector = function (value) {\n      return value;\n    };\n  }\n\n  var self = this; //todo: make this lazy.\n\n  /* todo: Want to zip here, when zip can specify the index. \r\n  \n  series.zip(series.skip(1), function (prev, next) { \r\n  \t});\r\n  \n  */\n\n  var input = E.from(self.toPairs()).select(function (pair) {\n    return {\n      pair: pair,\n      considered: false\n    };\n  }).toArray();\n  var output = [];\n\n  for (var i = 0; i < input.length; ++i) {\n    var underConsideration = input[i];\n\n    if (underConsideration.considered) {\n      // Skip this item, it has already been dealt with.\n      continue;\n    }\n\n    var curPair = underConsideration.pair;\n    underConsideration.considered = true; // Don't really need to do this, because we never backtrack, but it feels like it makes the code 'complete'.\n\n    for (var j = i + 1; j < input.length; ++j) {\n      var underComparison = input[j];\n\n      if (underComparison.considered) {\n        continue;\n      }\n\n      if (selector(underComparison.pair[1]) === selector(underConsideration.pair[1])) {\n        underComparison.considered = true;\n      }\n    }\n\n    output.push(curPair);\n  }\n\n  return self.factory({\n    iterable: {\n      getIterator: function () {\n        return new ArrayIterator(output);\n      },\n      getColumnNames: function () {\n        return self.iterable.getColumnNames();\n      }\n    }\n  });\n};\n/**\r\n * Groups sequential values into variable length 'windows'. The windows can then be transformed/transformed using selectPairs or selectManyPairs.\r\n *\r\n * @param {function} comparer - Predicate that compares two values and returns true if they should be in the same window.\r\n * \r\n * @returns {Series|DataFrame} Returns a series of groups. Each group is itself a series or dataframe that contains the values in the 'window'. \r\n */\n\n\nSeries.prototype.variableWindow = function (comparer, obsoleteSelector) {\n  assert.isFunction(comparer, \"Expected 'comparer' parameter to 'Series.variableWindow' to be a function.\");\n  assert(!obsoleteSelector, \"Selector parameter is obsolete and no longer required.\");\n  var self = this; //todo: make this lazy.\n\n  var input = self.toPairs();\n  var output = [];\n\n  if (input.length > 0) {\n    var startIndex = 0;\n    var takeAmount = 1;\n    var windowIndex = 0;\n    var prevPair = input[0]; // 1st pair.\n\n    for (var i = 1; i < input.length; ++i) {\n      var curPair = input[i];\n\n      if (!comparer(curPair[1], prevPair[1])) {\n        // Flush.\n        output.push([windowIndex, self.skip(startIndex).take(takeAmount)]);\n        ++windowIndex;\n        startIndex = i;\n        takeAmount = 1;\n      } else {\n        ++takeAmount;\n      }\n\n      prevPair = curPair;\n    }\n\n    if (takeAmount > 0) {\n      output.push([windowIndex, self.skip(startIndex).take(takeAmount)]);\n    }\n  }\n\n  return new Series({\n    values: E.from(output).select(function (pair) {\n      return pair[1];\n    }).toArray(),\n    index: new Series({\n      values: E.from(output).select(function (pair) {\n        return pair[0];\n      }).toArray()\n    })\n  });\n};\n/**\r\n * Insert a pair at the start of a Series.\r\n *\r\n * @param {pair} pair - The pair to insert.\r\n * \r\n * @returns {Series|DataFrame} Returns a new series or dataframe with the specified pair inserted.\r\n */\n\n\nSeries.prototype.insertPair = function (pair) {\n  assert.isArray(pair, \"Expected 'pair' parameter to 'Series.insertPair' to be an array.\");\n  assert(pair.length === 2, \"Expected 'pair' parameter to 'Series.insertPair' to be an array with two elements. The first element is the index, the second is the value.\"); //todo: make this lazy.\n\n  var self = this;\n  var pairs = [pair].concat(self.toPairs());\n  return self.factory({\n    iterable: new ArrayIterable(pairs)\n  });\n};\n/**\r\n * Append a pair to the end of a Series.\r\n *\r\n * @param {pair} pair - The pair to append.\r\n * \r\n * @returns {Series|DataFrame} Returns a new series or dataframe with the specified pair appended.\r\n */\n\n\nSeries.prototype.appendPair = function (pair) {\n  assert.isArray(pair, \"Expected 'pair' parameter to 'Series.appendPair' to be an array.\");\n  assert(pair.length === 2, \"Expected 'pair' parameter to 'Series.appendPair' to be an array with two elements. The first element is the index, the second is the value.\"); //todo: make this lazy.\n\n  var self = this;\n  var pairs = self.toPairs();\n  pairs.push(pair);\n  return self.factory({\n    iterable: new ArrayIterable(pairs)\n  });\n};\n/**\r\n * Fill gaps in a series or dataframe.\r\n *\r\n * @param {function} predicate - Predicate that is passed pairA and pairB, two consecutive rows, return truthy if there is a gap between the rows, or falsey if there is no gap.\r\n * @param {function} generator - Generator that is passed pairA and pairB, two consecutive rows, returns an array of pairs that fills the gap between the rows.\r\n *\r\n * @returns {Series} Returns a new series with gaps filled in.\r\n */\n\n\nSeries.prototype.fillGaps = function (predicate, generator) {\n  assert.isFunction(predicate, \"Expected 'predicate' parameter to 'Series.fillGaps' to be a predicate function that returns a boolean.\");\n  assert.isFunction(generator, \"Expected 'generator' parameter to 'Series.fillGaps' to be a generator function that returns an array of generated pairs.\");\n  var self = this;\n  return self.rollingWindow(2).asPairs().selectMany(function (pair) {\n    var window = pair[1];\n    var pairA = window.asPairs().first();\n    var pairB = window.asPairs().last();\n\n    if (!predicate(pairA, pairB)) {\n      return [pairA];\n    }\n\n    var generatedRows = generator(pairA, pairB);\n    assert.isArray(generatedRows, \"Expected return from 'generator' parameter to 'Series.fillGaps' to be an array of pairs, instead got a \" + typeof generatedRows);\n    return [pairA].concat(generatedRows);\n  }).asValues().appendPair(self.asPairs().last());\n};\n/**\r\n * Group the series according to the selector.\r\n *\r\n * @param {function} selector - Selector that defines the value to group by.\r\n *\r\n * @returns {Series} Returns a series of groups. Each group is a series with values that have been grouped by the 'selector' function.\r\n */\n\n\nSeries.prototype.groupBy = function (selector) {\n  assert.isFunction(selector, \"Expected 'selector' parameter to 'Series.groupBy' to be a selector function that determines the value to group the series by.\");\n  var self = this;\n  var groupedPairs = E.from(self.toPairs()).groupBy(function (pair) {\n    return selector(pair[1]);\n  }).select(function (group) {\n    return [group.key(), new Series({\n      iterable: new ArrayIterable(group.getSource())\n    })];\n  }).toArray();\n  return new Series({\n    iterable: new ArrayIterable(groupedPairs)\n  });\n};\n/**\r\n * Group sequential values into a Series of windows.\r\n *\r\n * @param {function} selector - Selector that defines the value to group by.\r\n *\r\n * @returns {Series} Returns a series of groups. Each group is a series with values that have been grouped by the 'selector' function.\r\n */\n\n\nSeries.prototype.groupSequentialBy = function (selector) {\n  if (selector) {\n    assert.isFunction(selector, \"Expected 'selector' parameter to 'Series.groupSequentialBy' to be a selector function that determines the value to group the series by.\");\n  } else {\n    selector = function (value) {\n      return value;\n    };\n  }\n\n  var self = this;\n  return self.variableWindow(function (a, b) {\n    return selector(a) === selector(b);\n  });\n};\n/**\r\n * Get the value at a specified index.\r\n *\r\n * @param {function} index - Index to for which to retreive the value.\r\n *\r\n * @returns {value} Returns the value from the specified index in the sequence. \r\n */\n\n\nSeries.prototype.at = function (index) {\n  var self = this;\n  var iterator = self.iterable.getIterator();\n\n  if (!iterator.moveNext()) {\n    return undefined;\n  } //\n  // This is pretty expensive.\n  // A specialised index could improve this.\n  //\n\n\n  do {\n    var curPair = iterator.getCurrent();\n\n    if (curPair[0] === index) {\n      return curPair[1];\n    }\n  } while (iterator.moveNext());\n\n  return undefined;\n};\n/**\r\n * Concatenate multiple other series onto this series.\r\n * \r\n * @param {...array|Series} series - Multiple arguments. Each can be either a series or an array of series.\r\n * \r\n * @returns {Series} Returns a single series concatenated from multiple input series. \r\n */\n\n\nSeries.prototype.concat = function () {\n  var self = this;\n  return concatSeries([self].concat(E.from(arguments).selectMany(function (argument) {\n    if (Object.isArray(argument)) {\n      return argument;\n    } else {\n      return [argument];\n    }\n  }).toArray()));\n};\n/**\r\n * Correlates the elements of two Series or DataFrames based on matching keys.\r\n *\r\n * @param {Series|DataFrame} self - The outer Series or DataFrame to join. \r\n * @param {Series|DataFrame} inner - The inner Series or DataFrame to join.\r\n * @param {function} outerKeySelector - Selector that chooses the join key from the outer sequence.\r\n * @param {function} innerKeySelector - Selector that chooses the join key from the inner sequence.\r\n * @param {function} resultSelector - Selector that defines how to merge outer and inner values.\r\n * \r\n * @returns {Series|DataFrame} Returns the joined series or dataframe. \r\n */\n\n\nSeries.prototype.join = function (inner, outerKeySelector, innerKeySelector, resultSelector) {\n  assert.instanceOf(inner, Series, \"Expected 'inner' parameter of 'Series.join' to be a Series or DataFrame.\");\n  assert.isFunction(outerKeySelector, \"Expected 'outerKeySelector' parameter of 'Series.join' to be a selector function.\");\n  assert.isFunction(innerKeySelector, \"Expected 'innerKeySelector' parameter of 'Series.join' to be a selector function.\");\n  assert.isFunction(resultSelector, \"Expected 'resultSelector' parameter of 'Series.join' to be a selector function.\");\n  var outer = this;\n  var joined = E.from(outer.toPairs()).join(inner.toPairs(), function (outerPair) {\n    return outerKeySelector(outerPair[1], outerPair[0]);\n  }, function (innerPair) {\n    return innerKeySelector(innerPair[1], innerPair[0]);\n  }, function (outerPair, innerPair) {\n    return resultSelector(outerPair[1], innerPair[1]);\n  }).toArray();\n  return new DataFrame({\n    values: joined\n  });\n};\n/**\r\n * Performs an outer join on two Series or DataFrames. Correlates the elements based on matching keys.\r\n * Includes elements that have no correlation.\r\n *\r\n * @param {Series|DataFrame} self - The outer Series or DataFrame to join. \r\n * @param {Series|DataFrame} inner - The inner Series or DataFrame to join.\r\n * @param {function} outerKeySelector - Selector that chooses the join key from the outer sequence.\r\n * @param {function} innerKeySelector - Selector that chooses the join key from the inner sequence.\r\n * @param {function} outerResultSelector - Selector that defines how to extract the outer value before joining it with the inner value. \r\n * @param {function} innerResultSelector - Selector that defines how to extract the inner value before joining it with the outer value.\r\n * @param {function} mergeSelector - Selector that defines how to combine left and right.\r\n * \r\n * Implementation from here:\r\n * \r\n * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\r\n * \r\n * @returns {Series|DataFrame} Returns the joined series or dataframe. \r\n */\n\n\nSeries.prototype.joinOuter = function (rightSeries, outerKeySelector, innerKeySelector, resultSelector) {\n  assert.instanceOf(rightSeries, Series, \"Expected 'rightSeries' parameter of 'Series.joinOuter' to be a Series.\");\n  assert.isFunction(outerKeySelector, \"Expected 'outerKeySelector' parameter of 'Series.joinOuter' to be a selector function.\");\n  assert.isFunction(innerKeySelector, \"Expected 'innerKeySelector' parameter of 'Series.joinOuter' to be a selector function.\");\n  assert.isFunction(resultSelector, \"Expected 'resultSelector' parameter of 'Series.joinOuter' to be a selector function.\");\n  var self = this;\n  var leftOuter = self.except(rightSeries, function (outer, inner) {\n    return outerKeySelector(outer) === innerKeySelector(inner);\n  }).select(function (outer) {\n    return resultSelector(outer, null);\n  });\n  var rightOuter = rightSeries.except(self, function (inner, outer) {\n    return outerKeySelector(outer) === innerKeySelector(inner);\n  }).select(function (inner) {\n    return resultSelector(null, inner);\n  });\n  var inner = self.join(rightSeries, outerKeySelector, innerKeySelector, resultSelector);\n  return leftOuter.concat(inner).concat(rightOuter).resetIndex();\n};\n/**\r\n * Performs a left outer join on two Series or DataFrames. Correlates the elements based on matching keys.\r\n * Includes left elements that have no correlation.\r\n *\r\n * @param {Series|DataFrame} self - The outer Series or DataFrame to join. \r\n * @param {Series|DataFrame} inner - The inner Series or DataFrame to join.\r\n * @param {function} outerKeySelector - Selector that chooses the join key from the outer sequence.\r\n * @param {function} innerKeySelector - Selector that chooses the join key from the inner sequence.\r\n * @param {function} outerResultSelector - Selector that defines how to extract the outer value before joining it with the inner value. \r\n * @param {function} innerResultSelector - Selector that defines how to extract the inner value before joining it with the outer value.\r\n * @param {function} mergeSelector - Selector that defines how to combine left and right.\r\n * \r\n * Implementation from here:\r\n * \r\n * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\r\n * \r\n * @returns {Series|DataFrame} Returns the joined series or dataframe. \r\n */\n\n\nSeries.prototype.joinOuterLeft = function (rightSeries, outerKeySelector, innerKeySelector, resultSelector) {\n  assert.instanceOf(rightSeries, Series, \"Expected 'rightSeries' parameter of 'Series.joinOuterLeft' to be a Series.\");\n  assert.isFunction(outerKeySelector, \"Expected 'outerKeySelector' parameter of 'Series.joinOuterLeft' to be a selector function.\");\n  assert.isFunction(innerKeySelector, \"Expected 'innerKeySelector' parameter of 'Series.joinOuterLeft' to be a selector function.\");\n  assert.isFunction(resultSelector, \"Expected 'resultSelector' parameter of 'Series.joinOuterLeft' to be a selector function.\");\n  var self = this;\n  var leftOuter = self.except(rightSeries, function (outer, inner) {\n    return outerKeySelector(outer) === innerKeySelector(inner);\n  }).select(function (outer) {\n    return resultSelector(outer, null);\n  });\n  var inner = self.join(rightSeries, outerKeySelector, innerKeySelector, resultSelector);\n  return leftOuter.concat(inner).resetIndex();\n};\n/**\r\n * Performs a right outer join on two Series or DataFrames. Correlates the elements based on matching keys.\r\n * Includes right elements that have no correlation.\r\n *\r\n * @param {Series|DataFrame} self - The outer Series or DataFrame to join. \r\n * @param {Series|DataFrame} inner - The inner Series or DataFrame to join.\r\n * @param {function} outerKeySelector - Selector that chooses the join key from the outer sequence.\r\n * @param {function} innerKeySelector - Selector that chooses the join key from the inner sequence.\r\n * @param {function} outerResultSelector - Selector that defines how to extract the outer value before joining it with the inner value. \r\n * @param {function} innerResultSelector - Selector that defines how to extract the inner value before joining it with the outer value.\r\n * @param {function} mergeSelector - Selector that defines how to combine left and right.\r\n * \r\n * Implementation from here:\r\n * \r\n * \thttp://blogs.geniuscode.net/RyanDHatch/?p=116\r\n * \r\n * @returns {Series|DataFrame} Returns the joined series or dataframe. \r\n */\n\n\nSeries.prototype.joinOuterRight = function (rightSeries, outerKeySelector, innerKeySelector, resultSelector) {\n  assert.instanceOf(rightSeries, Series, \"Expected 'rightSeries' parameter of 'Series.joinOuterRight' to be a Series.\");\n  assert.isFunction(outerKeySelector, \"Expected 'outerKeySelector' parameter of 'Series.joinOuterRight' to be a selector function.\");\n  assert.isFunction(innerKeySelector, \"Expected 'innerKeySelector' parameter of 'Series.joinOuterRight' to be a selector function.\");\n  assert.isFunction(resultSelector, \"Expected 'resultSelector' parameter of 'Series.joinOuterRight' to be a selector function.\");\n  var self = this;\n  var rightOuter = rightSeries.except(self, function (inner, outer) {\n    return outerKeySelector(outer) === innerKeySelector(inner);\n  }).select(function (inner) {\n    return resultSelector(null, inner);\n  });\n  var inner = self.join(rightSeries, outerKeySelector, innerKeySelector, resultSelector);\n  return inner.concat(rightOuter).resetIndex();\n};\n/**\r\n * Returns the specified default sequence if the Series or DataFrame is empty. \r\n *\r\n * @param {array|Series|DataFrame} defaultSequence - Default sequence to return if the Series or DataFrame is empty.\r\n * \r\n * @returns {Series|DataFrame} Returns 'defaultSequence' if the input sequence is empty. \r\n */\n\n\nSeries.prototype.defaultIfEmpty = function (defaultSequence) {\n  if (!Object.isArray(defaultSequence)) {\n    assert.instanceOf(defaultSequence, Series, \"Expect 'defaultSequence' parameter to 'Series.defaultIfEmpty' to be an array, Series or DataFrame.\");\n  }\n\n  var self = this;\n\n  if (self.none()) {\n    if (defaultSequence instanceof Series) {\n      return defaultSequence;\n    } else {\n      return self.factory({\n        values: defaultSequence\n      });\n    }\n  } else {\n    return self;\n  }\n};\n/**\r\n * Returns the unique union of values between two Series or DataFrames.\r\n *\r\n * @param {Series|DataFrame} other - The other Series or DataFrame to combine.\r\n * @param {function} [comparer] - Optional comparer that selects the value to compare.\r\n * \r\n * @returns {Series|DataFrame} Returns the union of two sequences.\r\n */\n\n\nSeries.prototype.union = function (other, selector) {\n  assert.instanceOf(other, Series, \"Expected 'other' parameter to 'Series.union' to be a Series or DataFrame.\");\n\n  if (selector) {\n    assert.isFunction(selector, \"Expected optional 'selector' parameter to 'Series.union' to be a selector function.\");\n  }\n\n  var self = this;\n  return self.concat(other).distinct(selector);\n};\n/**\r\n * Returns the intersection of values between two Series or DataFrames.\r\n *\r\n * @param {Series|DataFrame} other - The other Series or DataFrame to combine.\r\n * @param {function} [comparer] - Optional comparer that selects the value to compare.  \r\n * \r\n * @returns {Series|DataFrame} Returns the intersection of two sequences.\r\n */\n\n\nSeries.prototype.intersection = function (other, comparer) {\n  assert.instanceOf(other, Series, \"Expected 'other' parameter to 'Series.intersection' to be a Series or DataFrame.\");\n\n  if (comparer) {\n    assert.isFunction(comparer, \"Expected optional 'comparer' parameter to 'Series.intersection' to be a comparer function.\");\n  } else {\n    comparer = function (left, right) {\n      return left === right;\n    };\n  }\n\n  var self = this;\n  return self.where(function (left) {\n    return other.where(function (right) {\n      return comparer(left, right);\n    }).any();\n  });\n};\n/**\r\n * Returns the exception of values between two Series or DataFrames.\r\n *\r\n * @param {Series|DataFrame} other - The other Series or DataFrame to combine.\r\n * @param {function} [comparer] - Optional comparer that selects the value to compare.  \r\n * \r\n * @returns {Series|DataFrame} Returns the difference of one sequence to another.\r\n */\n\n\nSeries.prototype.except = function (other, comparer) {\n  assert.instanceOf(other, Series, \"Expected 'other' parameter to 'Series.except' to be a Series or DataFrame.\");\n\n  if (comparer) {\n    assert.isFunction(comparer, \"Expected optional 'comparer' parameter to 'Series.except' to be a comparer function.\");\n  } else {\n    comparer = function (left, right) {\n      return left === right;\n    };\n  }\n\n  var self = this;\n  return self.where(function (left) {\n    return other.where(function (right) {\n      return comparer(left, right);\n    }).none();\n  });\n};\n/** \r\n * Convert a series or a dataframe to a series of pairs in the form [pair1, pair2, pair3, ...] where each pair is [index, value].\r\n * \r\n * @returns {Pairs} Returns a series of pairs for each index and value pair in the input sequence.\r\n */\n\n\nSeries.prototype.asPairs = function () {\n  var self = this;\n  return new Pairs({\n    iterable: new PairsIterable(new CountIterable(), self)\n  }, self.factory // Used to restore back to values.\n  );\n};\n/**\r\n * Get a new series or dataframe starting at the specified index value.\r\n * \r\n * @param {value} indexValue - The value to search for before starting the new Series or DataFrame.\r\n * \r\n * @returns {Series|DataFrame} Returns a new series or dataframe with all values after the specified index. \r\n */\n\n\nSeries.prototype.startAt = function (indexValue) {\n  var self = this;\n  var lessThan = self.getIndex().getLessThan();\n  return self.asPairs().skipWhile(function (pair) {\n    return lessThan(pair[0], indexValue);\n  }).asValues();\n};\n/**\r\n * Get a new series or dataframe ending at the specified index value (inclusive).\r\n * \r\n * @param {value} indexValue - The value to search for before ending the new Series or DataFrame.\r\n * \r\n * @returns {Series|DataFrame} Returns a new series or dataframe with values up to and including the specified index. \r\n */\n\n\nSeries.prototype.endAt = function (indexValue) {\n  var self = this;\n  var greaterThan = self.getIndex().getGreaterThan();\n  return self.asPairs().takeUntil(function (pair) {\n    return greaterThan(pair[0], indexValue);\n  }).asValues();\n};\n/**\r\n * Get a new series or dataframe with all values before the specified index value (exclusive).\r\n * \r\n * @param {value} indexValue - The value to search for while taking values.\r\n * \r\n * @returns {Series|DataFrame} Returns a new series or dataframe with all values before the specified index. \r\n */\n\n\nSeries.prototype.before = function (indexValue) {\n  var self = this;\n  var lessThan = self.getIndex().getLessThan();\n  return self.asPairs().takeWhile(function (pair) {\n    return lessThan(pair[0], indexValue);\n  }).asValues();\n};\n/**\r\n * Get a new series or dataframe with all values after the specified index value (exclusive).\r\n * \r\n * @param {value} indexValue - The value to search for while taking values.\r\n * \r\n * @returns {Series|DataFrame} Returns a new series or dataframe with all values before the specified index. \r\n */\n\n\nSeries.prototype.after = function (indexValue) {\n  var self = this;\n  var greaterThan = self.getIndex().getGreaterThan();\n  return self.asPairs().skipUntil(function (pair) {\n    return greaterThan(pair[0], indexValue);\n  }).asValues();\n};\n/**\r\n * Get a new series or dataframe with all values between the specified index values (inclusive).\r\n * \r\n * @param {value} startIndexValue - The index where the new sequence starts. \r\n * @param {value} endIndexValue - The index where the new sequence ends.\r\n * \r\n * @returns {Series|DataFrame} Returns a new series or dataframe with all values before the specified index. \r\n */\n\n\nSeries.prototype.between = function (startIndexValue, endIndexValue) {\n  var self = this;\n  return self.startAt(startIndexValue).endAt(endIndexValue);\n};","map":null,"metadata":{},"sourceType":"script"}