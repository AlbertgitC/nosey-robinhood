{"ast":null,"code":"'use strict';\n\nvar errors = require('./errors.js'),\n    isFunction = require('lodash/isFunction'),\n    isObjectLike = require('lodash/isObjectLike'),\n    isString = require('lodash/isString'),\n    isUndefined = require('lodash/isUndefined');\n\nmodule.exports = function (options) {\n  var errorText = 'Please verify options'; // For better minification because this string is repeating\n\n  if (!isObjectLike(options)) {\n    throw new TypeError(errorText);\n  }\n\n  if (!isFunction(options.PromiseImpl)) {\n    throw new TypeError(errorText + '.PromiseImpl');\n  }\n\n  if (!isUndefined(options.constructorMixin) && !isFunction(options.constructorMixin)) {\n    throw new TypeError(errorText + '.PromiseImpl');\n  }\n\n  var PromiseImpl = options.PromiseImpl;\n  var constructorMixin = options.constructorMixin;\n  var plumbing = {};\n\n  plumbing.init = function (requestOptions) {\n    var self = this;\n    self._rp_promise = new PromiseImpl(function (resolve, reject) {\n      self._rp_resolve = resolve;\n      self._rp_reject = reject;\n\n      if (constructorMixin) {\n        constructorMixin.apply(self, arguments); // Using arguments since specific Promise libraries may pass additional parameters\n      }\n    });\n    self._rp_callbackOrig = requestOptions.callback;\n\n    requestOptions.callback = self.callback = function RP$callback(err, response, body) {\n      plumbing.callback.call(self, err, response, body);\n    };\n\n    if (isString(requestOptions.method)) {\n      requestOptions.method = requestOptions.method.toUpperCase();\n    }\n\n    requestOptions.transform = requestOptions.transform || plumbing.defaultTransformations[requestOptions.method];\n    self._rp_options = requestOptions;\n    self._rp_options.simple = requestOptions.simple !== false;\n    self._rp_options.resolveWithFullResponse = requestOptions.resolveWithFullResponse === true;\n    self._rp_options.transform2xxOnly = requestOptions.transform2xxOnly === true;\n  };\n\n  plumbing.defaultTransformations = {\n    HEAD: function (body, response, resolveWithFullResponse) {\n      return resolveWithFullResponse ? response : response.headers;\n    }\n  };\n\n  plumbing.callback = function (err, response, body) {\n    var self = this;\n    var origCallbackThrewException = false,\n        thrownException = null;\n\n    if (isFunction(self._rp_callbackOrig)) {\n      try {\n        self._rp_callbackOrig.apply(self, arguments); // TODO: Apply to self mimics behavior of request@2. Is that also right for request@next?\n\n      } catch (e) {\n        origCallbackThrewException = true;\n        thrownException = e;\n      }\n    }\n\n    var is2xx = !err && /^2/.test('' + response.statusCode);\n\n    if (err) {\n      self._rp_reject(new errors.RequestError(err, self._rp_options, response));\n    } else if (self._rp_options.simple && !is2xx) {\n      if (isFunction(self._rp_options.transform) && self._rp_options.transform2xxOnly === false) {\n        new PromiseImpl(function (resolve) {\n          resolve(self._rp_options.transform(body, response, self._rp_options.resolveWithFullResponse)); // transform may return a Promise\n        }).then(function (transformedResponse) {\n          self._rp_reject(new errors.StatusCodeError(response.statusCode, body, self._rp_options, transformedResponse));\n        }).catch(function (transformErr) {\n          self._rp_reject(new errors.TransformError(transformErr, self._rp_options, response));\n        });\n      } else {\n        self._rp_reject(new errors.StatusCodeError(response.statusCode, body, self._rp_options, response));\n      }\n    } else {\n      if (isFunction(self._rp_options.transform) && (is2xx || self._rp_options.transform2xxOnly === false)) {\n        new PromiseImpl(function (resolve) {\n          resolve(self._rp_options.transform(body, response, self._rp_options.resolveWithFullResponse)); // transform may return a Promise\n        }).then(function (transformedResponse) {\n          self._rp_resolve(transformedResponse);\n        }).catch(function (transformErr) {\n          self._rp_reject(new errors.TransformError(transformErr, self._rp_options, response));\n        });\n      } else if (self._rp_options.resolveWithFullResponse) {\n        self._rp_resolve(response);\n      } else {\n        self._rp_resolve(body);\n      }\n    }\n\n    if (origCallbackThrewException) {\n      throw thrownException;\n    }\n  };\n\n  plumbing.exposePromiseMethod = function (exposeTo, bindTo, promisePropertyKey, methodToExpose, exposeAs) {\n    exposeAs = exposeAs || methodToExpose;\n\n    if (exposeAs in exposeTo) {\n      throw new Error('Unable to expose method \"' + exposeAs + '\"');\n    }\n\n    exposeTo[exposeAs] = function RP$exposed() {\n      var self = bindTo || this;\n      return self[promisePropertyKey][methodToExpose].apply(self[promisePropertyKey], arguments);\n    };\n  };\n\n  plumbing.exposePromise = function (exposeTo, bindTo, promisePropertyKey, exposeAs) {\n    exposeAs = exposeAs || 'promise';\n\n    if (exposeAs in exposeTo) {\n      throw new Error('Unable to expose method \"' + exposeAs + '\"');\n    }\n\n    exposeTo[exposeAs] = function RP$promise() {\n      var self = bindTo || this;\n      return self[promisePropertyKey];\n    };\n  };\n\n  return plumbing;\n};","map":null,"metadata":{},"sourceType":"script"}