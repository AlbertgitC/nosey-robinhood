{"ast":null,"code":"'use strict';\n\nvar _createClass = require('babel-runtime/helpers/create-class')['default'];\n\nvar _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];\n\nvar _Object$defineProperty = require('babel-runtime/core-js/object/define-property')['default'];\n\nvar _Object$keys = require('babel-runtime/core-js/object/keys')['default'];\n\nvar _regeneratorRuntime = require('babel-runtime/regenerator')['default'];\n\nvar _Promise = require('babel-runtime/core-js/promise')['default'];\n\nvar _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];\n\n_Object$defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _mongodbCore = require('mongodb-core');\n\nvar _mongodbCore2 = _interopRequireDefault(_mongodbCore);\n\nvar _Cursor = require('./Cursor');\n\nvar _Cursor2 = _interopRequireDefault(_Cursor);\n\nvar _AggregationCursor = require('./AggregationCursor');\n\nvar _AggregationCursor2 = _interopRequireDefault(_AggregationCursor);\n\nvar _Bulk = require('./Bulk');\n\nvar _Bulk2 = _interopRequireDefault(_Bulk);\n\nvar _Utils = require('./Utils');\n\nvar Code = _mongodbCore2['default'].BSON.Code;\nvar ObjectID = _mongodbCore2['default'].BSON.ObjectID;\n\nfunction indexName(index) {\n  return _Object$keys(index).map(function (key) {\n    return key + '_' + index[key];\n  }).join('_');\n}\n\nfunction makeQuery(query) {\n  if (typeof query === 'undefined') {\n    return {};\n  } else if (query instanceof ObjectID || typeof query !== 'object') {\n    return {\n      _id: query\n    };\n  } else {\n    return query;\n  }\n}\n\nvar Collection = function () {\n  function Collection(db, collectionName) {\n    _classCallCheck(this, Collection);\n\n    this.initializeOrderedBulkOp = function () {\n      return new _Bulk2['default'](this, true);\n    };\n\n    this.initializeUnorderedBulkOp = function () {\n      return new _Bulk2['default'](this, false);\n    };\n\n    this.db = db;\n    this.collectionName = collectionName;\n    this.fullCollectionName = db.config.dbName + '.' + collectionName;\n    this.defaultWriteOptions = {\n      writeConcern: db.writeConcern,\n      ordered: true\n    };\n  }\n\n  _createClass(Collection, [{\n    key: 'aggregate',\n    value: function aggregate() {\n      var pipeline,\n          args$2$0 = arguments;\n      return _regeneratorRuntime.async(function aggregate$(context$2$0) {\n        while (1) switch (context$2$0.prev = context$2$0.next) {\n          case 0:\n            pipeline = Array.prototype.slice.call(args$2$0);\n            context$2$0.next = 3;\n            return _regeneratorRuntime.awrap(this.runCommand('aggregate', {\n              pipeline: pipeline\n            }));\n\n          case 3:\n            return context$2$0.abrupt('return', context$2$0.sent.result);\n\n          case 4:\n          case 'end':\n            return context$2$0.stop();\n        }\n      }, null, this);\n    }\n  }, {\n    key: 'aggregateCursor',\n    value: function aggregateCursor() {\n      var pipeline = Array.prototype.slice.call(arguments);\n      return new _Cursor2['default'](this, this.fullCollectionName, {\n        aggregate: this.collectionName,\n        pipeline: pipeline,\n        cursor: {\n          batchSize: 1000\n        }\n      }, {\n        cursor: {\n          batchSize: 1000\n        }\n      });\n    }\n  }, {\n    key: 'count',\n    value: function count(query) {\n      return _regeneratorRuntime.async(function count$(context$2$0) {\n        while (1) switch (context$2$0.prev = context$2$0.next) {\n          case 0:\n            context$2$0.next = 2;\n            return _regeneratorRuntime.awrap(this.find(query).count());\n\n          case 2:\n            return context$2$0.abrupt('return', context$2$0.sent);\n\n          case 3:\n          case 'end':\n            return context$2$0.stop();\n        }\n      }, null, this);\n    }\n  }, {\n    key: 'createIndex',\n    value: function createIndex(index, options) {\n      return _regeneratorRuntime.async(function createIndex$(context$2$0) {\n        while (1) switch (context$2$0.prev = context$2$0.next) {\n          case 0:\n            options = _lodash2['default'].extend({\n              name: indexName(index),\n              key: index\n            }, options || {});\n            context$2$0.next = 3;\n            return _regeneratorRuntime.awrap(this.runCommand('createIndexes', {\n              indexes: [options]\n            }));\n\n          case 3:\n            return context$2$0.abrupt('return', context$2$0.sent);\n\n          case 4:\n          case 'end':\n            return context$2$0.stop();\n        }\n      }, null, this);\n    }\n  }, {\n    key: 'distinct',\n    value: function distinct(key, query) {\n      return _regeneratorRuntime.async(function distinct$(context$2$0) {\n        while (1) switch (context$2$0.prev = context$2$0.next) {\n          case 0:\n            context$2$0.next = 2;\n            return _regeneratorRuntime.awrap(this.runCommand('distinct', {\n              key: key,\n              query: query\n            }));\n\n          case 2:\n            return context$2$0.abrupt('return', context$2$0.sent.values);\n\n          case 3:\n          case 'end':\n            return context$2$0.stop();\n        }\n      }, null, this);\n    }\n  }, {\n    key: 'drop',\n    value: function drop() {\n      return _regeneratorRuntime.async(function drop$(context$2$0) {\n        while (1) switch (context$2$0.prev = context$2$0.next) {\n          case 0:\n            context$2$0.prev = 0;\n            context$2$0.next = 3;\n            return _regeneratorRuntime.awrap(this.runCommand('drop'));\n\n          case 3:\n            return context$2$0.abrupt('return', true);\n\n          case 6:\n            context$2$0.prev = 6;\n            context$2$0.t0 = context$2$0['catch'](0);\n\n            if (!(context$2$0.t0.name === 'MongoError' && context$2$0.t0.message === 'ns not found')) {\n              context$2$0.next = 12;\n              break;\n            }\n\n            return context$2$0.abrupt('return', false);\n\n          case 12:\n            throw context$2$0.t0;\n\n          case 13:\n          case 'end':\n            return context$2$0.stop();\n        }\n      }, null, this, [[0, 6]]);\n    }\n  }, {\n    key: 'dropIndex',\n    value: function dropIndex(index) {\n      return _regeneratorRuntime.async(function dropIndex$(context$2$0) {\n        while (1) switch (context$2$0.prev = context$2$0.next) {\n          case 0:\n            context$2$0.next = 2;\n            return _regeneratorRuntime.awrap(this.runCommand('dropIndexes', {\n              index: index\n            }));\n\n          case 2:\n            return context$2$0.abrupt('return', context$2$0.sent);\n\n          case 3:\n          case 'end':\n            return context$2$0.stop();\n        }\n      }, null, this);\n    }\n  }, {\n    key: 'dropIndexes',\n    value: function dropIndexes() {\n      return _regeneratorRuntime.async(function dropIndexes$(context$2$0) {\n        while (1) switch (context$2$0.prev = context$2$0.next) {\n          case 0:\n            context$2$0.next = 2;\n            return _regeneratorRuntime.awrap(this.runCommand('dropIndexes', {\n              index: '*'\n            }));\n\n          case 2:\n            return context$2$0.abrupt('return', context$2$0.sent);\n\n          case 3:\n          case 'end':\n            return context$2$0.stop();\n        }\n      }, null, this);\n    }\n  }, {\n    key: 'ensureIndex',\n    value: function ensureIndex(index, options) {\n      return _regeneratorRuntime.async(function ensureIndex$(context$2$0) {\n        while (1) switch (context$2$0.prev = context$2$0.next) {\n          case 0:\n            context$2$0.next = 2;\n            return _regeneratorRuntime.awrap(this.createIndex(index, options));\n\n          case 2:\n            return context$2$0.abrupt('return', context$2$0.sent);\n\n          case 3:\n          case 'end':\n            return context$2$0.stop();\n        }\n      }, null, this);\n    }\n  }, {\n    key: 'find',\n    value: function find(query, projection, options) {\n      query = makeQuery(query);\n      projection = projection || null;\n      options = _lodash2['default'].extend({\n        find: this.collectionName,\n        query: query,\n        fields: projection\n      }, options || {});\n      return new _Cursor2['default'](this, this.fullCollectionName, options);\n    }\n  }, {\n    key: 'findAndModify',\n    value: function findAndModify(options) {\n      var result;\n      return _regeneratorRuntime.async(function findAndModify$(context$2$0) {\n        while (1) switch (context$2$0.prev = context$2$0.next) {\n          case 0:\n            context$2$0.next = 2;\n            return _regeneratorRuntime.awrap(this.runCommand('findAndModify', options));\n\n          case 2:\n            result = context$2$0.sent;\n\n            if (!result.lastErrorObject) {\n              result.lastErrorObject = {\n                n: 0\n              };\n            }\n\n            return context$2$0.abrupt('return', result);\n\n          case 5:\n          case 'end':\n            return context$2$0.stop();\n        }\n      }, null, this);\n    }\n  }, {\n    key: 'findOne',\n    value: function findOne(query, projection) {\n      var cursor, result;\n      return _regeneratorRuntime.async(function findOne$(context$2$0) {\n        while (1) switch (context$2$0.prev = context$2$0.next) {\n          case 0:\n            query = makeQuery(query);\n            cursor = this.find(query, projection).limit(1);\n            context$2$0.next = 4;\n            return _regeneratorRuntime.awrap(cursor.next());\n\n          case 4:\n            result = context$2$0.sent;\n            return context$2$0.abrupt('return', result);\n\n          case 6:\n          case 'end':\n            return context$2$0.stop();\n        }\n      }, null, this);\n    }\n  }, {\n    key: 'getIndexes',\n    value: function getIndexes() {\n      var ns;\n      return _regeneratorRuntime.async(function getIndexes$(context$2$0) {\n        while (1) switch (context$2$0.prev = context$2$0.next) {\n          case 0:\n            ns = this.db.config.dbName + '.system.indexes';\n            context$2$0.next = 3;\n            return _regeneratorRuntime.awrap(new _Cursor2['default'](this, ns, {\n              find: ns,\n              query: {\n                ns: this.fullCollectionName\n              },\n              projection: {}\n            }).toArray());\n\n          case 3:\n            return context$2$0.abrupt('return', context$2$0.sent);\n\n          case 4:\n          case 'end':\n            return context$2$0.stop();\n        }\n      }, null, this);\n    }\n  }, {\n    key: 'group',\n    value: function group(doc) {\n      var cmd;\n      return _regeneratorRuntime.async(function group$(context$2$0) {\n        while (1) switch (context$2$0.prev = context$2$0.next) {\n          case 0:\n            cmd = {\n              group: {\n                ns: this.collectionName,\n                key: doc.key,\n                initial: doc.initial,\n                $reduce: new Code(doc.reduce.toString()),\n                out: 'inline',\n                cond: doc.cond\n              }\n            };\n\n            if (doc.finalize) {\n              cmd.group.finalize = new Code(doc.finalize.toString());\n            }\n\n            if (doc.keys) {\n              cmd.group.$keyf = new Code(doc.keys.toString());\n            }\n\n            context$2$0.next = 5;\n            return _regeneratorRuntime.awrap(this.db.runCommand(cmd));\n\n          case 5:\n            return context$2$0.abrupt('return', context$2$0.sent.retval);\n\n          case 6:\n          case 'end':\n            return context$2$0.stop();\n        }\n      }, null, this);\n    }\n  }, {\n    key: 'insert',\n    value: function insert(docs) {\n      var self, docList, i, server;\n      return _regeneratorRuntime.async(function insert$(context$2$0) {\n        while (1) switch (context$2$0.prev = context$2$0.next) {\n          case 0:\n            self = this;\n            docList = docs;\n\n            if (!Array.isArray(docs)) {\n              docList = [docs];\n            }\n\n            for (i = 0; i < docList.length; ++i) {\n              if (!docList[i]._id) {\n                docList[i]._id = ObjectID.createPk();\n              }\n            }\n\n            context$2$0.next = 6;\n            return _regeneratorRuntime.awrap(self.db.connect());\n\n          case 6:\n            server = context$2$0.sent;\n            context$2$0.next = 9;\n            return _regeneratorRuntime.awrap(new _Promise(function (resolve, reject) {\n              server.insert(self.fullCollectionName, docList, self.defaultWriteOptions, function (error, result) {\n                if (error) {\n                  reject(error);\n                } else if (result.result.code) {\n                  reject((0, _Utils.toError)(result.result));\n                } else if (result.result.writeErrors) {\n                  reject((0, _Utils.toError)(result.result.writeErrors[0]));\n                } else {\n                  resolve(docs);\n                }\n              });\n            }));\n\n          case 9:\n            return context$2$0.abrupt('return', context$2$0.sent);\n\n          case 10:\n          case 'end':\n            return context$2$0.stop();\n        }\n      }, null, this);\n    }\n  }, {\n    key: 'isCapped',\n    value: function isCapped() {\n      var ns, result;\n      return _regeneratorRuntime.async(function isCapped$(context$2$0) {\n        while (1) switch (context$2$0.prev = context$2$0.next) {\n          case 0:\n            ns = this.db.config.dbName + '.system.namespaces';\n            context$2$0.next = 3;\n            return _regeneratorRuntime.awrap(new _Cursor2['default'](this, ns, {\n              find: ns,\n              query: {\n                name: this.fullCollectionName\n              },\n              projection: {}\n            }).toArray());\n\n          case 3:\n            result = context$2$0.sent;\n            return context$2$0.abrupt('return', !!(result[0].options && result[0].options.capped));\n\n          case 5:\n          case 'end':\n            return context$2$0.stop();\n        }\n      }, null, this);\n    }\n  }, {\n    key: 'mapReduce',\n    value: function mapReduce(map, reduce, options) {\n      return _regeneratorRuntime.async(function mapReduce$(context$2$0) {\n        while (1) switch (context$2$0.prev = context$2$0.next) {\n          case 0:\n            options = options || {};\n            context$2$0.next = 3;\n            return _regeneratorRuntime.awrap(this.runCommand('mapReduce', {\n              map: map.toString(),\n              reduce: reduce.toString(),\n              query: options.query || {},\n              out: options.out\n            }));\n\n          case 3:\n            return context$2$0.abrupt('return', context$2$0.sent);\n\n          case 4:\n          case 'end':\n            return context$2$0.stop();\n        }\n      }, null, this);\n    }\n  }, {\n    key: 'reIndex',\n    value: function reIndex() {\n      return _regeneratorRuntime.async(function reIndex$(context$2$0) {\n        while (1) switch (context$2$0.prev = context$2$0.next) {\n          case 0:\n            context$2$0.next = 2;\n            return _regeneratorRuntime.awrap(this.runCommand('reIndex'));\n\n          case 2:\n            return context$2$0.abrupt('return', context$2$0.sent);\n\n          case 3:\n          case 'end':\n            return context$2$0.stop();\n        }\n      }, null, this);\n    }\n  }, {\n    key: 'remove',\n    value: function remove(query, justOne) {\n      var self,\n          server,\n          args$2$0 = arguments;\n      return _regeneratorRuntime.async(function remove$(context$2$0) {\n        while (1) switch (context$2$0.prev = context$2$0.next) {\n          case 0:\n            query = makeQuery(query);\n\n            if (args$2$0.length === 0) {\n              query = {};\n            }\n\n            if (args$2$0.length < 2) {\n              justOne = false;\n            }\n\n            self = this;\n            context$2$0.next = 6;\n            return _regeneratorRuntime.awrap(self.db.connect());\n\n          case 6:\n            server = context$2$0.sent;\n            context$2$0.next = 9;\n            return _regeneratorRuntime.awrap(new _Promise(function (resolve, reject) {\n              server.remove(self.fullCollectionName, [{\n                q: query,\n                limit: justOne ? 1 : 0\n              }], self.defaultWriteOptions, function (error, result) {\n                if (error) {\n                  reject(error);\n                } else {\n                  resolve(result.result);\n                }\n              });\n            }));\n\n          case 9:\n            return context$2$0.abrupt('return', context$2$0.sent);\n\n          case 10:\n          case 'end':\n            return context$2$0.stop();\n        }\n      }, null, this);\n    }\n  }, {\n    key: 'runCommand',\n    value: function runCommand(command, options) {\n      var temp;\n      return _regeneratorRuntime.async(function runCommand$(context$2$0) {\n        while (1) switch (context$2$0.prev = context$2$0.next) {\n          case 0:\n            temp = {};\n            temp[command] = this.collectionName;\n            options = _lodash2['default'].extend(temp, options || {});\n            context$2$0.next = 5;\n            return _regeneratorRuntime.awrap(this.db.runCommand(options));\n\n          case 5:\n            return context$2$0.abrupt('return', context$2$0.sent);\n\n          case 6:\n          case 'end':\n            return context$2$0.stop();\n        }\n      }, null, this);\n    }\n  }, {\n    key: 'save',\n    value: function save(doc) {\n      return _regeneratorRuntime.async(function save$(context$2$0) {\n        while (1) switch (context$2$0.prev = context$2$0.next) {\n          case 0:\n            if (!doc._id) {\n              context$2$0.next = 6;\n              break;\n            }\n\n            context$2$0.next = 3;\n            return _regeneratorRuntime.awrap(this.update({\n              _id: doc._id\n            }, doc, {\n              upsert: true\n            }));\n\n          case 3:\n            return context$2$0.abrupt('return', doc);\n\n          case 6:\n            context$2$0.next = 8;\n            return _regeneratorRuntime.awrap(this.insert(doc));\n\n          case 8:\n            return context$2$0.abrupt('return', context$2$0.sent);\n\n          case 9:\n          case 'end':\n            return context$2$0.stop();\n        }\n      }, null, this);\n    }\n  }, {\n    key: 'stats',\n    value: function stats() {\n      return _regeneratorRuntime.async(function stats$(context$2$0) {\n        while (1) switch (context$2$0.prev = context$2$0.next) {\n          case 0:\n            context$2$0.next = 2;\n            return _regeneratorRuntime.awrap(this.runCommand('collStats'));\n\n          case 2:\n            return context$2$0.abrupt('return', context$2$0.sent);\n\n          case 3:\n          case 'end':\n            return context$2$0.stop();\n        }\n      }, null, this);\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.collectionName;\n    }\n  }, {\n    key: 'update',\n    value: function update(query, _update, options) {\n      var self, server;\n      return _regeneratorRuntime.async(function update$(context$2$0) {\n        while (1) switch (context$2$0.prev = context$2$0.next) {\n          case 0:\n            query = makeQuery(query);\n            self = this;\n\n            if (!options) {\n              options = {};\n            }\n\n            context$2$0.next = 5;\n            return _regeneratorRuntime.awrap(self.db.connect());\n\n          case 5:\n            server = context$2$0.sent;\n            context$2$0.next = 8;\n            return _regeneratorRuntime.awrap(new _Promise(function (resolve, reject) {\n              options = _lodash2['default'].extend({\n                q: query,\n                u: _update\n              }, options);\n              server.update(self.fullCollectionName, [options], self.defaultWriteOptions, function (error, result) {\n                if (error) {\n                  reject(error);\n                } else if (result.result.code) {\n                  reject((0, _Utils.toError)(result.result));\n                } else if (result.result.writeErrors) {\n                  reject((0, _Utils.toError)(result.result.writeErrors[0]));\n                } else {\n                  result = result.result; // backwards compatibility\n\n                  if (!result.updatedExisting && result.nModified === result.n) {\n                    result.updatedExisting = true;\n                  }\n\n                  resolve(result);\n                }\n              });\n            }));\n\n          case 8:\n            return context$2$0.abrupt('return', context$2$0.sent);\n\n          case 9:\n          case 'end':\n            return context$2$0.stop();\n        }\n      }, null, this);\n    }\n  }]);\n\n  return Collection;\n}();\n\nexports['default'] = Collection;\n;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}