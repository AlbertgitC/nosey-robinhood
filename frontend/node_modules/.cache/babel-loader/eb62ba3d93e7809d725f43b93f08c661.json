{"ast":null,"code":"/*--------------------------------------------------------------------------\r\n * linq.js - LINQ for JavaScript\r\n * licensed under MIT License\r\n *------------------------------------------------------------------------*/\n(function (root, undefined) {\n  // ReadOnly Function\n  var Functions = {\n    Identity: function (x) {\n      return x;\n    },\n    True: function () {\n      return true;\n    },\n    Blank: function () {}\n  }; // const Type\n\n  var Types = {\n    Boolean: typeof true,\n    Number: typeof 0,\n    String: typeof \"\",\n    Object: typeof {},\n    Undefined: typeof undefined,\n    Function: typeof function () {}\n  }; // createLambda cache\n\n  var funcCache = {\n    \"\": Functions.Identity\n  }; // private utility methods\n\n  var Utils = {\n    // Create anonymous function from lambda expression string\n    createLambda: function (expression) {\n      if (expression == null) return Functions.Identity;\n\n      if (typeof expression === Types.String) {\n        // get from cache\n        var f = funcCache[expression];\n\n        if (f != null) {\n          return f;\n        }\n\n        if (expression.indexOf(\"=>\") === -1) {\n          var regexp = new RegExp(\"[$]+\", \"g\");\n          var maxLength = 0;\n          var match;\n\n          while ((match = regexp.exec(expression)) != null) {\n            var paramNumber = match[0].length;\n\n            if (paramNumber > maxLength) {\n              maxLength = paramNumber;\n            }\n          }\n\n          var argArray = [];\n\n          for (var i = 1; i <= maxLength; i++) {\n            var dollar = \"\";\n\n            for (var j = 0; j < i; j++) {\n              dollar += \"$\";\n            }\n\n            argArray.push(dollar);\n          }\n\n          var args = Array.prototype.join.call(argArray, \",\");\n          f = new Function(args, \"return \" + expression);\n          funcCache[expression] = f;\n          return f;\n        } else {\n          var expr = expression.match(/^[(\\s]*([^()]*?)[)\\s]*=>(.*)/);\n          f = new Function(expr[1], \"return \" + expr[2]);\n          funcCache[expression] = f;\n          return f;\n        }\n      }\n\n      return expression;\n    },\n    isIEnumerable: function (obj) {\n      if (typeof Enumerator !== Types.Undefined) {\n        try {\n          new Enumerator(obj); // check JScript(IE)'s Enumerator\n\n          return true;\n        } catch (e) {}\n      }\n\n      return false;\n    },\n    // IE8's defineProperty is defined but cannot use, therefore check defineProperties\n    defineProperty: Object.defineProperties != null ? function (target, methodName, value) {\n      Object.defineProperty(target, methodName, {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: value\n      });\n    } : function (target, methodName, value) {\n      target[methodName] = value;\n    },\n    compare: function (a, b) {\n      return a === b ? 0 : a > b ? 1 : -1;\n    },\n    dispose: function (obj) {\n      if (obj != null) obj.dispose();\n    },\n    hasNativeIteratorSupport: function () {\n      return typeof Symbol !== 'undefined' && typeof Symbol.iterator !== 'undefined';\n    }\n  }; // IEnumerator State\n\n  var State = {\n    Before: 0,\n    Running: 1,\n    After: 2\n  }; // \"Enumerator\" is conflict JScript's \"Enumerator\"\n\n  var IEnumerator = function (initialize, tryGetNext, dispose) {\n    var yielder = new Yielder();\n    var state = State.Before;\n    this.current = yielder.current;\n\n    this.moveNext = function () {\n      try {\n        switch (state) {\n          case State.Before:\n            state = State.Running;\n            initialize();\n          // fall through\n\n          case State.Running:\n            if (tryGetNext.apply(yielder)) {\n              return true;\n            } else {\n              this.dispose();\n              return false;\n            }\n\n          case State.After:\n            return false;\n        }\n      } catch (e) {\n        this.dispose();\n        throw e;\n      }\n    };\n\n    this.dispose = function () {\n      if (state != State.Running) return;\n\n      try {\n        dispose();\n      } finally {\n        state = State.After;\n      }\n    };\n  }; // for tryGetNext\n\n\n  var Yielder = function () {\n    var current = null;\n\n    this.current = function () {\n      return current;\n    };\n\n    this.yieldReturn = function (value) {\n      current = value;\n      return true;\n    };\n\n    this.yieldBreak = function () {\n      return false;\n    };\n  }; // Enumerable constuctor\n\n\n  var Enumerable = function (getEnumerator) {\n    this.getEnumerator = getEnumerator;\n  }; // Utility\n\n\n  Enumerable.Utils = {}; // container\n\n  Enumerable.Utils.createLambda = function (expression) {\n    return Utils.createLambda(expression);\n  };\n\n  Enumerable.Utils.createEnumerable = function (getEnumerator) {\n    return new Enumerable(getEnumerator);\n  };\n\n  Enumerable.Utils.createEnumerator = function (initialize, tryGetNext, dispose) {\n    return new IEnumerator(initialize, tryGetNext, dispose);\n  };\n\n  Enumerable.Utils.extendTo = function (type) {\n    var typeProto = type.prototype;\n    var enumerableProto;\n\n    if (type === Array) {\n      enumerableProto = ArrayEnumerable.prototype;\n      Utils.defineProperty(typeProto, \"getSource\", function () {\n        return this;\n      });\n    } else {\n      enumerableProto = Enumerable.prototype;\n      Utils.defineProperty(typeProto, \"getEnumerator\", function () {\n        return Enumerable.from(this).getEnumerator();\n      });\n    }\n\n    for (var methodName in enumerableProto) {\n      var func = enumerableProto[methodName]; // already extended\n\n      if (typeProto[methodName] == func) continue; // already defined(example Array#reverse/join/forEach...)\n\n      if (typeProto[methodName] != null) {\n        methodName = methodName + \"ByLinq\";\n        if (typeProto[methodName] == func) continue; // recheck\n      }\n\n      if (func instanceof Function) {\n        Utils.defineProperty(typeProto, methodName, func);\n      }\n    }\n  }; // Generator\n\n\n  Enumerable.choice = function () // variable argument\n  {\n    var args = arguments;\n    return new Enumerable(function () {\n      return new IEnumerator(function () {\n        args = args[0] instanceof Array ? args[0] : args[0].getEnumerator != null ? args[0].toArray() : args;\n      }, function () {\n        return this.yieldReturn(args[Math.floor(Math.random() * args.length)]);\n      }, Functions.Blank);\n    });\n  };\n\n  Enumerable.cycle = function () // variable argument\n  {\n    var args = arguments;\n    return new Enumerable(function () {\n      var index = 0;\n      return new IEnumerator(function () {\n        args = args[0] instanceof Array ? args[0] : args[0].getEnumerator != null ? args[0].toArray() : args;\n      }, function () {\n        if (index >= args.length) index = 0;\n        return this.yieldReturn(args[index++]);\n      }, Functions.Blank);\n    });\n  };\n\n  Enumerable.empty = function () {\n    return new Enumerable(function () {\n      return new IEnumerator(Functions.Blank, function () {\n        return false;\n      }, Functions.Blank);\n    });\n  };\n\n  Enumerable.from = function (obj) {\n    if (obj == null) {\n      return Enumerable.empty();\n    }\n\n    if (obj instanceof Enumerable) {\n      return obj;\n    }\n\n    if (typeof obj == Types.Number || typeof obj == Types.Boolean) {\n      return Enumerable.repeat(obj, 1);\n    }\n\n    if (typeof obj == Types.String) {\n      return new Enumerable(function () {\n        var index = 0;\n        return new IEnumerator(Functions.Blank, function () {\n          return index < obj.length ? this.yieldReturn(obj.charAt(index++)) : false;\n        }, Functions.Blank);\n      });\n    }\n\n    if (typeof obj != Types.Function) {\n      // array or array like object\n      if (typeof obj.length == Types.Number) {\n        return new ArrayEnumerable(obj);\n      } // iterable object\n\n\n      if (typeof Symbol !== 'undefined' && typeof obj[Symbol.iterator] !== 'undefined') {\n        return new Enumerable(function () {\n          return new IEnumerator(Functions.Blank, function () {\n            var next = obj.next();\n            return next.done ? false : this.yieldReturn(next.value);\n          }, Functions.Blank);\n        });\n      } // JScript's IEnumerable\n\n\n      if (!(obj instanceof Object) && Utils.isIEnumerable(obj)) {\n        return new Enumerable(function () {\n          var isFirst = true;\n          var enumerator;\n          return new IEnumerator(function () {\n            enumerator = new Enumerator(obj);\n          }, function () {\n            if (isFirst) isFirst = false;else enumerator.moveNext();\n            return enumerator.atEnd() ? false : this.yieldReturn(enumerator.item());\n          }, Functions.Blank);\n        });\n      } // WinMD IIterable<T>\n\n\n      if (typeof Windows === Types.Object && typeof obj.first === Types.Function) {\n        return new Enumerable(function () {\n          var isFirst = true;\n          var enumerator;\n          return new IEnumerator(function () {\n            enumerator = obj.first();\n          }, function () {\n            if (isFirst) isFirst = false;else enumerator.moveNext();\n            return enumerator.hasCurrent ? this.yieldReturn(enumerator.current) : this.yieldBreak();\n          }, Functions.Blank);\n        });\n      }\n    } // case function/object : Create keyValuePair[]\n\n\n    return new Enumerable(function () {\n      var array = [];\n      var index = 0;\n      return new IEnumerator(function () {\n        for (var key in obj) {\n          var value = obj[key];\n\n          if (!(value instanceof Function) && Object.prototype.hasOwnProperty.call(obj, key)) {\n            array.push({\n              key: key,\n              value: value\n            });\n          }\n        }\n      }, function () {\n        return index < array.length ? this.yieldReturn(array[index++]) : false;\n      }, Functions.Blank);\n    });\n  }, Enumerable.make = function (element) {\n    return Enumerable.repeat(element, 1);\n  }; // Overload:function(input, pattern)\n  // Overload:function(input, pattern, flags)\n\n  Enumerable.matches = function (input, pattern, flags) {\n    if (flags == null) flags = \"\";\n\n    if (pattern instanceof RegExp) {\n      flags += pattern.ignoreCase ? \"i\" : \"\";\n      flags += pattern.multiline ? \"m\" : \"\";\n      pattern = pattern.source;\n    }\n\n    if (flags.indexOf(\"g\") === -1) flags += \"g\";\n    return new Enumerable(function () {\n      var regex;\n      return new IEnumerator(function () {\n        regex = new RegExp(pattern, flags);\n      }, function () {\n        var match = regex.exec(input);\n        return match ? this.yieldReturn(match) : false;\n      }, Functions.Blank);\n    });\n  }; // Overload:function(start, count)\n  // Overload:function(start, count, step)\n\n\n  Enumerable.range = function (start, count, step) {\n    if (step == null) step = 1;\n    return new Enumerable(function () {\n      var value;\n      var index = 0;\n      return new IEnumerator(function () {\n        value = start - step;\n      }, function () {\n        return index++ < count ? this.yieldReturn(value += step) : this.yieldBreak();\n      }, Functions.Blank);\n    });\n  }; // Overload:function(start, count)\n  // Overload:function(start, count, step)\n\n\n  Enumerable.rangeDown = function (start, count, step) {\n    if (step == null) step = 1;\n    return new Enumerable(function () {\n      var value;\n      var index = 0;\n      return new IEnumerator(function () {\n        value = start + step;\n      }, function () {\n        return index++ < count ? this.yieldReturn(value -= step) : this.yieldBreak();\n      }, Functions.Blank);\n    });\n  }; // Overload:function(start, to)\n  // Overload:function(start, to, step)\n\n\n  Enumerable.rangeTo = function (start, to, step) {\n    if (step == null) step = 1;\n\n    if (start < to) {\n      return new Enumerable(function () {\n        var value;\n        return new IEnumerator(function () {\n          value = start - step;\n        }, function () {\n          var next = value += step;\n          return next <= to ? this.yieldReturn(next) : this.yieldBreak();\n        }, Functions.Blank);\n      });\n    } else {\n      return new Enumerable(function () {\n        var value;\n        return new IEnumerator(function () {\n          value = start + step;\n        }, function () {\n          var next = value -= step;\n          return next >= to ? this.yieldReturn(next) : this.yieldBreak();\n        }, Functions.Blank);\n      });\n    }\n  }; // Overload:function(element)\n  // Overload:function(element, count)\n\n\n  Enumerable.repeat = function (element, count) {\n    if (count != null) return Enumerable.repeat(element).take(count);\n    return new Enumerable(function () {\n      return new IEnumerator(Functions.Blank, function () {\n        return this.yieldReturn(element);\n      }, Functions.Blank);\n    });\n  };\n\n  Enumerable.repeatWithFinalize = function (initializer, finalizer) {\n    initializer = Utils.createLambda(initializer);\n    finalizer = Utils.createLambda(finalizer);\n    return new Enumerable(function () {\n      var element;\n      return new IEnumerator(function () {\n        element = initializer();\n      }, function () {\n        return this.yieldReturn(element);\n      }, function () {\n        if (element != null) {\n          finalizer(element);\n          element = null;\n        }\n      });\n    });\n  }; // Overload:function(func)\n  // Overload:function(func, count)\n\n\n  Enumerable.generate = function (func, count) {\n    if (count != null) return Enumerable.generate(func).take(count);\n    func = Utils.createLambda(func);\n    return new Enumerable(function () {\n      return new IEnumerator(Functions.Blank, function () {\n        return this.yieldReturn(func());\n      }, Functions.Blank);\n    });\n  }; // Overload:function()\n  // Overload:function(start)\n  // Overload:function(start, step)\n\n\n  Enumerable.toInfinity = function (start, step) {\n    if (start == null) start = 0;\n    if (step == null) step = 1;\n    return new Enumerable(function () {\n      var value;\n      return new IEnumerator(function () {\n        value = start - step;\n      }, function () {\n        return this.yieldReturn(value += step);\n      }, Functions.Blank);\n    });\n  }; // Overload:function()\n  // Overload:function(start)\n  // Overload:function(start, step)\n\n\n  Enumerable.toNegativeInfinity = function (start, step) {\n    if (start == null) start = 0;\n    if (step == null) step = 1;\n    return new Enumerable(function () {\n      var value;\n      return new IEnumerator(function () {\n        value = start + step;\n      }, function () {\n        return this.yieldReturn(value -= step);\n      }, Functions.Blank);\n    });\n  };\n\n  Enumerable.unfold = function (seed, func) {\n    func = Utils.createLambda(func);\n    return new Enumerable(function () {\n      var isFirst = true;\n      var value;\n      return new IEnumerator(Functions.Blank, function () {\n        if (isFirst) {\n          isFirst = false;\n          value = seed;\n          return this.yieldReturn(value);\n        }\n\n        value = func(value);\n        return this.yieldReturn(value);\n      }, Functions.Blank);\n    });\n  };\n\n  Enumerable.defer = function (enumerableFactory) {\n    return new Enumerable(function () {\n      var enumerator;\n      return new IEnumerator(function () {\n        enumerator = Enumerable.from(enumerableFactory()).getEnumerator();\n      }, function () {\n        return enumerator.moveNext() ? this.yieldReturn(enumerator.current()) : this.yieldBreak();\n      }, function () {\n        Utils.dispose(enumerator);\n      });\n    });\n  }; // Extension Methods\n\n  /* Projection and Filtering Methods */\n  // Overload:function(func)\n  // Overload:function(func, resultSelector<element>)\n  // Overload:function(func, resultSelector<element, nestLevel>)\n\n\n  Enumerable.prototype.traverseBreadthFirst = function (func, resultSelector) {\n    var source = this;\n    func = Utils.createLambda(func);\n    resultSelector = Utils.createLambda(resultSelector);\n    return new Enumerable(function () {\n      var enumerator;\n      var nestLevel = 0;\n      var buffer = [];\n      return new IEnumerator(function () {\n        enumerator = source.getEnumerator();\n      }, function () {\n        while (true) {\n          if (enumerator.moveNext()) {\n            buffer.push(enumerator.current());\n            return this.yieldReturn(resultSelector(enumerator.current(), nestLevel));\n          }\n\n          var next = Enumerable.from(buffer).selectMany(function (x) {\n            return func(x);\n          });\n\n          if (!next.any()) {\n            return false;\n          } else {\n            nestLevel++;\n            buffer = [];\n            Utils.dispose(enumerator);\n            enumerator = next.getEnumerator();\n          }\n        }\n      }, function () {\n        Utils.dispose(enumerator);\n      });\n    });\n  }; // Overload:function(func)\n  // Overload:function(func, resultSelector<element>)\n  // Overload:function(func, resultSelector<element, nestLevel>)\n\n\n  Enumerable.prototype.traverseDepthFirst = function (func, resultSelector) {\n    var source = this;\n    func = Utils.createLambda(func);\n    resultSelector = Utils.createLambda(resultSelector);\n    return new Enumerable(function () {\n      var enumeratorStack = [];\n      var enumerator;\n      return new IEnumerator(function () {\n        enumerator = source.getEnumerator();\n      }, function () {\n        while (true) {\n          if (enumerator.moveNext()) {\n            var value = resultSelector(enumerator.current(), enumeratorStack.length);\n            enumeratorStack.push(enumerator);\n            enumerator = Enumerable.from(func(enumerator.current())).getEnumerator();\n            return this.yieldReturn(value);\n          }\n\n          if (enumeratorStack.length <= 0) return false;\n          Utils.dispose(enumerator);\n          enumerator = enumeratorStack.pop();\n        }\n      }, function () {\n        try {\n          Utils.dispose(enumerator);\n        } finally {\n          Enumerable.from(enumeratorStack).forEach(function (s) {\n            s.dispose();\n          });\n        }\n      });\n    });\n  };\n\n  Enumerable.prototype.flatten = function () {\n    var source = this;\n    return new Enumerable(function () {\n      var enumerator;\n      var middleEnumerator = null;\n      return new IEnumerator(function () {\n        enumerator = source.getEnumerator();\n      }, function () {\n        while (true) {\n          if (middleEnumerator != null) {\n            if (middleEnumerator.moveNext()) {\n              return this.yieldReturn(middleEnumerator.current());\n            } else {\n              middleEnumerator = null;\n            }\n          }\n\n          if (enumerator.moveNext()) {\n            if (enumerator.current() instanceof Array) {\n              Utils.dispose(middleEnumerator);\n              middleEnumerator = Enumerable.from(enumerator.current()).selectMany(Functions.Identity).flatten().getEnumerator();\n              continue;\n            } else {\n              return this.yieldReturn(enumerator.current());\n            }\n          }\n\n          return false;\n        }\n      }, function () {\n        try {\n          Utils.dispose(enumerator);\n        } finally {\n          Utils.dispose(middleEnumerator);\n        }\n      });\n    });\n  };\n\n  Enumerable.prototype.pairwise = function (selector) {\n    var source = this;\n    selector = Utils.createLambda(selector);\n    return new Enumerable(function () {\n      var enumerator;\n      return new IEnumerator(function () {\n        enumerator = source.getEnumerator();\n        enumerator.moveNext();\n      }, function () {\n        var prev = enumerator.current();\n        return enumerator.moveNext() ? this.yieldReturn(selector(prev, enumerator.current())) : false;\n      }, function () {\n        Utils.dispose(enumerator);\n      });\n    });\n  }; // Overload:function(func)\n  // Overload:function(seed,func<value,element>)\n\n\n  Enumerable.prototype.scan = function (seed, func) {\n    var isUseSeed;\n\n    if (func == null) {\n      func = Utils.createLambda(seed); // arguments[0]\n\n      isUseSeed = false;\n    } else {\n      func = Utils.createLambda(func);\n      isUseSeed = true;\n    }\n\n    var source = this;\n    return new Enumerable(function () {\n      var enumerator;\n      var value;\n      var isFirst = true;\n      return new IEnumerator(function () {\n        enumerator = source.getEnumerator();\n      }, function () {\n        if (isFirst) {\n          isFirst = false;\n\n          if (!isUseSeed) {\n            if (enumerator.moveNext()) {\n              return this.yieldReturn(value = enumerator.current());\n            }\n          } else {\n            return this.yieldReturn(value = seed);\n          }\n        }\n\n        return enumerator.moveNext() ? this.yieldReturn(value = func(value, enumerator.current())) : false;\n      }, function () {\n        Utils.dispose(enumerator);\n      });\n    });\n  }; // Overload:function(selector<element>)\n  // Overload:function(selector<element,index>)\n\n\n  Enumerable.prototype.select = function (selector) {\n    selector = Utils.createLambda(selector);\n\n    if (selector.length <= 1) {\n      return new WhereSelectEnumerable(this, null, selector);\n    } else {\n      var source = this;\n      return new Enumerable(function () {\n        var enumerator;\n        var index = 0;\n        return new IEnumerator(function () {\n          enumerator = source.getEnumerator();\n        }, function () {\n          return enumerator.moveNext() ? this.yieldReturn(selector(enumerator.current(), index++)) : false;\n        }, function () {\n          Utils.dispose(enumerator);\n        });\n      });\n    }\n  }; // Overload:function(collectionSelector<element>)\n  // Overload:function(collectionSelector<element,index>)\n  // Overload:function(collectionSelector<element>,resultSelector)\n  // Overload:function(collectionSelector<element,index>,resultSelector)\n\n\n  Enumerable.prototype.selectMany = function (collectionSelector, resultSelector) {\n    var source = this;\n    collectionSelector = Utils.createLambda(collectionSelector);\n    if (resultSelector == null) resultSelector = function (a, b) {\n      return b;\n    };\n    resultSelector = Utils.createLambda(resultSelector);\n    return new Enumerable(function () {\n      var enumerator;\n      var middleEnumerator = undefined;\n      var index = 0;\n      return new IEnumerator(function () {\n        enumerator = source.getEnumerator();\n      }, function () {\n        if (middleEnumerator === undefined) {\n          if (!enumerator.moveNext()) return false;\n        }\n\n        do {\n          if (middleEnumerator == null) {\n            var middleSeq = collectionSelector(enumerator.current(), index++);\n            middleEnumerator = Enumerable.from(middleSeq).getEnumerator();\n          }\n\n          if (middleEnumerator.moveNext()) {\n            return this.yieldReturn(resultSelector(enumerator.current(), middleEnumerator.current()));\n          }\n\n          Utils.dispose(middleEnumerator);\n          middleEnumerator = null;\n        } while (enumerator.moveNext());\n\n        return false;\n      }, function () {\n        try {\n          Utils.dispose(enumerator);\n        } finally {\n          Utils.dispose(middleEnumerator);\n        }\n      });\n    });\n  }; // Overload:function(predicate<element>)\n  // Overload:function(predicate<element,index>)\n\n\n  Enumerable.prototype.where = function (predicate) {\n    predicate = Utils.createLambda(predicate);\n\n    if (predicate.length <= 1) {\n      return new WhereEnumerable(this, predicate);\n    } else {\n      var source = this;\n      return new Enumerable(function () {\n        var enumerator;\n        var index = 0;\n        return new IEnumerator(function () {\n          enumerator = source.getEnumerator();\n        }, function () {\n          while (enumerator.moveNext()) {\n            if (predicate(enumerator.current(), index++)) {\n              return this.yieldReturn(enumerator.current());\n            }\n          }\n\n          return false;\n        }, function () {\n          Utils.dispose(enumerator);\n        });\n      });\n    }\n  }; // Overload:function(selector<element>)\n  // Overload:function(selector<element,index>)\n\n\n  Enumerable.prototype.choose = function (selector) {\n    selector = Utils.createLambda(selector);\n    var source = this;\n    return new Enumerable(function () {\n      var enumerator;\n      var index = 0;\n      return new IEnumerator(function () {\n        enumerator = source.getEnumerator();\n      }, function () {\n        while (enumerator.moveNext()) {\n          var result = selector(enumerator.current(), index++);\n\n          if (result != null) {\n            return this.yieldReturn(result);\n          }\n        }\n\n        return this.yieldBreak();\n      }, function () {\n        Utils.dispose(enumerator);\n      });\n    });\n  };\n\n  Enumerable.prototype.ofType = function (type) {\n    var typeName;\n\n    switch (type) {\n      case Number:\n        typeName = Types.Number;\n        break;\n\n      case String:\n        typeName = Types.String;\n        break;\n\n      case Boolean:\n        typeName = Types.Boolean;\n        break;\n\n      case Function:\n        typeName = Types.Function;\n        break;\n\n      default:\n        typeName = null;\n        break;\n    }\n\n    return typeName === null ? this.where(function (x) {\n      return x instanceof type;\n    }) : this.where(function (x) {\n      return typeof x === typeName;\n    });\n  }; // mutiple arguments, last one is selector, others are enumerable\n\n\n  Enumerable.prototype.zip = function () {\n    var args = arguments;\n    var selector = Utils.createLambda(arguments[arguments.length - 1]);\n    var source = this; // optimized case:argument is 2\n\n    if (arguments.length == 2) {\n      var second = arguments[0];\n      return new Enumerable(function () {\n        var firstEnumerator;\n        var secondEnumerator;\n        var index = 0;\n        return new IEnumerator(function () {\n          firstEnumerator = source.getEnumerator();\n          secondEnumerator = Enumerable.from(second).getEnumerator();\n        }, function () {\n          if (firstEnumerator.moveNext() && secondEnumerator.moveNext()) {\n            return this.yieldReturn(selector(firstEnumerator.current(), secondEnumerator.current(), index++));\n          }\n\n          return false;\n        }, function () {\n          try {\n            Utils.dispose(firstEnumerator);\n          } finally {\n            Utils.dispose(secondEnumerator);\n          }\n        });\n      });\n    } else {\n      return new Enumerable(function () {\n        var enumerators;\n        var index = 0;\n        return new IEnumerator(function () {\n          var array = Enumerable.make(source).concat(Enumerable.from(args).takeExceptLast().select(Enumerable.from)).select(function (x) {\n            return x.getEnumerator();\n          }).toArray();\n          enumerators = Enumerable.from(array);\n        }, function () {\n          if (enumerators.all(function (x) {\n            return x.moveNext();\n          })) {\n            var array = enumerators.select(function (x) {\n              return x.current();\n            }).toArray();\n            array.push(index++);\n            return this.yieldReturn(selector.apply(null, array));\n          } else {\n            return this.yieldBreak();\n          }\n        }, function () {\n          Enumerable.from(enumerators).forEach(Utils.dispose);\n        });\n      });\n    }\n  }; // mutiple arguments\n\n\n  Enumerable.prototype.merge = function () {\n    var args = arguments;\n    var source = this;\n    return new Enumerable(function () {\n      var enumerators;\n      var index = -1;\n      return new IEnumerator(function () {\n        enumerators = Enumerable.make(source).concat(Enumerable.from(args).select(Enumerable.from)).select(function (x) {\n          return x.getEnumerator();\n        }).toArray();\n      }, function () {\n        while (enumerators.length > 0) {\n          index = index >= enumerators.length - 1 ? 0 : index + 1;\n          var enumerator = enumerators[index];\n\n          if (enumerator.moveNext()) {\n            return this.yieldReturn(enumerator.current());\n          } else {\n            enumerator.dispose();\n            enumerators.splice(index--, 1);\n          }\n        }\n\n        return this.yieldBreak();\n      }, function () {\n        Enumerable.from(enumerators).forEach(Utils.dispose);\n      });\n    });\n  };\n  /* Join Methods */\n  // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector)\n  // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector)\n\n\n  Enumerable.prototype.join = function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector) {\n    outerKeySelector = Utils.createLambda(outerKeySelector);\n    innerKeySelector = Utils.createLambda(innerKeySelector);\n    resultSelector = Utils.createLambda(resultSelector);\n    compareSelector = Utils.createLambda(compareSelector);\n    var source = this;\n    return new Enumerable(function () {\n      var outerEnumerator;\n      var lookup;\n      var innerElements = null;\n      var innerCount = 0;\n      return new IEnumerator(function () {\n        outerEnumerator = source.getEnumerator();\n        lookup = Enumerable.from(inner).toLookup(innerKeySelector, Functions.Identity, compareSelector);\n      }, function () {\n        while (true) {\n          if (innerElements != null) {\n            var innerElement = innerElements[innerCount++];\n\n            if (innerElement !== undefined) {\n              return this.yieldReturn(resultSelector(outerEnumerator.current(), innerElement));\n            }\n\n            innerElement = null;\n            innerCount = 0;\n          }\n\n          if (outerEnumerator.moveNext()) {\n            var key = outerKeySelector(outerEnumerator.current());\n            innerElements = lookup.get(key).toArray();\n          } else {\n            return false;\n          }\n        }\n      }, function () {\n        Utils.dispose(outerEnumerator);\n      });\n    });\n  }; // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector)\n  // Overload:function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector)\n\n\n  Enumerable.prototype.groupJoin = function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector) {\n    outerKeySelector = Utils.createLambda(outerKeySelector);\n    innerKeySelector = Utils.createLambda(innerKeySelector);\n    resultSelector = Utils.createLambda(resultSelector);\n    compareSelector = Utils.createLambda(compareSelector);\n    var source = this;\n    return new Enumerable(function () {\n      var enumerator = source.getEnumerator();\n      var lookup = null;\n      return new IEnumerator(function () {\n        enumerator = source.getEnumerator();\n        lookup = Enumerable.from(inner).toLookup(innerKeySelector, Functions.Identity, compareSelector);\n      }, function () {\n        if (enumerator.moveNext()) {\n          var innerElement = lookup.get(outerKeySelector(enumerator.current()));\n          return this.yieldReturn(resultSelector(enumerator.current(), innerElement));\n        }\n\n        return false;\n      }, function () {\n        Utils.dispose(enumerator);\n      });\n    });\n  };\n  /* Set Methods */\n\n\n  Enumerable.prototype.all = function (predicate) {\n    predicate = Utils.createLambda(predicate);\n    var result = true;\n    this.forEach(function (x) {\n      if (!predicate(x)) {\n        result = false;\n        return false; // break\n      }\n    });\n    return result;\n  }; // Overload:function()\n  // Overload:function(predicate)\n\n\n  Enumerable.prototype.any = function (predicate) {\n    predicate = Utils.createLambda(predicate);\n    var enumerator = this.getEnumerator();\n\n    try {\n      if (arguments.length == 0) return enumerator.moveNext(); // case:function()\n\n      while (enumerator.moveNext()) // case:function(predicate)\n      {\n        if (predicate(enumerator.current())) return true;\n      }\n\n      return false;\n    } finally {\n      Utils.dispose(enumerator);\n    }\n  };\n\n  Enumerable.prototype.isEmpty = function () {\n    return !this.any();\n  }; // multiple arguments\n\n\n  Enumerable.prototype.concat = function () {\n    var source = this;\n\n    if (arguments.length == 1) {\n      var second = arguments[0];\n      return new Enumerable(function () {\n        var firstEnumerator;\n        var secondEnumerator;\n        return new IEnumerator(function () {\n          firstEnumerator = source.getEnumerator();\n        }, function () {\n          if (secondEnumerator == null) {\n            if (firstEnumerator.moveNext()) return this.yieldReturn(firstEnumerator.current());\n            secondEnumerator = Enumerable.from(second).getEnumerator();\n          }\n\n          if (secondEnumerator.moveNext()) return this.yieldReturn(secondEnumerator.current());\n          return false;\n        }, function () {\n          try {\n            Utils.dispose(firstEnumerator);\n          } finally {\n            Utils.dispose(secondEnumerator);\n          }\n        });\n      });\n    } else {\n      var args = arguments;\n      return new Enumerable(function () {\n        var enumerators;\n        return new IEnumerator(function () {\n          enumerators = Enumerable.make(source).concat(Enumerable.from(args).select(Enumerable.from)).select(function (x) {\n            return x.getEnumerator();\n          }).toArray();\n        }, function () {\n          while (enumerators.length > 0) {\n            var enumerator = enumerators[0];\n\n            if (enumerator.moveNext()) {\n              return this.yieldReturn(enumerator.current());\n            } else {\n              enumerator.dispose();\n              enumerators.splice(0, 1);\n            }\n          }\n\n          return this.yieldBreak();\n        }, function () {\n          Enumerable.from(enumerators).forEach(Utils.dispose);\n        });\n      });\n    }\n  };\n\n  Enumerable.prototype.insert = function (index, second) {\n    var source = this;\n    return new Enumerable(function () {\n      var firstEnumerator;\n      var secondEnumerator;\n      var count = 0;\n      var isEnumerated = false;\n      return new IEnumerator(function () {\n        firstEnumerator = source.getEnumerator();\n        secondEnumerator = Enumerable.from(second).getEnumerator();\n      }, function () {\n        if (count == index && secondEnumerator.moveNext()) {\n          isEnumerated = true;\n          return this.yieldReturn(secondEnumerator.current());\n        }\n\n        if (firstEnumerator.moveNext()) {\n          count++;\n          return this.yieldReturn(firstEnumerator.current());\n        }\n\n        if (!isEnumerated && secondEnumerator.moveNext()) {\n          return this.yieldReturn(secondEnumerator.current());\n        }\n\n        return false;\n      }, function () {\n        try {\n          Utils.dispose(firstEnumerator);\n        } finally {\n          Utils.dispose(secondEnumerator);\n        }\n      });\n    });\n  };\n\n  Enumerable.prototype.alternate = function (alternateValueOrSequence) {\n    var source = this;\n    return new Enumerable(function () {\n      var buffer;\n      var enumerator;\n      var alternateSequence;\n      var alternateEnumerator;\n      return new IEnumerator(function () {\n        if (alternateValueOrSequence instanceof Array || alternateValueOrSequence.getEnumerator != null) {\n          alternateSequence = Enumerable.from(Enumerable.from(alternateValueOrSequence).toArray()); // freeze\n        } else {\n          alternateSequence = Enumerable.make(alternateValueOrSequence);\n        }\n\n        enumerator = source.getEnumerator();\n        if (enumerator.moveNext()) buffer = enumerator.current();\n      }, function () {\n        while (true) {\n          if (alternateEnumerator != null) {\n            if (alternateEnumerator.moveNext()) {\n              return this.yieldReturn(alternateEnumerator.current());\n            } else {\n              alternateEnumerator = null;\n            }\n          }\n\n          if (buffer == null && enumerator.moveNext()) {\n            buffer = enumerator.current(); // hasNext\n\n            alternateEnumerator = alternateSequence.getEnumerator();\n            continue; // GOTO\n          } else if (buffer != null) {\n            var retVal = buffer;\n            buffer = null;\n            return this.yieldReturn(retVal);\n          }\n\n          return this.yieldBreak();\n        }\n      }, function () {\n        try {\n          Utils.dispose(enumerator);\n        } finally {\n          Utils.dispose(alternateEnumerator);\n        }\n      });\n    });\n  }; // Overload:function(value)\n  // Overload:function(value, compareSelector)\n\n\n  Enumerable.prototype.contains = function (value, compareSelector) {\n    compareSelector = Utils.createLambda(compareSelector);\n    var enumerator = this.getEnumerator();\n\n    try {\n      while (enumerator.moveNext()) {\n        if (compareSelector(enumerator.current()) === value) return true;\n      }\n\n      return false;\n    } finally {\n      Utils.dispose(enumerator);\n    }\n  };\n\n  Enumerable.prototype.defaultIfEmpty = function (defaultValue) {\n    var source = this;\n    if (defaultValue === undefined) defaultValue = null;\n    return new Enumerable(function () {\n      var enumerator;\n      var isFirst = true;\n      return new IEnumerator(function () {\n        enumerator = source.getEnumerator();\n      }, function () {\n        if (enumerator.moveNext()) {\n          isFirst = false;\n          return this.yieldReturn(enumerator.current());\n        } else if (isFirst) {\n          isFirst = false;\n          return this.yieldReturn(defaultValue);\n        }\n\n        return false;\n      }, function () {\n        Utils.dispose(enumerator);\n      });\n    });\n  }; // Overload:function()\n  // Overload:function(compareSelector)\n\n\n  Enumerable.prototype.distinct = function (compareSelector) {\n    return this.except(Enumerable.empty(), compareSelector);\n  };\n\n  Enumerable.prototype.distinctUntilChanged = function (compareSelector) {\n    compareSelector = Utils.createLambda(compareSelector);\n    var source = this;\n    return new Enumerable(function () {\n      var enumerator;\n      var compareKey;\n      var initial;\n      return new IEnumerator(function () {\n        enumerator = source.getEnumerator();\n      }, function () {\n        while (enumerator.moveNext()) {\n          var key = compareSelector(enumerator.current());\n\n          if (initial) {\n            initial = false;\n            compareKey = key;\n            return this.yieldReturn(enumerator.current());\n          }\n\n          if (compareKey === key) {\n            continue;\n          }\n\n          compareKey = key;\n          return this.yieldReturn(enumerator.current());\n        }\n\n        return this.yieldBreak();\n      }, function () {\n        Utils.dispose(enumerator);\n      });\n    });\n  }; // Overload:function(second)\n  // Overload:function(second, compareSelector)\n\n\n  Enumerable.prototype.except = function (second, compareSelector) {\n    compareSelector = Utils.createLambda(compareSelector);\n    var source = this;\n    return new Enumerable(function () {\n      var enumerator;\n      var keys;\n      return new IEnumerator(function () {\n        enumerator = source.getEnumerator();\n        keys = new Dictionary(compareSelector);\n        Enumerable.from(second).forEach(function (key) {\n          keys.add(key);\n        });\n      }, function () {\n        while (enumerator.moveNext()) {\n          var current = enumerator.current();\n\n          if (!keys.contains(current)) {\n            keys.add(current);\n            return this.yieldReturn(current);\n          }\n        }\n\n        return false;\n      }, function () {\n        Utils.dispose(enumerator);\n      });\n    });\n  }; // Overload:function(second)\n  // Overload:function(second, compareSelector)\n\n\n  Enumerable.prototype.intersect = function (second, compareSelector) {\n    compareSelector = Utils.createLambda(compareSelector);\n    var source = this;\n    return new Enumerable(function () {\n      var enumerator;\n      var keys;\n      var outs;\n      return new IEnumerator(function () {\n        enumerator = source.getEnumerator();\n        keys = new Dictionary(compareSelector);\n        Enumerable.from(second).forEach(function (key) {\n          keys.add(key);\n        });\n        outs = new Dictionary(compareSelector);\n      }, function () {\n        while (enumerator.moveNext()) {\n          var current = enumerator.current();\n\n          if (!outs.contains(current) && keys.contains(current)) {\n            outs.add(current);\n            return this.yieldReturn(current);\n          }\n        }\n\n        return false;\n      }, function () {\n        Utils.dispose(enumerator);\n      });\n    });\n  }; // Overload:function(second)\n  // Overload:function(second, compareSelector)\n\n\n  Enumerable.prototype.sequenceEqual = function (second, compareSelector) {\n    compareSelector = Utils.createLambda(compareSelector);\n    var firstEnumerator = this.getEnumerator();\n\n    try {\n      var secondEnumerator = Enumerable.from(second).getEnumerator();\n\n      try {\n        while (firstEnumerator.moveNext()) {\n          if (!secondEnumerator.moveNext() || compareSelector(firstEnumerator.current()) !== compareSelector(secondEnumerator.current())) {\n            return false;\n          }\n        }\n\n        if (secondEnumerator.moveNext()) return false;\n        return true;\n      } finally {\n        Utils.dispose(secondEnumerator);\n      }\n    } finally {\n      Utils.dispose(firstEnumerator);\n    }\n  };\n\n  Enumerable.prototype.union = function (second, compareSelector) {\n    compareSelector = Utils.createLambda(compareSelector);\n    var source = this;\n    return new Enumerable(function () {\n      var firstEnumerator;\n      var secondEnumerator;\n      var keys;\n      return new IEnumerator(function () {\n        firstEnumerator = source.getEnumerator();\n        keys = new Dictionary(compareSelector);\n      }, function () {\n        var current;\n\n        if (secondEnumerator === undefined) {\n          while (firstEnumerator.moveNext()) {\n            current = firstEnumerator.current();\n\n            if (!keys.contains(current)) {\n              keys.add(current);\n              return this.yieldReturn(current);\n            }\n          }\n\n          secondEnumerator = Enumerable.from(second).getEnumerator();\n        }\n\n        while (secondEnumerator.moveNext()) {\n          current = secondEnumerator.current();\n\n          if (!keys.contains(current)) {\n            keys.add(current);\n            return this.yieldReturn(current);\n          }\n        }\n\n        return false;\n      }, function () {\n        try {\n          Utils.dispose(firstEnumerator);\n        } finally {\n          Utils.dispose(secondEnumerator);\n        }\n      });\n    });\n  };\n  /* Ordering Methods */\n\n\n  Enumerable.prototype.orderBy = function (keySelector) {\n    return new OrderedEnumerable(this, keySelector, false);\n  };\n\n  Enumerable.prototype.orderByDescending = function (keySelector) {\n    return new OrderedEnumerable(this, keySelector, true);\n  };\n\n  Enumerable.prototype.reverse = function () {\n    var source = this;\n    return new Enumerable(function () {\n      var buffer;\n      var index;\n      return new IEnumerator(function () {\n        buffer = source.toArray();\n        index = buffer.length;\n      }, function () {\n        return index > 0 ? this.yieldReturn(buffer[--index]) : false;\n      }, Functions.Blank);\n    });\n  };\n\n  Enumerable.prototype.shuffle = function () {\n    var source = this;\n    return new Enumerable(function () {\n      var buffer;\n      return new IEnumerator(function () {\n        buffer = source.toArray();\n      }, function () {\n        if (buffer.length > 0) {\n          var i = Math.floor(Math.random() * buffer.length);\n          return this.yieldReturn(buffer.splice(i, 1)[0]);\n        }\n\n        return false;\n      }, Functions.Blank);\n    });\n  };\n\n  Enumerable.prototype.weightedSample = function (weightSelector) {\n    weightSelector = Utils.createLambda(weightSelector);\n    var source = this;\n    return new Enumerable(function () {\n      var sortedByBound;\n      var totalWeight = 0;\n      return new IEnumerator(function () {\n        sortedByBound = source.choose(function (x) {\n          var weight = weightSelector(x);\n          if (weight <= 0) return null; // ignore 0\n\n          totalWeight += weight;\n          return {\n            value: x,\n            bound: totalWeight\n          };\n        }).toArray();\n      }, function () {\n        if (sortedByBound.length > 0) {\n          var draw = Math.floor(Math.random() * totalWeight) + 1;\n          var lower = -1;\n          var upper = sortedByBound.length;\n\n          while (upper - lower > 1) {\n            var index = Math.floor((lower + upper) / 2);\n\n            if (sortedByBound[index].bound >= draw) {\n              upper = index;\n            } else {\n              lower = index;\n            }\n          }\n\n          return this.yieldReturn(sortedByBound[upper].value);\n        }\n\n        return this.yieldBreak();\n      }, Functions.Blank);\n    });\n  };\n  /* Grouping Methods */\n  // Overload:function(keySelector)\n  // Overload:function(keySelector,elementSelector)\n  // Overload:function(keySelector,elementSelector,resultSelector)\n  // Overload:function(keySelector,elementSelector,resultSelector,compareSelector)\n\n\n  Enumerable.prototype.groupBy = function (keySelector, elementSelector, resultSelector, compareSelector) {\n    var source = this;\n    keySelector = Utils.createLambda(keySelector);\n    elementSelector = Utils.createLambda(elementSelector);\n    if (resultSelector != null) resultSelector = Utils.createLambda(resultSelector);\n    compareSelector = Utils.createLambda(compareSelector);\n    return new Enumerable(function () {\n      var enumerator;\n      return new IEnumerator(function () {\n        enumerator = source.toLookup(keySelector, elementSelector, compareSelector).toEnumerable().getEnumerator();\n      }, function () {\n        while (enumerator.moveNext()) {\n          return resultSelector == null ? this.yieldReturn(enumerator.current()) : this.yieldReturn(resultSelector(enumerator.current().key(), enumerator.current()));\n        }\n\n        return false;\n      }, function () {\n        Utils.dispose(enumerator);\n      });\n    });\n  }; // Overload:function(keySelector)\n  // Overload:function(keySelector,elementSelector)\n  // Overload:function(keySelector,elementSelector,resultSelector)\n  // Overload:function(keySelector,elementSelector,resultSelector,compareSelector)\n\n\n  Enumerable.prototype.partitionBy = function (keySelector, elementSelector, resultSelector, compareSelector) {\n    var source = this;\n    keySelector = Utils.createLambda(keySelector);\n    elementSelector = Utils.createLambda(elementSelector);\n    compareSelector = Utils.createLambda(compareSelector);\n    var hasResultSelector;\n\n    if (resultSelector == null) {\n      hasResultSelector = false;\n\n      resultSelector = function (key, group) {\n        return new Grouping(key, group);\n      };\n    } else {\n      hasResultSelector = true;\n      resultSelector = Utils.createLambda(resultSelector);\n    }\n\n    return new Enumerable(function () {\n      var enumerator;\n      var key;\n      var compareKey;\n      var group = [];\n      return new IEnumerator(function () {\n        enumerator = source.getEnumerator();\n\n        if (enumerator.moveNext()) {\n          key = keySelector(enumerator.current());\n          compareKey = compareSelector(key);\n          group.push(elementSelector(enumerator.current()));\n        }\n      }, function () {\n        var hasNext;\n\n        while ((hasNext = enumerator.moveNext()) == true) {\n          if (compareKey === compareSelector(keySelector(enumerator.current()))) {\n            group.push(elementSelector(enumerator.current()));\n          } else break;\n        }\n\n        if (group.length > 0) {\n          var result = hasResultSelector ? resultSelector(key, Enumerable.from(group)) : resultSelector(key, group);\n\n          if (hasNext) {\n            key = keySelector(enumerator.current());\n            compareKey = compareSelector(key);\n            group = [elementSelector(enumerator.current())];\n          } else group = [];\n\n          return this.yieldReturn(result);\n        }\n\n        return false;\n      }, function () {\n        Utils.dispose(enumerator);\n      });\n    });\n  };\n\n  Enumerable.prototype.buffer = function (count) {\n    var source = this;\n    return new Enumerable(function () {\n      var enumerator;\n      return new IEnumerator(function () {\n        enumerator = source.getEnumerator();\n      }, function () {\n        var array = [];\n        var index = 0;\n\n        while (enumerator.moveNext()) {\n          array.push(enumerator.current());\n          if (++index >= count) return this.yieldReturn(array);\n        }\n\n        if (array.length > 0) return this.yieldReturn(array);\n        return false;\n      }, function () {\n        Utils.dispose(enumerator);\n      });\n    });\n  };\n  /* Aggregate Methods */\n  // Overload:function(func)\n  // Overload:function(seed,func)\n  // Overload:function(seed,func,resultSelector)\n\n\n  Enumerable.prototype.aggregate = function (seed, func, resultSelector) {\n    resultSelector = Utils.createLambda(resultSelector);\n    return resultSelector(this.scan(seed, func, resultSelector).last());\n  }; // Overload:function()\n  // Overload:function(selector)\n\n\n  Enumerable.prototype.average = function (selector) {\n    selector = Utils.createLambda(selector);\n    var sum = 0;\n    var count = 0;\n    this.forEach(function (x) {\n      sum += selector(x);\n      ++count;\n    });\n    return sum / count;\n  }; // Overload:function()\n  // Overload:function(predicate)\n\n\n  Enumerable.prototype.count = function (predicate) {\n    predicate = predicate == null ? Functions.True : Utils.createLambda(predicate);\n    var count = 0;\n    this.forEach(function (x, i) {\n      if (predicate(x, i)) ++count;\n    });\n    return count;\n  }; // Overload:function()\n  // Overload:function(selector)\n\n\n  Enumerable.prototype.max = function (selector) {\n    if (selector == null) selector = Functions.Identity;\n    return this.select(selector).aggregate(function (a, b) {\n      return a > b ? a : b;\n    });\n  }; // Overload:function()\n  // Overload:function(selector)\n\n\n  Enumerable.prototype.min = function (selector) {\n    if (selector == null) selector = Functions.Identity;\n    return this.select(selector).aggregate(function (a, b) {\n      return a < b ? a : b;\n    });\n  };\n\n  Enumerable.prototype.maxBy = function (keySelector) {\n    keySelector = Utils.createLambda(keySelector);\n    return this.aggregate(function (a, b) {\n      return keySelector(a) > keySelector(b) ? a : b;\n    });\n  };\n\n  Enumerable.prototype.minBy = function (keySelector) {\n    keySelector = Utils.createLambda(keySelector);\n    return this.aggregate(function (a, b) {\n      return keySelector(a) < keySelector(b) ? a : b;\n    });\n  }; // Overload:function()\n  // Overload:function(selector)\n\n\n  Enumerable.prototype.sum = function (selector) {\n    if (selector == null) selector = Functions.Identity;\n    return this.select(selector).aggregate(0, function (a, b) {\n      return a + b;\n    });\n  };\n  /* Paging Methods */\n\n\n  Enumerable.prototype.elementAt = function (index) {\n    var value;\n    var found = false;\n    this.forEach(function (x, i) {\n      if (i == index) {\n        value = x;\n        found = true;\n        return false;\n      }\n    });\n    if (!found) throw new Error(\"index is less than 0 or greater than or equal to the number of elements in source.\");\n    return value;\n  };\n\n  Enumerable.prototype.elementAtOrDefault = function (index, defaultValue) {\n    if (defaultValue === undefined) defaultValue = null;\n    var value;\n    var found = false;\n    this.forEach(function (x, i) {\n      if (i == index) {\n        value = x;\n        found = true;\n        return false;\n      }\n    });\n    return !found ? defaultValue : value;\n  }; // Overload:function()\n  // Overload:function(predicate)\n\n\n  Enumerable.prototype.first = function (predicate) {\n    if (predicate != null) return this.where(predicate).first();\n    var value;\n    var found = false;\n    this.forEach(function (x) {\n      value = x;\n      found = true;\n      return false;\n    });\n    if (!found) throw new Error(\"first:No element satisfies the condition.\");\n    return value;\n  };\n\n  Enumerable.prototype.firstOrDefault = function (predicate, defaultValue) {\n    if (predicate !== undefined) {\n      if (typeof predicate === Types.Function || typeof Utils.createLambda(predicate) === Types.Function) {\n        return this.where(predicate).firstOrDefault(undefined, defaultValue);\n      }\n\n      defaultValue = predicate;\n    }\n\n    var value;\n    var found = false;\n    this.forEach(function (x) {\n      value = x;\n      found = true;\n      return false;\n    });\n    return !found ? defaultValue : value;\n  }; // Overload:function()\n  // Overload:function(predicate)\n\n\n  Enumerable.prototype.last = function (predicate) {\n    if (predicate != null) return this.where(predicate).last();\n    var value;\n    var found = false;\n    this.forEach(function (x) {\n      found = true;\n      value = x;\n    });\n    if (!found) throw new Error(\"last:No element satisfies the condition.\");\n    return value;\n  };\n\n  Enumerable.prototype.lastOrDefault = function (predicate, defaultValue) {\n    if (predicate !== undefined) {\n      if (typeof predicate === Types.Function || typeof Utils.createLambda(predicate) === Types.Function) {\n        return this.where(predicate).lastOrDefault(undefined, defaultValue);\n      }\n\n      defaultValue = predicate;\n    }\n\n    var value;\n    var found = false;\n    this.forEach(function (x) {\n      found = true;\n      value = x;\n    });\n    return !found ? defaultValue : value;\n  }; // Overload:function()\n  // Overload:function(predicate)\n\n\n  Enumerable.prototype.single = function (predicate) {\n    if (predicate != null) return this.where(predicate).single();\n    var value;\n    var found = false;\n    this.forEach(function (x) {\n      if (!found) {\n        found = true;\n        value = x;\n      } else throw new Error(\"single:sequence contains more than one element.\");\n    });\n    if (!found) throw new Error(\"single:No element satisfies the condition.\");\n    return value;\n  }; // Overload:function(defaultValue)\n  // Overload:function(defaultValue,predicate)\n\n\n  Enumerable.prototype.singleOrDefault = function (predicate, defaultValue) {\n    if (defaultValue === undefined) defaultValue = null;\n    if (predicate != null) return this.where(predicate).singleOrDefault(null, defaultValue);\n    var value;\n    var found = false;\n    this.forEach(function (x) {\n      if (!found) {\n        found = true;\n        value = x;\n      } else throw new Error(\"single:sequence contains more than one element.\");\n    });\n    return !found ? defaultValue : value;\n  };\n\n  Enumerable.prototype.skip = function (count) {\n    var source = this;\n    return new Enumerable(function () {\n      var enumerator;\n      var index = 0;\n      return new IEnumerator(function () {\n        enumerator = source.getEnumerator();\n\n        while (index++ < count && enumerator.moveNext()) {}\n\n        ;\n      }, function () {\n        return enumerator.moveNext() ? this.yieldReturn(enumerator.current()) : false;\n      }, function () {\n        Utils.dispose(enumerator);\n      });\n    });\n  }; // Overload:function(predicate<element>)\n  // Overload:function(predicate<element,index>)\n\n\n  Enumerable.prototype.skipWhile = function (predicate) {\n    predicate = Utils.createLambda(predicate);\n    var source = this;\n    return new Enumerable(function () {\n      var enumerator;\n      var index = 0;\n      var isSkipEnd = false;\n      return new IEnumerator(function () {\n        enumerator = source.getEnumerator();\n      }, function () {\n        while (!isSkipEnd) {\n          if (enumerator.moveNext()) {\n            if (!predicate(enumerator.current(), index++)) {\n              isSkipEnd = true;\n              return this.yieldReturn(enumerator.current());\n            }\n\n            continue;\n          } else return false;\n        }\n\n        return enumerator.moveNext() ? this.yieldReturn(enumerator.current()) : false;\n      }, function () {\n        Utils.dispose(enumerator);\n      });\n    });\n  };\n\n  Enumerable.prototype.take = function (count) {\n    var source = this;\n    return new Enumerable(function () {\n      var enumerator;\n      var index = 0;\n      return new IEnumerator(function () {\n        enumerator = source.getEnumerator();\n      }, function () {\n        return index++ < count && enumerator.moveNext() ? this.yieldReturn(enumerator.current()) : false;\n      }, function () {\n        Utils.dispose(enumerator);\n      });\n    });\n  }; // Overload:function(predicate<element>)\n  // Overload:function(predicate<element,index>)\n\n\n  Enumerable.prototype.takeWhile = function (predicate) {\n    predicate = Utils.createLambda(predicate);\n    var source = this;\n    return new Enumerable(function () {\n      var enumerator;\n      var index = 0;\n      return new IEnumerator(function () {\n        enumerator = source.getEnumerator();\n      }, function () {\n        return enumerator.moveNext() && predicate(enumerator.current(), index++) ? this.yieldReturn(enumerator.current()) : false;\n      }, function () {\n        Utils.dispose(enumerator);\n      });\n    });\n  }; // Overload:function()\n  // Overload:function(count)\n\n\n  Enumerable.prototype.takeExceptLast = function (count) {\n    if (count == null) count = 1;\n    var source = this;\n    return new Enumerable(function () {\n      if (count <= 0) return source.getEnumerator(); // do nothing\n\n      var enumerator;\n      var q = [];\n      return new IEnumerator(function () {\n        enumerator = source.getEnumerator();\n      }, function () {\n        while (enumerator.moveNext()) {\n          if (q.length == count) {\n            q.push(enumerator.current());\n            return this.yieldReturn(q.shift());\n          }\n\n          q.push(enumerator.current());\n        }\n\n        return false;\n      }, function () {\n        Utils.dispose(enumerator);\n      });\n    });\n  };\n\n  Enumerable.prototype.takeFromLast = function (count) {\n    if (count <= 0 || count == null) return Enumerable.empty();\n    var source = this;\n    return new Enumerable(function () {\n      var sourceEnumerator;\n      var enumerator;\n      var q = [];\n      return new IEnumerator(function () {\n        sourceEnumerator = source.getEnumerator();\n      }, function () {\n        while (sourceEnumerator.moveNext()) {\n          if (q.length == count) q.shift();\n          q.push(sourceEnumerator.current());\n        }\n\n        if (enumerator == null) {\n          enumerator = Enumerable.from(q).getEnumerator();\n        }\n\n        return enumerator.moveNext() ? this.yieldReturn(enumerator.current()) : false;\n      }, function () {\n        Utils.dispose(enumerator);\n      });\n    });\n  }; // Overload:function(item)\n  // Overload:function(predicate)\n\n\n  Enumerable.prototype.indexOf = function (item) {\n    var found = null; // item as predicate\n\n    if (typeof item === Types.Function) {\n      this.forEach(function (x, i) {\n        if (item(x, i)) {\n          found = i;\n          return false;\n        }\n      });\n    } else {\n      this.forEach(function (x, i) {\n        if (x === item) {\n          found = i;\n          return false;\n        }\n      });\n    }\n\n    return found !== null ? found : -1;\n  }; // Overload:function(item)\n  // Overload:function(predicate)\n\n\n  Enumerable.prototype.lastIndexOf = function (item) {\n    var result = -1; // item as predicate\n\n    if (typeof item === Types.Function) {\n      this.forEach(function (x, i) {\n        if (item(x, i)) result = i;\n      });\n    } else {\n      this.forEach(function (x, i) {\n        if (x === item) result = i;\n      });\n    }\n\n    return result;\n  };\n  /* Convert Methods */\n\n\n  Enumerable.prototype.cast = function () {\n    return this;\n  };\n\n  Enumerable.prototype.asEnumerable = function () {\n    return Enumerable.from(this);\n  };\n\n  Enumerable.prototype.toArray = function () {\n    var array = [];\n    this.forEach(function (x) {\n      array.push(x);\n    });\n    return array;\n  }; // Overload:function(keySelector)\n  // Overload:function(keySelector, elementSelector)\n  // Overload:function(keySelector, elementSelector, compareSelector)\n\n\n  Enumerable.prototype.toLookup = function (keySelector, elementSelector, compareSelector) {\n    keySelector = Utils.createLambda(keySelector);\n    elementSelector = Utils.createLambda(elementSelector);\n    compareSelector = Utils.createLambda(compareSelector);\n    var dict = new Dictionary(compareSelector);\n    this.forEach(function (x) {\n      var key = keySelector(x);\n      var element = elementSelector(x);\n      var array = dict.get(key);\n      if (array !== undefined) array.push(element);else dict.add(key, [element]);\n    });\n    return new Lookup(dict);\n  };\n\n  Enumerable.prototype.toObject = function (keySelector, elementSelector) {\n    keySelector = Utils.createLambda(keySelector);\n    elementSelector = Utils.createLambda(elementSelector);\n    var obj = {};\n    this.forEach(function (x) {\n      obj[keySelector(x)] = elementSelector(x);\n    });\n    return obj;\n  }; // Overload:function(keySelector, elementSelector)\n  // Overload:function(keySelector, elementSelector, compareSelector)\n\n\n  Enumerable.prototype.toDictionary = function (keySelector, elementSelector, compareSelector) {\n    keySelector = Utils.createLambda(keySelector);\n    elementSelector = Utils.createLambda(elementSelector);\n    compareSelector = Utils.createLambda(compareSelector);\n    var dict = new Dictionary(compareSelector);\n    this.forEach(function (x) {\n      dict.add(keySelector(x), elementSelector(x));\n    });\n    return dict;\n  }; // Overload:function()\n  // Overload:function(replacer)\n  // Overload:function(replacer, space)\n\n\n  Enumerable.prototype.toJSONString = function (replacer, space) {\n    if (typeof JSON === Types.Undefined || JSON.stringify == null) {\n      throw new Error(\"toJSONString can't find JSON.stringify. This works native JSON support Browser or include json2.js\");\n    }\n\n    return JSON.stringify(this.toArray(), replacer, space);\n  }; // Overload:function()\n  // Overload:function(separator)\n  // Overload:function(separator,selector)\n\n\n  Enumerable.prototype.toJoinedString = function (separator, selector) {\n    if (separator == null) separator = \"\";\n    if (selector == null) selector = Functions.Identity;\n    return this.select(selector).toArray().join(separator);\n  };\n  /* Action Methods */\n  // Overload:function(action<element>)\n  // Overload:function(action<element,index>)\n\n\n  Enumerable.prototype.doAction = function (action) {\n    var source = this;\n    action = Utils.createLambda(action);\n    return new Enumerable(function () {\n      var enumerator;\n      var index = 0;\n      return new IEnumerator(function () {\n        enumerator = source.getEnumerator();\n      }, function () {\n        if (enumerator.moveNext()) {\n          action(enumerator.current(), index++);\n          return this.yieldReturn(enumerator.current());\n        }\n\n        return false;\n      }, function () {\n        Utils.dispose(enumerator);\n      });\n    });\n  }; // Overload:function(action<element>)\n  // Overload:function(action<element,index>)\n  // Overload:function(func<element,bool>)\n  // Overload:function(func<element,index,bool>)\n\n\n  Enumerable.prototype.forEach = function (action) {\n    action = Utils.createLambda(action);\n    var index = 0;\n    var enumerator = this.getEnumerator();\n\n    try {\n      while (enumerator.moveNext()) {\n        if (action(enumerator.current(), index++) === false) break;\n      }\n    } finally {\n      Utils.dispose(enumerator);\n    }\n  }; // Overload:function()\n  // Overload:function(separator)\n  // Overload:function(separator,selector)\n\n\n  Enumerable.prototype.write = function (separator, selector) {\n    if (separator == null) separator = \"\";\n    selector = Utils.createLambda(selector);\n    var isFirst = true;\n    this.forEach(function (item) {\n      if (isFirst) isFirst = false;else document.write(separator);\n      document.write(selector(item));\n    });\n  }; // Overload:function()\n  // Overload:function(selector)\n\n\n  Enumerable.prototype.writeLine = function (selector) {\n    selector = Utils.createLambda(selector);\n    this.forEach(function (item) {\n      document.writeln(selector(item) + \"<br />\");\n    });\n  };\n\n  Enumerable.prototype.force = function () {\n    var enumerator = this.getEnumerator();\n\n    try {\n      while (enumerator.moveNext()) {}\n    } finally {\n      Utils.dispose(enumerator);\n    }\n  };\n  /* Functional Methods */\n\n\n  Enumerable.prototype.letBind = function (func) {\n    func = Utils.createLambda(func);\n    var source = this;\n    return new Enumerable(function () {\n      var enumerator;\n      return new IEnumerator(function () {\n        enumerator = Enumerable.from(func(source)).getEnumerator();\n      }, function () {\n        return enumerator.moveNext() ? this.yieldReturn(enumerator.current()) : false;\n      }, function () {\n        Utils.dispose(enumerator);\n      });\n    });\n  };\n\n  Enumerable.prototype.share = function () {\n    var source = this;\n    var sharedEnumerator;\n    var disposed = false;\n    return new DisposableEnumerable(function () {\n      return new IEnumerator(function () {\n        if (sharedEnumerator == null) {\n          sharedEnumerator = source.getEnumerator();\n        }\n      }, function () {\n        if (disposed) throw new Error(\"enumerator is disposed\");\n        return sharedEnumerator.moveNext() ? this.yieldReturn(sharedEnumerator.current()) : false;\n      }, Functions.Blank);\n    }, function () {\n      disposed = true;\n      Utils.dispose(sharedEnumerator);\n    });\n  };\n\n  Enumerable.prototype.memoize = function () {\n    var source = this;\n    var cache;\n    var enumerator;\n    var disposed = false;\n    return new DisposableEnumerable(function () {\n      var index = -1;\n      return new IEnumerator(function () {\n        if (enumerator == null) {\n          enumerator = source.getEnumerator();\n          cache = [];\n        }\n      }, function () {\n        if (disposed) throw new Error(\"enumerator is disposed\");\n        index++;\n\n        if (cache.length <= index) {\n          return enumerator.moveNext() ? this.yieldReturn(cache[index] = enumerator.current()) : false;\n        }\n\n        return this.yieldReturn(cache[index]);\n      }, Functions.Blank);\n    }, function () {\n      disposed = true;\n      Utils.dispose(enumerator);\n      cache = null;\n    });\n  };\n  /* Iterator (ES6 for..of) support */\n\n\n  if (Utils.hasNativeIteratorSupport()) {\n    Enumerable.prototype[Symbol.iterator] = function () {\n      return {\n        enumerator: this.getEnumerator(),\n        next: function () {\n          if (this.enumerator.moveNext()) {\n            return {\n              done: false,\n              value: this.enumerator.current()\n            };\n          } else {\n            return {\n              done: true\n            };\n          }\n        }\n      };\n    };\n  }\n  /* Error Handling Methods */\n\n\n  Enumerable.prototype.catchError = function (handler) {\n    handler = Utils.createLambda(handler);\n    var source = this;\n    return new Enumerable(function () {\n      var enumerator;\n      return new IEnumerator(function () {\n        enumerator = source.getEnumerator();\n      }, function () {\n        try {\n          return enumerator.moveNext() ? this.yieldReturn(enumerator.current()) : false;\n        } catch (e) {\n          handler(e);\n          return false;\n        }\n      }, function () {\n        Utils.dispose(enumerator);\n      });\n    });\n  };\n\n  Enumerable.prototype.finallyAction = function (finallyAction) {\n    finallyAction = Utils.createLambda(finallyAction);\n    var source = this;\n    return new Enumerable(function () {\n      var enumerator;\n      return new IEnumerator(function () {\n        enumerator = source.getEnumerator();\n      }, function () {\n        return enumerator.moveNext() ? this.yieldReturn(enumerator.current()) : false;\n      }, function () {\n        try {\n          Utils.dispose(enumerator);\n        } finally {\n          finallyAction();\n        }\n      });\n    });\n  };\n  /* For Debug Methods */\n  // Overload:function()\n  // Overload:function(selector)\n\n\n  Enumerable.prototype.log = function (selector) {\n    selector = Utils.createLambda(selector);\n    return this.doAction(function (item) {\n      if (typeof console !== Types.Undefined) {\n        console.log(selector(item));\n      }\n    });\n  }; // Overload:function()\n  // Overload:function(message)\n  // Overload:function(message,selector)\n\n\n  Enumerable.prototype.trace = function (message, selector) {\n    if (message == null) message = \"Trace\";\n    selector = Utils.createLambda(selector);\n    return this.doAction(function (item) {\n      if (typeof console !== Types.Undefined) {\n        console.log(message, selector(item));\n      }\n    });\n  }; // private\n\n\n  var OrderedEnumerable = function (source, keySelector, descending, parent) {\n    this.source = source;\n    this.keySelector = Utils.createLambda(keySelector);\n    this.descending = descending;\n    this.parent = parent;\n  };\n\n  OrderedEnumerable.prototype = new Enumerable();\n\n  OrderedEnumerable.prototype.createOrderedEnumerable = function (keySelector, descending) {\n    return new OrderedEnumerable(this.source, keySelector, descending, this);\n  };\n\n  OrderedEnumerable.prototype.thenBy = function (keySelector) {\n    return this.createOrderedEnumerable(keySelector, false);\n  };\n\n  OrderedEnumerable.prototype.thenByDescending = function (keySelector) {\n    return this.createOrderedEnumerable(keySelector, true);\n  };\n\n  OrderedEnumerable.prototype.getEnumerator = function () {\n    var self = this;\n    var buffer;\n    var indexes;\n    var index = 0;\n    return new IEnumerator(function () {\n      buffer = [];\n      indexes = [];\n      self.source.forEach(function (item, index) {\n        buffer.push(item);\n        indexes.push(index);\n      });\n      var sortContext = SortContext.create(self, null);\n      sortContext.GenerateKeys(buffer);\n      indexes.sort(function (a, b) {\n        return sortContext.compare(a, b);\n      });\n    }, function () {\n      return index < indexes.length ? this.yieldReturn(buffer[indexes[index++]]) : false;\n    }, Functions.Blank);\n  };\n\n  var SortContext = function (keySelector, descending, child) {\n    this.keySelector = keySelector;\n    this.descending = descending;\n    this.child = child;\n    this.keys = null;\n  };\n\n  SortContext.create = function (orderedEnumerable, currentContext) {\n    var context = new SortContext(orderedEnumerable.keySelector, orderedEnumerable.descending, currentContext);\n    if (orderedEnumerable.parent != null) return SortContext.create(orderedEnumerable.parent, context);\n    return context;\n  };\n\n  SortContext.prototype.GenerateKeys = function (source) {\n    var len = source.length;\n    var keySelector = this.keySelector;\n    var keys = new Array(len);\n\n    for (var i = 0; i < len; i++) keys[i] = keySelector(source[i]);\n\n    this.keys = keys;\n    if (this.child != null) this.child.GenerateKeys(source);\n  };\n\n  SortContext.prototype.compare = function (index1, index2) {\n    var comparison = Utils.compare(this.keys[index1], this.keys[index2]);\n\n    if (comparison == 0) {\n      if (this.child != null) return this.child.compare(index1, index2);\n      return Utils.compare(index1, index2);\n    }\n\n    return this.descending ? -comparison : comparison;\n  };\n\n  var DisposableEnumerable = function (getEnumerator, dispose) {\n    this.dispose = dispose;\n    Enumerable.call(this, getEnumerator);\n  };\n\n  DisposableEnumerable.prototype = new Enumerable(); // optimize array or arraylike object\n\n  var ArrayEnumerable = function (source) {\n    this.getSource = function () {\n      return source;\n    };\n  };\n\n  ArrayEnumerable.prototype = new Enumerable();\n\n  ArrayEnumerable.prototype.any = function (predicate) {\n    return predicate == null ? this.getSource().length > 0 : Enumerable.prototype.any.apply(this, arguments);\n  };\n\n  ArrayEnumerable.prototype.count = function (predicate) {\n    return predicate == null ? this.getSource().length : Enumerable.prototype.count.apply(this, arguments);\n  };\n\n  ArrayEnumerable.prototype.elementAt = function (index) {\n    var source = this.getSource();\n    return 0 <= index && index < source.length ? source[index] : Enumerable.prototype.elementAt.apply(this, arguments);\n  };\n\n  ArrayEnumerable.prototype.elementAtOrDefault = function (index, defaultValue) {\n    if (defaultValue === undefined) defaultValue = null;\n    var source = this.getSource();\n    return 0 <= index && index < source.length ? source[index] : defaultValue;\n  };\n\n  ArrayEnumerable.prototype.first = function (predicate) {\n    var source = this.getSource();\n    return predicate == null && source.length > 0 ? source[0] : Enumerable.prototype.first.apply(this, arguments);\n  };\n\n  ArrayEnumerable.prototype.firstOrDefault = function (predicate, defaultValue) {\n    if (predicate !== undefined) {\n      return Enumerable.prototype.firstOrDefault.apply(this, arguments);\n    }\n\n    defaultValue = predicate;\n    var source = this.getSource();\n    return source.length > 0 ? source[0] : defaultValue;\n  };\n\n  ArrayEnumerable.prototype.last = function (predicate) {\n    var source = this.getSource();\n    return predicate == null && source.length > 0 ? source[source.length - 1] : Enumerable.prototype.last.apply(this, arguments);\n  };\n\n  ArrayEnumerable.prototype.lastOrDefault = function (predicate, defaultValue) {\n    if (predicate !== undefined) {\n      return Enumerable.prototype.lastOrDefault.apply(this, arguments);\n    }\n\n    defaultValue = predicate;\n    var source = this.getSource();\n    return source.length > 0 ? source[source.length - 1] : defaultValue;\n  };\n\n  ArrayEnumerable.prototype.skip = function (count) {\n    var source = this.getSource();\n    return new Enumerable(function () {\n      var index;\n      return new IEnumerator(function () {\n        index = count < 0 ? 0 : count;\n      }, function () {\n        return index < source.length ? this.yieldReturn(source[index++]) : false;\n      }, Functions.Blank);\n    });\n  };\n\n  ArrayEnumerable.prototype.takeExceptLast = function (count) {\n    if (count == null) count = 1;\n    return this.take(this.getSource().length - count);\n  };\n\n  ArrayEnumerable.prototype.takeFromLast = function (count) {\n    return this.skip(this.getSource().length - count);\n  };\n\n  ArrayEnumerable.prototype.reverse = function () {\n    var source = this.getSource();\n    return new Enumerable(function () {\n      var index;\n      return new IEnumerator(function () {\n        index = source.length;\n      }, function () {\n        return index > 0 ? this.yieldReturn(source[--index]) : false;\n      }, Functions.Blank);\n    });\n  };\n\n  ArrayEnumerable.prototype.sequenceEqual = function (second, compareSelector) {\n    if ((second instanceof ArrayEnumerable || second instanceof Array) && compareSelector == null && Enumerable.from(second).count() != this.count()) {\n      return false;\n    }\n\n    return Enumerable.prototype.sequenceEqual.apply(this, arguments);\n  };\n\n  ArrayEnumerable.prototype.toJoinedString = function (separator, selector) {\n    var source = this.getSource();\n\n    if (selector != null || !(source instanceof Array)) {\n      return Enumerable.prototype.toJoinedString.apply(this, arguments);\n    }\n\n    if (separator == null) separator = \"\";\n    return source.join(separator);\n  };\n\n  ArrayEnumerable.prototype.getEnumerator = function () {\n    var source = this.getSource();\n    var index = -1; // fast and simple enumerator\n\n    return {\n      current: function () {\n        return source[index];\n      },\n      moveNext: function () {\n        return ++index < source.length;\n      },\n      dispose: Functions.Blank\n    };\n  }; // optimization for multiple where and multiple select and whereselect\n\n\n  var WhereEnumerable = function (source, predicate) {\n    this.prevSource = source;\n    this.prevPredicate = predicate; // predicate.length always <= 1\n  };\n\n  WhereEnumerable.prototype = new Enumerable();\n\n  WhereEnumerable.prototype.where = function (predicate) {\n    predicate = Utils.createLambda(predicate);\n\n    if (predicate.length <= 1) {\n      var prevPredicate = this.prevPredicate;\n\n      var composedPredicate = function (x) {\n        return prevPredicate(x) && predicate(x);\n      };\n\n      return new WhereEnumerable(this.prevSource, composedPredicate);\n    } else {\n      // if predicate use index, can't compose\n      return Enumerable.prototype.where.call(this, predicate);\n    }\n  };\n\n  WhereEnumerable.prototype.select = function (selector) {\n    selector = Utils.createLambda(selector);\n    return selector.length <= 1 ? new WhereSelectEnumerable(this.prevSource, this.prevPredicate, selector) : Enumerable.prototype.select.call(this, selector);\n  };\n\n  WhereEnumerable.prototype.getEnumerator = function () {\n    var predicate = this.prevPredicate;\n    var source = this.prevSource;\n    var enumerator;\n    return new IEnumerator(function () {\n      enumerator = source.getEnumerator();\n    }, function () {\n      while (enumerator.moveNext()) {\n        if (predicate(enumerator.current())) {\n          return this.yieldReturn(enumerator.current());\n        }\n      }\n\n      return false;\n    }, function () {\n      Utils.dispose(enumerator);\n    });\n  };\n\n  var WhereSelectEnumerable = function (source, predicate, selector) {\n    this.prevSource = source;\n    this.prevPredicate = predicate; // predicate.length always <= 1 or null\n\n    this.prevSelector = selector; // selector.length always <= 1\n  };\n\n  WhereSelectEnumerable.prototype = new Enumerable();\n\n  WhereSelectEnumerable.prototype.where = function (predicate) {\n    predicate = Utils.createLambda(predicate);\n    return predicate.length <= 1 ? new WhereEnumerable(this, predicate) : Enumerable.prototype.where.call(this, predicate);\n  };\n\n  WhereSelectEnumerable.prototype.select = function (selector) {\n    selector = Utils.createLambda(selector);\n\n    if (selector.length <= 1) {\n      var prevSelector = this.prevSelector;\n\n      var composedSelector = function (x) {\n        return selector(prevSelector(x));\n      };\n\n      return new WhereSelectEnumerable(this.prevSource, this.prevPredicate, composedSelector);\n    } else {\n      // if selector use index, can't compose\n      return Enumerable.prototype.select.call(this, selector);\n    }\n  };\n\n  WhereSelectEnumerable.prototype.getEnumerator = function () {\n    var predicate = this.prevPredicate;\n    var selector = this.prevSelector;\n    var source = this.prevSource;\n    var enumerator;\n    return new IEnumerator(function () {\n      enumerator = source.getEnumerator();\n    }, function () {\n      while (enumerator.moveNext()) {\n        if (predicate == null || predicate(enumerator.current())) {\n          return this.yieldReturn(selector(enumerator.current()));\n        }\n      }\n\n      return false;\n    }, function () {\n      Utils.dispose(enumerator);\n    });\n  }; // Collections\n\n\n  var Dictionary = function () {\n    // static utility methods\n    var callHasOwnProperty = function (target, key) {\n      return Object.prototype.hasOwnProperty.call(target, key);\n    };\n\n    var computeHashCode = function (obj) {\n      if (obj === null) return \"null\";\n      if (obj === undefined) return \"undefined\";\n      return typeof obj.toString === Types.Function ? obj.toString() : Object.prototype.toString.call(obj);\n    }; // LinkedList for Dictionary\n\n\n    var HashEntry = function (key, value) {\n      this.key = key;\n      this.value = value;\n      this.prev = null;\n      this.next = null;\n    };\n\n    var EntryList = function () {\n      this.first = null;\n      this.last = null;\n    };\n\n    EntryList.prototype = {\n      addLast: function (entry) {\n        if (this.last != null) {\n          this.last.next = entry;\n          entry.prev = this.last;\n          this.last = entry;\n        } else this.first = this.last = entry;\n      },\n      replace: function (entry, newEntry) {\n        if (entry.prev != null) {\n          entry.prev.next = newEntry;\n          newEntry.prev = entry.prev;\n        } else this.first = newEntry;\n\n        if (entry.next != null) {\n          entry.next.prev = newEntry;\n          newEntry.next = entry.next;\n        } else this.last = newEntry;\n      },\n      remove: function (entry) {\n        if (entry.prev != null) entry.prev.next = entry.next;else this.first = entry.next;\n        if (entry.next != null) entry.next.prev = entry.prev;else this.last = entry.prev;\n      }\n    }; // Overload:function()\n    // Overload:function(compareSelector)\n\n    var Dictionary = function (compareSelector) {\n      this.countField = 0;\n      this.entryList = new EntryList();\n      this.buckets = {}; // as Dictionary<string,List<object>>\n\n      this.compareSelector = compareSelector == null ? Functions.Identity : compareSelector;\n    };\n\n    Dictionary.prototype = {\n      add: function (key, value) {\n        var compareKey = this.compareSelector(key);\n        var hash = computeHashCode(compareKey);\n        var entry = new HashEntry(key, value);\n\n        if (callHasOwnProperty(this.buckets, hash)) {\n          var array = this.buckets[hash];\n\n          for (var i = 0; i < array.length; i++) {\n            if (this.compareSelector(array[i].key) === compareKey) {\n              this.entryList.replace(array[i], entry);\n              array[i] = entry;\n              return;\n            }\n          }\n\n          array.push(entry);\n        } else {\n          this.buckets[hash] = [entry];\n        }\n\n        this.countField++;\n        this.entryList.addLast(entry);\n      },\n      get: function (key) {\n        var compareKey = this.compareSelector(key);\n        var hash = computeHashCode(compareKey);\n        if (!callHasOwnProperty(this.buckets, hash)) return undefined;\n        var array = this.buckets[hash];\n\n        for (var i = 0; i < array.length; i++) {\n          var entry = array[i];\n          if (this.compareSelector(entry.key) === compareKey) return entry.value;\n        }\n\n        return undefined;\n      },\n      set: function (key, value) {\n        var compareKey = this.compareSelector(key);\n        var hash = computeHashCode(compareKey);\n\n        if (callHasOwnProperty(this.buckets, hash)) {\n          var array = this.buckets[hash];\n\n          for (var i = 0; i < array.length; i++) {\n            if (this.compareSelector(array[i].key) === compareKey) {\n              var newEntry = new HashEntry(key, value);\n              this.entryList.replace(array[i], newEntry);\n              array[i] = newEntry;\n              return true;\n            }\n          }\n        }\n\n        return false;\n      },\n      contains: function (key) {\n        var compareKey = this.compareSelector(key);\n        var hash = computeHashCode(compareKey);\n        if (!callHasOwnProperty(this.buckets, hash)) return false;\n        var array = this.buckets[hash];\n\n        for (var i = 0; i < array.length; i++) {\n          if (this.compareSelector(array[i].key) === compareKey) return true;\n        }\n\n        return false;\n      },\n      clear: function () {\n        this.countField = 0;\n        this.buckets = {};\n        this.entryList = new EntryList();\n      },\n      remove: function (key) {\n        var compareKey = this.compareSelector(key);\n        var hash = computeHashCode(compareKey);\n        if (!callHasOwnProperty(this.buckets, hash)) return;\n        var array = this.buckets[hash];\n\n        for (var i = 0; i < array.length; i++) {\n          if (this.compareSelector(array[i].key) === compareKey) {\n            this.entryList.remove(array[i]);\n            array.splice(i, 1);\n            if (array.length == 0) delete this.buckets[hash];\n            this.countField--;\n            return;\n          }\n        }\n      },\n      count: function () {\n        return this.countField;\n      },\n      toEnumerable: function () {\n        var self = this;\n        return new Enumerable(function () {\n          var currentEntry;\n          return new IEnumerator(function () {\n            currentEntry = self.entryList.first;\n          }, function () {\n            if (currentEntry != null) {\n              var result = {\n                key: currentEntry.key,\n                value: currentEntry.value\n              };\n              currentEntry = currentEntry.next;\n              return this.yieldReturn(result);\n            }\n\n            return false;\n          }, Functions.Blank);\n        });\n      }\n    };\n    return Dictionary;\n  }(); // dictionary = Dictionary<TKey, TValue[]>\n\n\n  var Lookup = function (dictionary) {\n    this.count = function () {\n      return dictionary.count();\n    };\n\n    this.get = function (key) {\n      return Enumerable.from(dictionary.get(key));\n    };\n\n    this.contains = function (key) {\n      return dictionary.contains(key);\n    };\n\n    this.toEnumerable = function () {\n      return dictionary.toEnumerable().select(function (kvp) {\n        return new Grouping(kvp.key, kvp.value);\n      });\n    };\n  };\n\n  var Grouping = function (groupKey, elements) {\n    this.key = function () {\n      return groupKey;\n    };\n\n    ArrayEnumerable.call(this, elements);\n  };\n\n  Grouping.prototype = new ArrayEnumerable(); // module export\n\n  if (typeof define === Types.Function && define.amd) {\n    // AMD\n    define(\"linqjs\", [], function () {\n      return Enumerable;\n    });\n  } else if (typeof module !== Types.Undefined && module.exports) {\n    // Node\n    module.exports = Enumerable;\n  } else {\n    root.Enumerable = Enumerable;\n  }\n})(this);","map":null,"metadata":{},"sourceType":"script"}