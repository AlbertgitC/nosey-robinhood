{"ast":null,"code":"// We need to have at least old-style Proxies\nif (typeof Proxy === 'undefined') throw new Error('Native proxies not enabled. use `node --harmony` or `node --harmony-proxies`'); // Check if we actually have new-style Proxies\n\nmodule.exports = typeof Proxy.create !== 'function' ? Proxy : ProxyShim;\n\nfunction ProxyShim(target, handler) {\n  // this code is mostly copied from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Old_Proxy_API\n  var oldHandler = {\n    // Fundamental traps\n    getOwnPropertyDescriptor: function (name) {\n      if (handler.getOwnPropertyDescriptor) return handler.getOwnPropertyDescriptor(target, name);\n      var desc = Object.getOwnPropertyDescriptor(target, name); // a trapping proxy's properties must always be configurable\n\n      if (desc !== undefined) {\n        desc.configurable = true;\n      }\n\n      return desc;\n    },\n    getPropertyDescriptor: function (name) {\n      var proto = target;\n\n      do {\n        var desc = Object.getOwnPropertyDescriptor(proto, name);\n      } while (desc === undefined && (proto = Object.getPrototypeOf(proto))); // a trapping proxy's properties must always be configurable\n\n\n      if (desc !== undefined) {\n        desc.configurable = true;\n      }\n\n      return desc;\n    },\n    getOwnPropertyNames: function (name) {\n      if (handler.getOwnPropertyNames) return handler.getOwnPropertyNames(target, name);\n      return Object.getOwnPropertyNames(target);\n    },\n    getPropertyNames: function () {\n      var names = [];\n      var proto = target;\n\n      do {\n        names = names.concat(Object.getOwnPropertyNames(proto));\n      } while ((proto = Object.getPrototypeOf(proto)) && proto !== Object.prototype);\n\n      return names;\n    },\n    defineProperty: function (name, desc) {\n      if (handler.defineProperty) return handler.defineProperty(target, name, desc);\n      return Object.defineProperty(target, name, desc);\n    },\n    delete: function (name) {\n      if (handler.deleteProperty) return handler.deleteProperty(target, name);\n      return delete target[name];\n    }\n    /* TODO: freeze, seal, preventExtensions\n    fix: function() {\n    \tif (Object.isFrozen(obj)) {\n    \t\treturn Object.getOwnPropertyNames(obj).map(function(name) {\n    \t\t\treturn Object.getOwnPropertyDescriptor(obj, name);\n    \t\t});\n    \t}\n    \t// As long as obj is not frozen, the proxy won't allow itself to be fixed\n    \treturn undefined; // will cause a TypeError to be thrown\n    },*/\n\n  }; // derived traps\n\n  if (handler.has) oldHandler.has = function (name) {\n    return handler.has(target, name);\n  };\n  if (handler.hasOwn) oldHandler.hasOwn = function (name) {\n    return handler.hasOwn(target, name);\n  };\n  if (handler.get) oldHandler.get = function (receiver, name) {\n    return handler.get(target, name, receiver);\n  };\n  if (handler.set) oldHandler.set = function (receiver, name, val) {\n    return handler.set(target, name, val, receiver);\n  };\n  if (handler.enumerate) oldHandler.enumerate = function () {\n    return handler.enumerate(target);\n  };\n  if (handler.keys) oldHandler.keys = function () {\n    return handler.keys(target);\n  };\n  if (typeof target !== 'function') return Proxy.create(oldHandler, Object.getPrototypeOf(target));\n  return Proxy.createFunction(oldHandler, handler.apply && function () {\n    return handler.apply(target, this, Array.prototype.slice.call(arguments));\n  }, handler.construct && function (args) {\n    return handler.construct(target, Array.prototype.slice.call(arguments));\n  });\n}","map":null,"metadata":{},"sourceType":"script"}