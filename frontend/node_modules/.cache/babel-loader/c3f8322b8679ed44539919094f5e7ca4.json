{"ast":null,"code":"\"use strict\";\n\nvar Long = require('bson').Long,\n    Logger = require('./connection/logger'),\n    MongoError = require('./error'),\n    f = require('util').format;\n/**\n * This is a cursor results callback\n *\n * @callback resultCallback\n * @param {error} error An error object. Set to null if no error present\n * @param {object} document\n */\n\n/**\n * @fileOverview The **Cursor** class is an internal class that embodies a cursor on MongoDB\n * allowing for iteration over the results returned from the underlying query.\n *\n * **CURSORS Cannot directly be instantiated**\n * @example\n * var Server = require('mongodb-core').Server\n *   , ReadPreference = require('mongodb-core').ReadPreference\n *   , assert = require('assert');\n *\n * var server = new Server({host: 'localhost', port: 27017});\n * // Wait for the connection event\n * server.on('connect', function(server) {\n *   assert.equal(null, err);\n *\n *   // Execute the write\n *   var cursor = _server.cursor('integration_tests.inserts_example4', {\n *       find: 'integration_tests.example4'\n *     , query: {a:1}\n *   }, {\n *     readPreference: new ReadPreference('secondary');\n *   });\n *\n *   // Get the first document\n *   cursor.next(function(err, doc) {\n *     assert.equal(null, err);\n *     server.destroy();\n *   });\n * });\n *\n * // Start connecting\n * server.connect();\n */\n\n/**\n * Creates a new Cursor, not to be used directly\n * @class\n * @param {object} bson An instance of the BSON parser\n * @param {string} ns The MongoDB fully qualified namespace (ex: db1.collection1)\n * @param {{object}|Long} cmd The selector (can be a command or a cursorId)\n * @param {object} [options=null] Optional settings.\n * @param {object} [options.batchSize=1000] Batchsize for the operation\n * @param {array} [options.documents=[]] Initial documents list for cursor\n * @param {object} [options.transforms=null] Transform methods for the cursor results\n * @param {function} [options.transforms.query] Transform the value returned from the initial query\n * @param {function} [options.transforms.doc] Transform each document returned from Cursor.prototype.next\n * @param {object} topology The server topology instance.\n * @param {object} topologyOptions The server topology options.\n * @return {Cursor} A cursor instance\n * @property {number} cursorBatchSize The current cursorBatchSize for the cursor\n * @property {number} cursorLimit The current cursorLimit for the cursor\n * @property {number} cursorSkip The current cursorSkip for the cursor\n */\n\n\nvar Cursor = function (bson, ns, cmd, options, topology, topologyOptions) {\n  options = options || {}; // Cursor reference\n\n  var self = this; // Initial query\n\n  var query = null; // Cursor pool\n\n  this.pool = null; // Cursor server\n\n  this.server = null; // Do we have a not connected handler\n\n  this.disconnectHandler = options.disconnectHandler; // Set local values\n\n  this.bson = bson;\n  this.ns = ns;\n  this.cmd = cmd;\n  this.options = options;\n  this.topology = topology; // All internal state\n\n  this.cursorState = {\n    cursorId: null,\n    cmd: cmd,\n    documents: options.documents || [],\n    cursorIndex: 0,\n    dead: false,\n    killed: false,\n    init: false,\n    notified: false,\n    limit: options.limit || cmd.limit || 0,\n    skip: options.skip || cmd.skip || 0,\n    batchSize: options.batchSize || cmd.batchSize || 1000,\n    currentLimit: 0 // Result field name if not a cursor (contains the array of results)\n    ,\n    transforms: options.transforms\n  }; // Add promoteLong to cursor state\n\n  if (typeof topologyOptions.promoteLongs == 'boolean') {\n    this.cursorState.promoteLongs = topologyOptions.promoteLongs;\n  } // Callback controller\n\n\n  this.callbacks = null; // Logger\n\n  this.logger = Logger('Cursor', options); //\n  // Did we pass in a cursor id\n\n  if (typeof cmd == 'number') {\n    this.cursorState.cursorId = Long.fromNumber(cmd);\n    this.cursorState.lastCursorId = this.cursorState.cursorId;\n  } else if (cmd instanceof Long) {\n    this.cursorState.cursorId = cmd;\n    this.cursorState.lastCursorId = cmd;\n  }\n};\n\nCursor.prototype.setCursorBatchSize = function (value) {\n  this.cursorState.batchSize = value;\n};\n\nCursor.prototype.cursorBatchSize = function () {\n  return this.cursorState.batchSize;\n};\n\nCursor.prototype.setCursorLimit = function (value) {\n  this.cursorState.limit = value;\n};\n\nCursor.prototype.cursorLimit = function () {\n  return this.cursorState.limit;\n};\n\nCursor.prototype.setCursorSkip = function (value) {\n  this.cursorState.skip = value;\n};\n\nCursor.prototype.cursorSkip = function () {\n  return this.cursorState.skip;\n}; //\n// Handle callback (including any exceptions thrown)\n\n\nvar handleCallback = function (callback, err, result) {\n  try {\n    callback(err, result);\n  } catch (err) {\n    process.nextTick(function () {\n      throw err;\n    });\n  }\n}; // Internal methods\n\n\nCursor.prototype._find = function (callback) {\n  var self = this;\n\n  if (self.logger.isDebug()) {\n    self.logger.debug(f(\"issue initial query [%s] with flags [%s]\", JSON.stringify(self.cmd), JSON.stringify(self.query)));\n  }\n\n  var queryCallback = function (err, result) {\n    if (err) return callback(err); // Query failure bit set\n\n    if (result.queryFailure) {\n      return callback(MongoError.create(result.documents[0]), null);\n    } // Store the connection for usage with getMore command\n\n\n    self.connection = result.connection; // Check if we have a command cursor\n\n    if (Array.isArray(result.documents) && result.documents.length == 1 && (!self.cmd.find || self.cmd.find && self.cmd.virtual == false) && (result.documents[0].cursor != 'string' || result.documents[0]['$err'] || result.documents[0]['errmsg'] || Array.isArray(result.documents[0].result))) {\n      // We have a an error document return the error\n      if (result.documents[0]['$err'] || result.documents[0]['errmsg']) {\n        return callback(MongoError.create(result.documents[0]), null);\n      } // We have a cursor document\n\n\n      if (result.documents[0].cursor != null && typeof result.documents[0].cursor != 'string') {\n        var id = result.documents[0].cursor.id; // If we have a namespace change set the new namespace for getmores\n\n        if (result.documents[0].cursor.ns) {\n          self.ns = result.documents[0].cursor.ns;\n        } // Promote id to long if needed\n\n\n        self.cursorState.cursorId = typeof id == 'number' ? Long.fromNumber(id) : id;\n        self.cursorState.lastCursorId = self.cursorState.cursorId; // If we have a firstBatch set it\n\n        if (Array.isArray(result.documents[0].cursor.firstBatch)) {\n          self.cursorState.documents = result.documents[0].cursor.firstBatch; //.reverse();\n        } // Return after processing command cursor\n\n\n        return callback(null, null);\n      }\n\n      if (Array.isArray(result.documents[0].result)) {\n        self.cursorState.documents = result.documents[0].result;\n        self.cursorState.cursorId = Long.ZERO;\n        return callback(null, null);\n      }\n    } // Otherwise fall back to regular find path\n\n\n    self.cursorState.cursorId = result.cursorId;\n    self.cursorState.documents = result.documents;\n    self.cursorState.lastCursorId = result.cursorId; // Transform the results with passed in transformation method if provided\n\n    if (self.cursorState.transforms && typeof self.cursorState.transforms.query == 'function') {\n      self.cursorState.documents = self.cursorState.transforms.query(result);\n    } // Return callback\n\n\n    callback(null, null);\n  }; // If we have a raw query decorate the function\n\n\n  if (self.options.raw || self.cmd.raw) {\n    queryCallback.raw = self.options.raw || self.cmd.raw;\n  } // Do we have documentsReturnedIn set on the query\n\n\n  if (typeof self.query.documentsReturnedIn == 'string') {\n    queryCallback.documentsReturnedIn = self.query.documentsReturnedIn;\n  } // Add promote Long value if defined\n\n\n  if (typeof self.cursorState.promoteLongs == 'boolean') {\n    queryCallback.promoteLongs = self.cursorState.promoteLongs;\n  } // Set up callback\n\n\n  self.callbacks.register(self.query.requestId, queryCallback); // Write the initial command out\n\n  self.pool.write(self.query.toBin(), queryCallback);\n};\n\nCursor.prototype._getmore = function (callback) {\n  if (this.logger.isDebug()) this.logger.debug(f(\"schedule getMore call for query [%s]\", JSON.stringify(this.query))); // Determine if it's a raw query\n\n  var raw = this.options.raw || this.cmd.raw; // Set the current batchSize\n\n  var batchSize = this.cursorState.batchSize;\n\n  if (this.cursorState.limit > 0 && this.cursorState.currentLimit + batchSize > this.cursorState.limit) {\n    batchSize = this.cursorState.limit - this.cursorState.currentLimit;\n  } // Default pool\n\n\n  var pool = this.pool; // If we have a connection get the corresponding pool\n\n  if (this.connection && this.connection.isConnected()) {\n    // Get the server\n    var server = this.topology.getServerFrom(this.connection); // Get the pool\n\n    if (server && server.s.pool) {\n      pool = server.s.pool;\n    }\n  } // We have a wire protocol handler\n\n\n  this.server.wireProtocolHandler.getMore(this.bson, this.ns, this.cursorState, batchSize, raw, pool, this.callbacks, this.options, callback);\n};\n\nCursor.prototype._killcursor = function (callback) {\n  // Set cursor to dead\n  this.cursorState.dead = true;\n  this.cursorState.killed = true; // Remove documents\n\n  this.cursorState.documents = []; // If no cursor id just return\n\n  if (this.cursorState.cursorId == null || this.cursorState.cursorId.isZero() || this.cursorState.init == false) {\n    if (callback) callback(null, null);\n    return;\n  } // Default pool\n\n\n  var pool = this.pool; // If we have a connection get the corresponding pool\n\n  if (this.connection && this.connection.isConnected()) {\n    // Get the server\n    var server = this.topology.getServerFrom(this.connection); // Get the pool\n\n    if (server && server.s.pool) {\n      pool = server.s.pool;\n    }\n  } // Execute command\n\n\n  this.server.wireProtocolHandler.killCursor(this.bson, this.ns, this.cursorState.cursorId, pool, this.callbacks, callback);\n};\n/**\n * Clone the cursor\n * @method\n * @return {Cursor}\n */\n\n\nCursor.prototype.clone = function () {\n  return this.topology.cursor(this.ns, this.cmd, this.options);\n};\n/**\n * Checks if the cursor is dead\n * @method\n * @return {boolean} A boolean signifying if the cursor is dead or not\n */\n\n\nCursor.prototype.isDead = function () {\n  return this.cursorState.dead == true;\n};\n/**\n * Checks if the cursor was killed by the application\n * @method\n * @return {boolean} A boolean signifying if the cursor was killed by the application\n */\n\n\nCursor.prototype.isKilled = function () {\n  return this.cursorState.killed == true;\n};\n/**\n * Checks if the cursor notified it's caller about it's death\n * @method\n * @return {boolean} A boolean signifying if the cursor notified the callback\n */\n\n\nCursor.prototype.isNotified = function () {\n  return this.cursorState.notified == true;\n};\n/**\n * Returns current buffered documents length\n * @method\n * @return {number} The number of items in the buffered documents\n */\n\n\nCursor.prototype.bufferedCount = function () {\n  return this.cursorState.documents.length - this.cursorState.cursorIndex;\n};\n/**\n * Returns current buffered documents\n * @method\n * @return {Array} An array of buffered documents\n */\n\n\nCursor.prototype.readBufferedDocuments = function (number) {\n  var unreadDocumentsLength = this.cursorState.documents.length - this.cursorState.cursorIndex;\n  var length = number < unreadDocumentsLength ? number : unreadDocumentsLength;\n  var elements = this.cursorState.documents.slice(this.cursorState.cursorIndex, this.cursorState.cursorIndex + length); // Transform the doc with passed in transformation method if provided\n\n  if (this.cursorState.transforms && typeof this.cursorState.transforms.doc == 'function') {\n    // Transform all the elements\n    for (var i = 0; i < elements.length; i++) {\n      elements[i] = this.cursorState.transforms.doc(elements[i]);\n    }\n  } // Ensure we do not return any more documents than the limit imposed\n  // Just return the number of elements up to the limit\n\n\n  if (this.cursorState.limit > 0 && this.cursorState.currentLimit + elements.length > this.cursorState.limit) {\n    elements = elements.slice(0, this.cursorState.limit - this.cursorState.currentLimit);\n    this.kill();\n  } // Adjust current limit\n\n\n  this.cursorState.currentLimit = this.cursorState.currentLimit + elements.length;\n  this.cursorState.cursorIndex = this.cursorState.cursorIndex + elements.length; // Return elements\n\n  return elements;\n};\n/**\n * Kill the cursor\n * @method\n * @param {resultCallback} callback A callback function\n */\n\n\nCursor.prototype.kill = function (callback) {\n  this._killcursor(callback);\n};\n/**\n * Resets the cursor\n * @method\n * @return {null}\n */\n\n\nCursor.prototype.rewind = function () {\n  if (this.cursorState.init) {\n    if (!this.cursorState.dead) {\n      this.kill();\n    }\n\n    this.cursorState.currentLimit = 0;\n    this.cursorState.init = false;\n    this.cursorState.dead = false;\n    this.cursorState.killed = false;\n    this.cursorState.notified = false;\n    this.cursorState.documents = [];\n    this.cursorState.cursorId = null;\n    this.cursorState.cursorIndex = 0;\n  }\n};\n/**\n * Validate if the pool is dead and return error\n */\n\n\nvar isConnectionDead = function (self, callback) {\n  if (self.pool && self.pool.isDestroyed()) {\n    self.cursorState.notified = true;\n    self.cursorState.killed = true;\n    self.cursorState.documents = [];\n    self.cursorState.cursorIndex = 0;\n    callback(MongoError.create(f('connection to host %s:%s was destroyed', self.pool.host, self.pool.port)));\n    return true;\n  }\n\n  return false;\n};\n/**\n * Validate if the cursor is dead but was not explicitly killed by user\n */\n\n\nvar isCursorDeadButNotkilled = function (self, callback) {\n  // Cursor is dead but not marked killed, return null\n  if (self.cursorState.dead && !self.cursorState.killed) {\n    self.cursorState.notified = true;\n    self.cursorState.killed = true;\n    self.cursorState.documents = [];\n    self.cursorState.cursorIndex = 0;\n    handleCallback(callback, null, null);\n    return true;\n  }\n\n  return false;\n};\n/**\n * Validate if the cursor is dead and was killed by user\n */\n\n\nvar isCursorDeadAndKilled = function (self, callback) {\n  if (self.cursorState.dead && self.cursorState.killed) {\n    handleCallback(callback, MongoError.create(\"cursor is dead\"));\n    return true;\n  }\n\n  return false;\n};\n/**\n * Validate if the cursor was killed by the user\n */\n\n\nvar isCursorKilled = function (self, callback) {\n  if (self.cursorState.killed) {\n    self.cursorState.notified = true;\n    self.cursorState.documents = [];\n    self.cursorState.cursorIndex = 0;\n    handleCallback(callback, null, null);\n    return true;\n  }\n\n  return false;\n};\n/**\n * Mark cursor as being dead and notified\n */\n\n\nvar setCursorDeadAndNotified = function (self, callback) {\n  self.cursorState.dead = true;\n  self.cursorState.notified = true;\n  self.cursorState.documents = [];\n  self.cursorState.cursorIndex = 0;\n  handleCallback(callback, null, null);\n};\n/**\n * Mark cursor as being notified\n */\n\n\nvar setCursorNotified = function (self, callback) {\n  self.cursorState.notified = true;\n  self.cursorState.documents = [];\n  self.cursorState.cursorIndex = 0;\n  handleCallback(callback, null, null);\n};\n\nvar push = Array.prototype.push;\n\nvar nextFunction = function (self, callback) {\n  // We have notified about it\n  if (self.cursorState.notified) {\n    return callback(new Error('cursor is exhausted'));\n  } // Cursor is killed return null\n\n\n  if (isCursorKilled(self, callback)) return; // Cursor is dead but not marked killed, return null\n\n  if (isCursorDeadButNotkilled(self, callback)) return; // We have a dead and killed cursor, attempting to call next should error\n\n  if (isCursorDeadAndKilled(self, callback)) return; // We have just started the cursor\n\n  if (!self.cursorState.init) {\n    // Topology is not connected, save the call in the provided store to be\n    // Executed at some point when the handler deems it's reconnected\n    if (!self.topology.isConnected(self.options) && self.disconnectHandler != null) {\n      return self.disconnectHandler.addObjectAndMethod('cursor', self, 'next', [callback], callback);\n    }\n\n    try {\n      // Get a server\n      self.server = self.topology.getServer(self.options); // Get a reference to the pool\n\n      self.pool = self.server.s.pool; // Get the callbacks\n\n      self.callbacks = self.server.getCallbacks();\n    } catch (err) {\n      // Handle the error and add object to next method call\n      if (self.disconnectHandler != null) {\n        return self.disconnectHandler.addObjectAndMethod('cursor', self, 'next', [callback], callback);\n      } // Otherwise return the error\n\n\n      return callback(err);\n    } // Set as init\n\n\n    self.cursorState.init = true;\n\n    try {\n      self.query = self.server.wireProtocolHandler.command(self.bson, self.ns, self.cmd, self.cursorState, self.topology, self.options);\n    } catch (err) {\n      return callback(err);\n    }\n  } // If we don't have a cursorId execute the first query\n\n\n  if (self.cursorState.cursorId == null) {\n    // Check if pool is dead and return if not possible to\n    // execute the query against the db\n    if (isConnectionDead(self, callback)) return; // Check if topology is destroyed\n\n    if (self.topology.isDestroyed()) return callback(new MongoError(f('connection destroyed, not possible to instantiate cursor'))); // query, cmd, options, cursorState, callback\n\n    self._find(function (err, r) {\n      if (err) return handleCallback(callback, err, null);\n\n      if (self.cursorState.documents.length == 0 && self.cursorState.cursorId && self.cursorState.cursorId.isZero() && !self.cmd.tailable && !self.cmd.awaitData) {\n        return setCursorNotified(self, callback);\n      }\n\n      nextFunction(self, callback);\n    });\n  } else if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\n    // Ensure we kill the cursor on the server\n    self.kill(); // Set cursor in dead and notified state\n\n    return setCursorDeadAndNotified(self, callback);\n  } else if (self.cursorState.cursorIndex == self.cursorState.documents.length && !Long.ZERO.equals(self.cursorState.cursorId)) {\n    // Ensure an empty cursor state\n    self.cursorState.documents = [];\n    self.cursorState.cursorIndex = 0; // Check if topology is destroyed\n\n    if (self.topology.isDestroyed()) return callback(new MongoError(f('connection destroyed, not possible to instantiate cursor'))); // Check if connection is dead and return if not possible to\n    // execute a getmore on this connection\n\n    if (isConnectionDead(self, callback)) return; // Execute the next get more\n\n    self._getmore(function (err, doc, connection) {\n      // General error\n      // if(err && err.code != 43) return handleCallback(callback, err);\n      if (err && err.code != 43) return handleCallback(callback, err); // No cursor found error from mongos\n\n      if (err && err.code == 43 || self.cursorState.documents.length == 0 && Long.ZERO.equals(self.cursorState.cursorId) && !self.cmd.tailable) {\n        self.cursorState.dead = true; // Finished iterating over the cursor\n\n        return setCursorDeadAndNotified(self, callback);\n      } // Save the returned connection to ensure all getMore's fire over the same connection\n\n\n      self.connection = connection; // Tailable cursor getMore result, notify owner about it\n      // No attempt is made here to retry, this is left to the user of the\n      // core module to handle to keep core simple\n\n      if (self.cursorState.documents.length == 0 && self.cmd.tailable && Long.ZERO.equals(self.cursorState.cursorId)) {\n        // No more documents in the tailed cursor\n        return handleCallback(callback, MongoError.create({\n          message: \"No more documents in tailed cursor\",\n          tailable: self.cmd.tailable,\n          awaitData: self.cmd.awaitData\n        }));\n      } else if (self.cursorState.documents.length == 0 && self.cmd.tailable && !Long.ZERO.equals(self.cursorState.cursorId)) {\n        return nextFunction(self, callback);\n      }\n\n      if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\n        return setCursorDeadAndNotified(self, callback);\n      }\n\n      nextFunction(self, callback);\n    });\n  } else if (self.cursorState.documents.length == self.cursorState.cursorIndex && self.cmd.tailable && Long.ZERO.equals(self.cursorState.cursorId)) {\n    return handleCallback(callback, MongoError.create({\n      message: \"No more documents in tailed cursor\",\n      tailable: self.cmd.tailable,\n      awaitData: self.cmd.awaitData\n    }));\n  } else if (self.cursorState.documents.length == self.cursorState.cursorIndex && Long.ZERO.equals(self.cursorState.cursorId)) {\n    setCursorDeadAndNotified(self, callback);\n  } else {\n    if (self.cursorState.limit > 0 && self.cursorState.currentLimit >= self.cursorState.limit) {\n      // Ensure we kill the cursor on the server\n      self.kill(); // Set cursor in dead and notified state\n\n      return setCursorDeadAndNotified(self, callback);\n    } // Increment the current cursor limit\n\n\n    self.cursorState.currentLimit += 1; // Get the document\n\n    var doc = self.cursorState.documents[self.cursorState.cursorIndex++]; // Doc overflow\n\n    if (doc.$err) {\n      // Ensure we kill the cursor on the server\n      self.kill(); // Set cursor in dead and notified state\n\n      return setCursorDeadAndNotified(self, function () {\n        handleCallback(callback, new MongoError(doc.$err));\n      });\n    } // Transform the doc with passed in transformation method if provided\n\n\n    if (self.cursorState.transforms && typeof self.cursorState.transforms.doc == 'function') {\n      doc = self.cursorState.transforms.doc(doc);\n    } // Return the document\n\n\n    handleCallback(callback, null, doc);\n  }\n};\n/**\n * Retrieve the next document from the cursor\n * @method\n * @param {resultCallback} callback A callback function\n */\n\n\nCursor.prototype.next = function (callback) {\n  nextFunction(this, callback);\n};\n\nmodule.exports = Cursor;","map":null,"metadata":{},"sourceType":"script"}