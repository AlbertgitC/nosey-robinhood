{"ast":null,"code":"/*\n\tBaby Parse\n\tv0.4.1\n\thttps://github.com/Rich-Harris/BabyParse\n\n\tCreated by Rich Harris\n\tMaintained by Matt Holt\n\n\tBased on Papa Parse v4.0.7 by Matt Holt\n\thttps://github.com/mholt/PapaParse\n*/\n(function (global) {\n  // A configuration object from which to draw default settings\n  var DEFAULTS = {\n    delimiter: \"\",\n    // empty: auto-detect\n    newline: \"\",\n    // empty: auto-detect\n    header: false,\n    dynamicTyping: false,\n    preview: 0,\n    step: undefined,\n    comments: false,\n    complete: undefined,\n    skipEmptyLines: false,\n    fastMode: false\n  };\n  var Baby = {};\n  Baby.parse = CsvToJson;\n  Baby.parseFiles = ParseFiles;\n  Baby.unparse = JsonToCsv;\n  Baby.RECORD_SEP = String.fromCharCode(30);\n  Baby.UNIT_SEP = String.fromCharCode(31);\n  Baby.BYTE_ORDER_MARK = \"\\ufeff\";\n  Baby.BAD_DELIMITERS = [\"\\r\", \"\\n\", \"\\\"\", Baby.BYTE_ORDER_MARK];\n  Baby.DefaultDelimiter = \",\"; // Used if not specified and detection fails\n\n  Baby.Parser = Parser; // For testing/dev only\n\n  Baby.ParserHandle = ParserHandle; // For testing/dev only\n\n  var fs = fs || require('fs');\n\n  function ParseFiles(_input, _config) {\n    if (Array.isArray(_input)) {\n      var results = [];\n\n      _input.forEach(function (input) {\n        if (typeof input === 'object') results.push(ParseFiles(input.file, input.config));else results.push(ParseFiles(input, _config));\n      });\n\n      return results;\n    } else {\n      var results = {\n        data: [],\n        errors: []\n      };\n\n      if (/(\\.csv|\\.txt)$/.test(_input)) {\n        try {\n          var contents = fs.readFileSync(_input).toString();\n          return CsvToJson(contents, _config);\n        } catch (err) {\n          results.errors.push(err);\n          return results;\n        }\n      } else {\n        results.errors.push({\n          type: '',\n          code: '',\n          message: 'Unsupported file type.',\n          row: ''\n        });\n        return results;\n      }\n    }\n  }\n\n  function CsvToJson(_input, _config) {\n    var config = copyAndValidateConfig(_config);\n    var ph = new ParserHandle(config);\n    var results = ph.parse(_input);\n    return results;\n  }\n\n  function JsonToCsv(_input, _config) {\n    var _output = \"\";\n    var _fields = []; // Default configuration\n\n    var _quotes = false; // whether to surround every datum with quotes\n\n    var _delimiter = \",\"; // delimiting character\n\n    var _newline = \"\\r\\n\"; // newline character(s)\n\n    unpackConfig();\n    if (typeof _input === 'string') _input = JSON.parse(_input);\n\n    if (_input instanceof Array) {\n      if (!_input.length || _input[0] instanceof Array) return serialize(null, _input);else if (typeof _input[0] === 'object') return serialize(objectKeys(_input[0]), _input);\n    } else if (typeof _input === 'object') {\n      if (typeof _input.data === 'string') _input.data = JSON.parse(_input.data);\n\n      if (_input.data instanceof Array) {\n        if (!_input.fields) _input.fields = _input.data[0] instanceof Array ? _input.fields : objectKeys(_input.data[0]);\n        if (!(_input.data[0] instanceof Array) && typeof _input.data[0] !== 'object') _input.data = [_input.data]; // handles input like [1,2,3] or [\"asdf\"]\n      }\n\n      return serialize(_input.fields || [], _input.data || []);\n    } // Default (any valid paths should return before this)\n\n\n    throw \"exception: Unable to serialize unrecognized input\";\n\n    function unpackConfig() {\n      if (typeof _config !== 'object') return;\n\n      if (typeof _config.delimiter === 'string' && _config.delimiter.length == 1 && Baby.BAD_DELIMITERS.indexOf(_config.delimiter) == -1) {\n        _delimiter = _config.delimiter;\n      }\n\n      if (typeof _config.quotes === 'boolean' || _config.quotes instanceof Array) _quotes = _config.quotes;\n      if (typeof _config.newline === 'string') _newline = _config.newline;\n    } // Turns an object's keys into an array\n\n\n    function objectKeys(obj) {\n      if (typeof obj !== 'object') return [];\n      var keys = [];\n\n      for (var key in obj) keys.push(key);\n\n      return keys;\n    } // The double for loop that iterates the data and writes out a CSV string including header row\n\n\n    function serialize(fields, data) {\n      var csv = \"\";\n      if (typeof fields === 'string') fields = JSON.parse(fields);\n      if (typeof data === 'string') data = JSON.parse(data);\n      var hasHeader = fields instanceof Array && fields.length > 0;\n      var dataKeyedByField = !(data[0] instanceof Array); // If there a header row, write it first\n\n      if (hasHeader) {\n        for (var i = 0; i < fields.length; i++) {\n          if (i > 0) csv += _delimiter;\n          csv += safe(fields[i], i);\n        }\n\n        if (data.length > 0) csv += _newline;\n      } // Then write out the data\n\n\n      for (var row = 0; row < data.length; row++) {\n        var maxCol = hasHeader ? fields.length : data[row].length;\n\n        for (var col = 0; col < maxCol; col++) {\n          if (col > 0) csv += _delimiter;\n          var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;\n          csv += safe(data[row][colIdx], col);\n        }\n\n        if (row < data.length - 1) csv += _newline;\n      }\n\n      return csv;\n    } // Encloses a value around quotes if needed (makes a value safe for CSV insertion)\n\n\n    function safe(str, col) {\n      if (typeof str === \"undefined\" || str === null) return \"\";\n      str = str.toString().replace(/\"/g, '\"\"');\n      var needsQuotes = typeof _quotes === 'boolean' && _quotes || _quotes instanceof Array && _quotes[col] || hasAny(str, Baby.BAD_DELIMITERS) || str.indexOf(_delimiter) > -1 || str.charAt(0) == ' ' || str.charAt(str.length - 1) == ' ';\n      return needsQuotes ? '\"' + str + '\"' : str;\n    }\n\n    function hasAny(str, substrings) {\n      for (var i = 0; i < substrings.length; i++) if (str.indexOf(substrings[i]) > -1) return true;\n\n      return false;\n    }\n  } // Use one ParserHandle per entire CSV file or string\n\n\n  function ParserHandle(_config) {\n    // One goal is to minimize the use of regular expressions...\n    var FLOAT = /^\\s*-?(\\d*\\.?\\d+|\\d+\\.?\\d*)(e[-+]?\\d+)?\\s*$/i;\n    var self = this;\n    var _stepCounter = 0; // Number of times step was called (number of rows parsed)\n\n    var _input; // The input being parsed\n\n\n    var _parser; // The core parser being used\n\n\n    var _paused = false; // Whether we are paused or not\n\n    var _delimiterError; // Temporary state between delimiter detection and processing results\n\n\n    var _fields = []; // Fields are from the header row of the input, if there is one\n\n    var _results = {\n      // The last results returned from the parser\n      data: [],\n      errors: [],\n      meta: {}\n    };\n\n    if (isFunction(_config.step)) {\n      var userStep = _config.step;\n\n      _config.step = function (results) {\n        _results = results;\n        if (needsHeaderRow()) processResults();else // only call user's step function after header row\n          {\n            processResults(); // It's possbile that this line was empty and there's no row here after all\n\n            if (_results.data.length == 0) return;\n            _stepCounter += results.data.length;\n            if (_config.preview && _stepCounter > _config.preview) _parser.abort();else userStep(_results, self);\n          }\n      };\n    }\n\n    this.parse = function (input) {\n      if (!_config.newline) _config.newline = guessLineEndings(input);\n      _delimiterError = false;\n\n      if (!_config.delimiter) {\n        var delimGuess = guessDelimiter(input);\n        if (delimGuess.successful) _config.delimiter = delimGuess.bestDelimiter;else {\n          _delimiterError = true; // add error after parsing (otherwise it would be overwritten)\n\n          _config.delimiter = Baby.DefaultDelimiter;\n        }\n        _results.meta.delimiter = _config.delimiter;\n      }\n\n      var parserConfig = copy(_config);\n      if (_config.preview && _config.header) parserConfig.preview++; // to compensate for header row\n\n      _input = input;\n      _parser = new Parser(parserConfig);\n      _results = _parser.parse(_input);\n      processResults();\n      if (isFunction(_config.complete) && !_paused && (!self.streamer || self.streamer.finished())) _config.complete(_results);\n      return _paused ? {\n        meta: {\n          paused: true\n        }\n      } : _results || {\n        meta: {\n          paused: false\n        }\n      };\n    };\n\n    this.pause = function () {\n      _paused = true;\n\n      _parser.abort();\n\n      _input = _input.substr(_parser.getCharIndex());\n    };\n\n    this.resume = function () {\n      _paused = false;\n      _parser = new Parser(_config);\n\n      _parser.parse(_input);\n\n      if (!_paused) {\n        if (self.streamer && !self.streamer.finished()) self.streamer.resume(); // more of the file yet to come\n        else if (isFunction(_config.complete)) _config.complete(_results);\n      }\n    };\n\n    this.abort = function () {\n      _parser.abort();\n\n      if (isFunction(_config.complete)) _config.complete(_results);\n      _input = \"\";\n    };\n\n    function processResults() {\n      if (_results && _delimiterError) {\n        addError(\"Delimiter\", \"UndetectableDelimiter\", \"Unable to auto-detect delimiting character; defaulted to '\" + Baby.DefaultDelimiter + \"'\");\n        _delimiterError = false;\n      }\n\n      if (_config.skipEmptyLines) {\n        for (var i = 0; i < _results.data.length; i++) if (_results.data[i].length == 1 && _results.data[i][0] == \"\") _results.data.splice(i--, 1);\n      }\n\n      if (needsHeaderRow()) fillHeaderFields();\n      return applyHeaderAndDynamicTyping();\n    }\n\n    function needsHeaderRow() {\n      return _config.header && _fields.length == 0;\n    }\n\n    function fillHeaderFields() {\n      if (!_results) return;\n\n      for (var i = 0; needsHeaderRow() && i < _results.data.length; i++) for (var j = 0; j < _results.data[i].length; j++) _fields.push(_results.data[i][j]);\n\n      _results.data.splice(0, 1);\n    }\n\n    function applyHeaderAndDynamicTyping() {\n      if (!_results || !_config.header && !_config.dynamicTyping) return _results;\n\n      for (var i = 0; i < _results.data.length; i++) {\n        var row = {};\n\n        for (var j = 0; j < _results.data[i].length; j++) {\n          if (_config.dynamicTyping) {\n            var value = _results.data[i][j];\n            if (value == \"true\" || value === \"TRUE\") _results.data[i][j] = true;else if (value == \"false\" || value === \"FALSE\") _results.data[i][j] = false;else _results.data[i][j] = tryParseFloat(value);\n          }\n\n          if (_config.header) {\n            if (j >= _fields.length) {\n              if (!row[\"__parsed_extra\"]) row[\"__parsed_extra\"] = [];\n              row[\"__parsed_extra\"].push(_results.data[i][j]);\n            } else row[_fields[j]] = _results.data[i][j];\n          }\n        }\n\n        if (_config.header) {\n          _results.data[i] = row;\n          if (j > _fields.length) addError(\"FieldMismatch\", \"TooManyFields\", \"Too many fields: expected \" + _fields.length + \" fields but parsed \" + j, i);else if (j < _fields.length) addError(\"FieldMismatch\", \"TooFewFields\", \"Too few fields: expected \" + _fields.length + \" fields but parsed \" + j, i);\n        }\n      }\n\n      if (_config.header && _results.meta) _results.meta.fields = _fields;\n      return _results;\n    }\n\n    function guessDelimiter(input) {\n      var delimChoices = [\",\", \"\\t\", \"|\", \";\", Baby.RECORD_SEP, Baby.UNIT_SEP];\n      var bestDelim, bestDelta, fieldCountPrevRow;\n\n      for (var i = 0; i < delimChoices.length; i++) {\n        var delim = delimChoices[i];\n        var delta = 0,\n            avgFieldCount = 0;\n        fieldCountPrevRow = undefined;\n        var preview = new Parser({\n          delimiter: delim,\n          preview: 10\n        }).parse(input);\n\n        for (var j = 0; j < preview.data.length; j++) {\n          var fieldCount = preview.data[j].length;\n          avgFieldCount += fieldCount;\n\n          if (typeof fieldCountPrevRow === 'undefined') {\n            fieldCountPrevRow = fieldCount;\n            continue;\n          } else if (fieldCount > 1) {\n            delta += Math.abs(fieldCount - fieldCountPrevRow);\n            fieldCountPrevRow = fieldCount;\n          }\n        }\n\n        avgFieldCount /= preview.data.length;\n\n        if ((typeof bestDelta === 'undefined' || delta < bestDelta) && avgFieldCount > 1.99) {\n          bestDelta = delta;\n          bestDelim = delim;\n        }\n      }\n\n      _config.delimiter = bestDelim;\n      return {\n        successful: !!bestDelim,\n        bestDelimiter: bestDelim\n      };\n    }\n\n    function guessLineEndings(input) {\n      input = input.substr(0, 1024 * 1024); // max length 1 MB\n\n      var r = input.split('\\r');\n      if (r.length == 1) return '\\n';\n      var numWithN = 0;\n\n      for (var i = 0; i < r.length; i++) {\n        if (r[i][0] == '\\n') numWithN++;\n      }\n\n      return numWithN >= r.length / 2 ? '\\r\\n' : '\\r';\n    }\n\n    function tryParseFloat(val) {\n      var isNumber = FLOAT.test(val);\n      return isNumber ? parseFloat(val) : val;\n    }\n\n    function addError(type, code, msg, row) {\n      _results.errors.push({\n        type: type,\n        code: code,\n        message: msg,\n        row: row\n      });\n    }\n  } // The core parser implements speedy and correct CSV parsing\n\n\n  function Parser(config) {\n    // Unpack the config object\n    config = config || {};\n    var delim = config.delimiter;\n    var newline = config.newline;\n    var comments = config.comments;\n    var step = config.step;\n    var preview = config.preview;\n    var fastMode = config.fastMode; // Delimiter must be valid\n\n    if (typeof delim !== 'string' || delim.length != 1 || Baby.BAD_DELIMITERS.indexOf(delim) > -1) delim = \",\"; // Comment character must be valid\n\n    if (comments === delim) throw \"Comment character same as delimiter\";else if (comments === true) comments = \"#\";else if (typeof comments !== 'string' || Baby.BAD_DELIMITERS.indexOf(comments) > -1) comments = false; // Newline must be valid: \\r, \\n, or \\r\\n\n\n    if (newline != '\\n' && newline != '\\r' && newline != '\\r\\n') newline = '\\n'; // We're gonna need these at the Parser scope\n\n    var cursor = 0;\n    var aborted = false;\n\n    this.parse = function (input) {\n      // For some reason, in Chrome, this speeds things up (!?)\n      if (typeof input !== 'string') throw \"Input must be a string\"; // We don't need to compute some of these every time parse() is called,\n      // but having them in a more local scope seems to perform better\n\n      var inputLen = input.length,\n          delimLen = delim.length,\n          newlineLen = newline.length,\n          commentsLen = comments.length;\n      var stepIsFunction = typeof step === 'function'; // Establish starting state\n\n      cursor = 0;\n      var data = [],\n          errors = [],\n          row = [];\n      if (!input) return returnable();\n\n      if (fastMode) {\n        // Fast mode assumes there are no quoted fields in the input\n        var rows = input.split(newline);\n\n        for (var i = 0; i < rows.length; i++) {\n          if (comments && rows[i].substr(0, commentsLen) == comments) continue;\n\n          if (stepIsFunction) {\n            data = [rows[i].split(delim)];\n            doStep();\n            if (aborted) return returnable();\n          } else data.push(rows[i].split(delim));\n\n          if (preview && i >= preview) {\n            data = data.slice(0, preview);\n            return returnable(true);\n          }\n        }\n\n        return returnable();\n      }\n\n      var nextDelim = input.indexOf(delim, cursor);\n      var nextNewline = input.indexOf(newline, cursor); // Parser loop\n\n      for (;;) {\n        // Field has opening quote\n        if (input[cursor] == '\"') {\n          // Start our search for the closing quote where the cursor is\n          var quoteSearch = cursor; // Skip the opening quote\n\n          cursor++;\n\n          for (;;) {\n            // Find closing quote\n            var quoteSearch = input.indexOf('\"', quoteSearch + 1);\n\n            if (quoteSearch === -1) {\n              // No closing quote... what a pity\n              errors.push({\n                type: \"Quotes\",\n                code: \"MissingQuotes\",\n                message: \"Quoted field unterminated\",\n                row: data.length,\n                // row has yet to be inserted\n                index: cursor\n              });\n              return finish();\n            }\n\n            if (quoteSearch === inputLen - 1) {\n              // Closing quote at EOF\n              row.push(input.substring(cursor, quoteSearch).replace(/\"\"/g, '\"'));\n              data.push(row);\n              if (stepIsFunction) doStep();\n              return returnable();\n            } // If this quote is escaped, it's part of the data; skip it\n\n\n            if (input[quoteSearch + 1] == '\"') {\n              quoteSearch++;\n              continue;\n            }\n\n            if (input[quoteSearch + 1] == delim) {\n              // Closing quote followed by delimiter\n              row.push(input.substring(cursor, quoteSearch).replace(/\"\"/g, '\"'));\n              cursor = quoteSearch + 1 + delimLen;\n              nextDelim = input.indexOf(delim, cursor);\n              nextNewline = input.indexOf(newline, cursor);\n              break;\n            }\n\n            if (input.substr(quoteSearch + 1, newlineLen) === newline) {\n              // Closing quote followed by newline\n              row.push(input.substring(cursor, quoteSearch).replace(/\"\"/g, '\"'));\n              saveRow(quoteSearch + 1 + newlineLen);\n              nextDelim = input.indexOf(delim, cursor); // because we may have skipped the nextDelim in the quoted field\n\n              if (stepIsFunction) {\n                doStep();\n                if (aborted) return returnable();\n              }\n\n              if (preview && data.length >= preview) return returnable(true);\n              break;\n            }\n          }\n\n          continue;\n        } // Comment found at start of new line\n\n\n        if (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments) {\n          if (nextNewline == -1) // Comment ends at EOF\n            return returnable();\n          cursor = nextNewline + newlineLen;\n          nextNewline = input.indexOf(newline, cursor);\n          nextDelim = input.indexOf(delim, cursor);\n          continue;\n        } // Next delimiter comes before next newline, so we've reached end of field\n\n\n        if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1)) {\n          row.push(input.substring(cursor, nextDelim));\n          cursor = nextDelim + delimLen;\n          nextDelim = input.indexOf(delim, cursor);\n          continue;\n        } // End of row\n\n\n        if (nextNewline !== -1) {\n          row.push(input.substring(cursor, nextNewline));\n          saveRow(nextNewline + newlineLen);\n\n          if (stepIsFunction) {\n            doStep();\n            if (aborted) return returnable();\n          }\n\n          if (preview && data.length >= preview) return returnable(true);\n          continue;\n        }\n\n        break;\n      }\n\n      return finish(); // Appends the remaining input from cursor to the end into\n      // row, saves the row, calls step, and returns the results.\n\n      function finish() {\n        row.push(input.substr(cursor));\n        data.push(row);\n        cursor = inputLen; // important in case parsing is paused\n\n        if (stepIsFunction) doStep();\n        return returnable();\n      } // Appends the current row to the results. It sets the cursor\n      // to newCursor and finds the nextNewline. The caller should\n      // take care to execute user's step function and check for\n      // preview and end parsing if necessary.\n\n\n      function saveRow(newCursor) {\n        data.push(row);\n        row = [];\n        cursor = newCursor;\n        nextNewline = input.indexOf(newline, cursor);\n      } // Returns an object with the results, errors, and meta.\n\n\n      function returnable(stopped) {\n        return {\n          data: data,\n          errors: errors,\n          meta: {\n            delimiter: delim,\n            linebreak: newline,\n            aborted: aborted,\n            truncated: !!stopped\n          }\n        };\n      } // Executes the user's step function and resets data & errors.\n\n\n      function doStep() {\n        step(returnable());\n        data = [], errors = [];\n      }\n    }; // Sets the abort flag\n\n\n    this.abort = function () {\n      aborted = true;\n    }; // Gets the cursor position\n\n\n    this.getCharIndex = function () {\n      return cursor;\n    };\n  } // Replaces bad config values with good, default ones\n\n\n  function copyAndValidateConfig(origConfig) {\n    if (typeof origConfig !== 'object') origConfig = {};\n    var config = copy(origConfig);\n    if (typeof config.delimiter !== 'string' || config.delimiter.length != 1 || Baby.BAD_DELIMITERS.indexOf(config.delimiter) > -1) config.delimiter = DEFAULTS.delimiter;\n    if (config.newline != '\\n' && config.newline != '\\r' && config.newline != '\\r\\n') config.newline = DEFAULTS.newline;\n    if (typeof config.header !== 'boolean') config.header = DEFAULTS.header;\n    if (typeof config.dynamicTyping !== 'boolean') config.dynamicTyping = DEFAULTS.dynamicTyping;\n    if (typeof config.preview !== 'number') config.preview = DEFAULTS.preview;\n    if (typeof config.step !== 'function') config.step = DEFAULTS.step;\n    if (typeof config.complete !== 'function') config.complete = DEFAULTS.complete;\n    if (typeof config.skipEmptyLines !== 'boolean') config.skipEmptyLines = DEFAULTS.skipEmptyLines;\n    if (typeof config.fastMode !== 'boolean') config.fastMode = DEFAULTS.fastMode;\n    return config;\n  }\n\n  function copy(obj) {\n    if (typeof obj !== 'object') return obj;\n    var cpy = obj instanceof Array ? [] : {};\n\n    for (var key in obj) cpy[key] = copy(obj[key]);\n\n    return cpy;\n  }\n\n  function isFunction(func) {\n    return typeof func === 'function';\n  } // export to Node...\n\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = Baby;\n  } // ...or as AMD module...\n  else if (typeof define === 'function' && define.amd) {\n      define(function () {\n        return Baby;\n      });\n    } // ...or as browser global\n    else {\n        global.Baby = Baby;\n      }\n})(typeof window !== 'undefined' ? window : this);","map":null,"metadata":{},"sourceType":"script"}