{"ast":null,"code":"'use strict';\n\nvar $ = require('./$'),\n    ctx = require('./$.ctx'),\n    $export = require('./$.export'),\n    createDesc = require('./$.property-desc'),\n    assign = require('./$.object-assign'),\n    keyOf = require('./$.keyof'),\n    aFunction = require('./$.a-function'),\n    forOf = require('./$.for-of'),\n    isIterable = require('./core.is-iterable'),\n    $iterCreate = require('./$.iter-create'),\n    step = require('./$.iter-step'),\n    isObject = require('./$.is-object'),\n    toIObject = require('./$.to-iobject'),\n    DESCRIPTORS = require('./$.descriptors'),\n    has = require('./$.has'),\n    getKeys = $.getKeys; // 0 -> Dict.forEach\n// 1 -> Dict.map\n// 2 -> Dict.filter\n// 3 -> Dict.some\n// 4 -> Dict.every\n// 5 -> Dict.find\n// 6 -> Dict.findKey\n// 7 -> Dict.mapPairs\n\n\nvar createDictMethod = function (TYPE) {\n  var IS_MAP = TYPE == 1,\n      IS_EVERY = TYPE == 4;\n  return function (object, callbackfn, that\n  /* = undefined */\n  ) {\n    var f = ctx(callbackfn, that, 3),\n        O = toIObject(object),\n        result = IS_MAP || TYPE == 7 || TYPE == 2 ? new (typeof this == 'function' ? this : Dict)() : undefined,\n        key,\n        val,\n        res;\n\n    for (key in O) if (has(O, key)) {\n      val = O[key];\n      res = f(val, key, object);\n\n      if (TYPE) {\n        if (IS_MAP) result[key] = res; // map\n        else if (res) switch (TYPE) {\n            case 2:\n              result[key] = val;\n              break;\n            // filter\n\n            case 3:\n              return true;\n            // some\n\n            case 5:\n              return val;\n            // find\n\n            case 6:\n              return key;\n            // findKey\n\n            case 7:\n              result[res[0]] = res[1];\n            // mapPairs\n          } else if (IS_EVERY) return false; // every\n      }\n    }\n\n    return TYPE == 3 || IS_EVERY ? IS_EVERY : result;\n  };\n};\n\nvar findKey = createDictMethod(6);\n\nvar createDictIter = function (kind) {\n  return function (it) {\n    return new DictIterator(it, kind);\n  };\n};\n\nvar DictIterator = function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n\n  this._a = getKeys(iterated); // keys\n\n  this._i = 0; // next index\n\n  this._k = kind; // kind\n};\n\n$iterCreate(DictIterator, 'Dict', function () {\n  var that = this,\n      O = that._t,\n      keys = that._a,\n      kind = that._k,\n      key;\n\n  do {\n    if (that._i >= keys.length) {\n      that._t = undefined;\n      return step(1);\n    }\n  } while (!has(O, key = keys[that._i++]));\n\n  if (kind == 'keys') return step(0, key);\n  if (kind == 'values') return step(0, O[key]);\n  return step(0, [key, O[key]]);\n});\n\nfunction Dict(iterable) {\n  var dict = $.create(null);\n\n  if (iterable != undefined) {\n    if (isIterable(iterable)) {\n      forOf(iterable, true, function (key, value) {\n        dict[key] = value;\n      });\n    } else assign(dict, iterable);\n  }\n\n  return dict;\n}\n\nDict.prototype = null;\n\nfunction reduce(object, mapfn, init) {\n  aFunction(mapfn);\n  var O = toIObject(object),\n      keys = getKeys(O),\n      length = keys.length,\n      i = 0,\n      memo,\n      key;\n\n  if (arguments.length < 3) {\n    if (!length) throw TypeError('Reduce of empty object with no initial value');\n    memo = O[keys[i++]];\n  } else memo = Object(init);\n\n  while (length > i) if (has(O, key = keys[i++])) {\n    memo = mapfn(memo, O[key], key, object);\n  }\n\n  return memo;\n}\n\nfunction includes(object, el) {\n  return (el == el ? keyOf(object, el) : findKey(object, function (it) {\n    return it != it;\n  })) !== undefined;\n}\n\nfunction get(object, key) {\n  if (has(object, key)) return object[key];\n}\n\nfunction set(object, key, value) {\n  if (DESCRIPTORS && key in Object) $.setDesc(object, key, createDesc(0, value));else object[key] = value;\n  return object;\n}\n\nfunction isDict(it) {\n  return isObject(it) && $.getProto(it) === Dict.prototype;\n}\n\n$export($export.G + $export.F, {\n  Dict: Dict\n});\n$export($export.S, 'Dict', {\n  keys: createDictIter('keys'),\n  values: createDictIter('values'),\n  entries: createDictIter('entries'),\n  forEach: createDictMethod(0),\n  map: createDictMethod(1),\n  filter: createDictMethod(2),\n  some: createDictMethod(3),\n  every: createDictMethod(4),\n  find: createDictMethod(5),\n  findKey: findKey,\n  mapPairs: createDictMethod(7),\n  reduce: reduce,\n  keyOf: keyOf,\n  includes: includes,\n  has: has,\n  get: get,\n  set: set,\n  isDict: isDict\n});","map":null,"metadata":{},"sourceType":"script"}